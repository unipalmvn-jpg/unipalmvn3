"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@trpc+server@11.7.1_typescript@5.9.3";
exports.ids = ["vendor-chunks/@trpc+server@11.7.1_typescript@5.9.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/getErrorShape-BH60iMC2.mjs":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/getErrorShape-BH60iMC2.mjs ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HTTP_CODE_TO_JSONRPC2: () => (/* binding */ HTTP_CODE_TO_JSONRPC2),\n/* harmony export */   JSONRPC2_TO_HTTP_CODE: () => (/* binding */ JSONRPC2_TO_HTTP_CODE),\n/* harmony export */   __commonJS: () => (/* binding */ __commonJS),\n/* harmony export */   __toESM: () => (/* binding */ __toESM),\n/* harmony export */   createFlatProxy: () => (/* binding */ createFlatProxy),\n/* harmony export */   createRecursiveProxy: () => (/* binding */ createRecursiveProxy),\n/* harmony export */   getErrorShape: () => (/* binding */ getErrorShape),\n/* harmony export */   getHTTPStatusCode: () => (/* binding */ getHTTPStatusCode),\n/* harmony export */   getHTTPStatusCodeFromError: () => (/* binding */ getHTTPStatusCodeFromError),\n/* harmony export */   getStatusCodeFromKey: () => (/* binding */ getStatusCodeFromKey),\n/* harmony export */   getStatusKeyFromCode: () => (/* binding */ getStatusKeyFromCode),\n/* harmony export */   require_defineProperty: () => (/* binding */ require_defineProperty),\n/* harmony export */   require_objectSpread2: () => (/* binding */ require_objectSpread2)\n/* harmony export */ });\n/* harmony import */ var _utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-CLZnJdb_.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/utils-CLZnJdb_.mjs\");\n\n\n//#region rolldown:runtime\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function() {\n\treturn mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n\tif (from && typeof from === \"object\" || typeof from === \"function\") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {\n\t\tkey = keys[i];\n\t\tif (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {\n\t\t\tget: ((k) => from[k]).bind(null, key),\n\t\t\tenumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable\n\t\t});\n\t}\n\treturn to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", {\n\tvalue: mod,\n\tenumerable: true\n}) : target, mod));\n\n//#endregion\n//#region src/unstable-core-do-not-import/createProxy.ts\nconst noop = () => {};\nconst freezeIfAvailable = (obj) => {\n\tif (Object.freeze) Object.freeze(obj);\n};\nfunction createInnerProxy(callback, path, memo) {\n\tvar _memo$cacheKey;\n\tconst cacheKey = path.join(\".\");\n\t(_memo$cacheKey = memo[cacheKey]) !== null && _memo$cacheKey !== void 0 || (memo[cacheKey] = new Proxy(noop, {\n\t\tget(_obj, key) {\n\t\t\tif (typeof key !== \"string\" || key === \"then\") return void 0;\n\t\t\treturn createInnerProxy(callback, [...path, key], memo);\n\t\t},\n\t\tapply(_1, _2, args) {\n\t\t\tconst lastOfPath = path[path.length - 1];\n\t\t\tlet opts = {\n\t\t\t\targs,\n\t\t\t\tpath\n\t\t\t};\n\t\t\tif (lastOfPath === \"call\") opts = {\n\t\t\t\targs: args.length >= 2 ? [args[1]] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\telse if (lastOfPath === \"apply\") opts = {\n\t\t\t\targs: args.length >= 2 ? args[1] : [],\n\t\t\t\tpath: path.slice(0, -1)\n\t\t\t};\n\t\t\tfreezeIfAvailable(opts.args);\n\t\t\tfreezeIfAvailable(opts.path);\n\t\t\treturn callback(opts);\n\t\t}\n\t}));\n\treturn memo[cacheKey];\n}\n/**\n* Creates a proxy that calls the callback with the path and arguments\n*\n* @internal\n*/\nconst createRecursiveProxy = (callback) => createInnerProxy(callback, [], Object.create(null));\n/**\n* Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n*\n* @internal\n*/\nconst createFlatProxy = (callback) => {\n\treturn new Proxy(noop, { get(_obj, name) {\n\t\tif (name === \"then\") return void 0;\n\t\treturn callback(name);\n\t} });\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/getHTTPStatusCode.ts\nconst JSONRPC2_TO_HTTP_CODE = {\n\tPARSE_ERROR: 400,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_SUPPORTED: 405,\n\tTIMEOUT: 408,\n\tCONFLICT: 409,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tUNPROCESSABLE_CONTENT: 422,\n\tPRECONDITION_REQUIRED: 428,\n\tTOO_MANY_REQUESTS: 429,\n\tCLIENT_CLOSED_REQUEST: 499,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504\n};\nconst HTTP_CODE_TO_JSONRPC2 = {\n\t400: \"BAD_REQUEST\",\n\t401: \"UNAUTHORIZED\",\n\t402: \"PAYMENT_REQUIRED\",\n\t403: \"FORBIDDEN\",\n\t404: \"NOT_FOUND\",\n\t405: \"METHOD_NOT_SUPPORTED\",\n\t408: \"TIMEOUT\",\n\t409: \"CONFLICT\",\n\t412: \"PRECONDITION_FAILED\",\n\t413: \"PAYLOAD_TOO_LARGE\",\n\t415: \"UNSUPPORTED_MEDIA_TYPE\",\n\t422: \"UNPROCESSABLE_CONTENT\",\n\t428: \"PRECONDITION_REQUIRED\",\n\t429: \"TOO_MANY_REQUESTS\",\n\t499: \"CLIENT_CLOSED_REQUEST\",\n\t500: \"INTERNAL_SERVER_ERROR\",\n\t501: \"NOT_IMPLEMENTED\",\n\t502: \"BAD_GATEWAY\",\n\t503: \"SERVICE_UNAVAILABLE\",\n\t504: \"GATEWAY_TIMEOUT\"\n};\nfunction getStatusCodeFromKey(code) {\n\tvar _JSONRPC2_TO_HTTP_COD;\n\treturn (_JSONRPC2_TO_HTTP_COD = JSONRPC2_TO_HTTP_CODE[code]) !== null && _JSONRPC2_TO_HTTP_COD !== void 0 ? _JSONRPC2_TO_HTTP_COD : 500;\n}\nfunction getStatusKeyFromCode(code) {\n\tvar _HTTP_CODE_TO_JSONRPC;\n\treturn (_HTTP_CODE_TO_JSONRPC = HTTP_CODE_TO_JSONRPC2[code]) !== null && _HTTP_CODE_TO_JSONRPC !== void 0 ? _HTTP_CODE_TO_JSONRPC : \"INTERNAL_SERVER_ERROR\";\n}\nfunction getHTTPStatusCode(json) {\n\tconst arr = Array.isArray(json) ? json : [json];\n\tconst httpStatuses = new Set(arr.map((res) => {\n\t\tif (\"error\" in res && (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(res.error.data)) {\n\t\t\tvar _res$error$data;\n\t\t\tif (typeof ((_res$error$data = res.error.data) === null || _res$error$data === void 0 ? void 0 : _res$error$data[\"httpStatus\"]) === \"number\") return res.error.data[\"httpStatus\"];\n\t\t\tconst code = _utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_NUMBER[res.error.code];\n\t\t\treturn getStatusCodeFromKey(code);\n\t\t}\n\t\treturn 200;\n\t}));\n\tif (httpStatuses.size !== 1) return 207;\n\tconst httpStatus = httpStatuses.values().next().value;\n\treturn httpStatus;\n}\nfunction getHTTPStatusCodeFromError(error) {\n\treturn getStatusCodeFromKey(error.code);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\nvar require_typeof = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/typeof.js\"(exports, module) {\n\tfunction _typeof$2(o) {\n\t\t\"@babel/helpers - typeof\";\n\t\treturn module.exports = _typeof$2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o$1) {\n\t\t\treturn typeof o$1;\n\t\t} : function(o$1) {\n\t\t\treturn o$1 && \"function\" == typeof Symbol && o$1.constructor === Symbol && o$1 !== Symbol.prototype ? \"symbol\" : typeof o$1;\n\t\t}, module.exports.__esModule = true, module.exports[\"default\"] = module.exports, _typeof$2(o);\n\t}\n\tmodule.exports = _typeof$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\nvar require_toPrimitive = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPrimitive.js\"(exports, module) {\n\tvar _typeof$1 = require_typeof()[\"default\"];\n\tfunction toPrimitive$1(t, r) {\n\t\tif (\"object\" != _typeof$1(t) || !t) return t;\n\t\tvar e = t[Symbol.toPrimitive];\n\t\tif (void 0 !== e) {\n\t\t\tvar i = e.call(t, r || \"default\");\n\t\t\tif (\"object\" != _typeof$1(i)) return i;\n\t\t\tthrow new TypeError(\"@@toPrimitive must return a primitive value.\");\n\t\t}\n\t\treturn (\"string\" === r ? String : Number)(t);\n\t}\n\tmodule.exports = toPrimitive$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\nvar require_toPropertyKey = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/toPropertyKey.js\"(exports, module) {\n\tvar _typeof = require_typeof()[\"default\"];\n\tvar toPrimitive = require_toPrimitive();\n\tfunction toPropertyKey$1(t) {\n\t\tvar i = toPrimitive(t, \"string\");\n\t\treturn \"symbol\" == _typeof(i) ? i : i + \"\";\n\t}\n\tmodule.exports = toPropertyKey$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\nvar require_defineProperty = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/defineProperty.js\"(exports, module) {\n\tvar toPropertyKey = require_toPropertyKey();\n\tfunction _defineProperty(e, r, t) {\n\t\treturn (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n\t\t\tvalue: t,\n\t\t\tenumerable: !0,\n\t\t\tconfigurable: !0,\n\t\t\twritable: !0\n\t\t}) : e[r] = t, e;\n\t}\n\tmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\nvar require_objectSpread2 = __commonJS({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/objectSpread2.js\"(exports, module) {\n\tvar defineProperty = require_defineProperty();\n\tfunction ownKeys(e, r) {\n\t\tvar t = Object.keys(e);\n\t\tif (Object.getOwnPropertySymbols) {\n\t\t\tvar o = Object.getOwnPropertySymbols(e);\n\t\t\tr && (o = o.filter(function(r$1) {\n\t\t\t\treturn Object.getOwnPropertyDescriptor(e, r$1).enumerable;\n\t\t\t})), t.push.apply(t, o);\n\t\t}\n\t\treturn t;\n\t}\n\tfunction _objectSpread2(e) {\n\t\tfor (var r = 1; r < arguments.length; r++) {\n\t\t\tvar t = null != arguments[r] ? arguments[r] : {};\n\t\t\tr % 2 ? ownKeys(Object(t), !0).forEach(function(r$1) {\n\t\t\t\tdefineProperty(e, r$1, t[r$1]);\n\t\t\t}) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r$1) {\n\t\t\t\tObject.defineProperty(e, r$1, Object.getOwnPropertyDescriptor(t, r$1));\n\t\t\t});\n\t\t}\n\t\treturn e;\n\t}\n\tmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/getErrorShape.ts\nvar import_objectSpread2 = __toESM(require_objectSpread2(), 1);\n/**\n* @internal\n*/\nfunction getErrorShape(opts) {\n\tconst { path, error, config } = opts;\n\tconst { code } = opts.error;\n\tconst shape = {\n\t\tmessage: error.message,\n\t\tcode: _utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.TRPC_ERROR_CODES_BY_KEY[code],\n\t\tdata: {\n\t\t\tcode,\n\t\t\thttpStatus: getHTTPStatusCodeFromError(error)\n\t\t}\n\t};\n\tif (config.isDev && typeof opts.error.stack === \"string\") shape.data.stack = opts.error.stack;\n\tif (typeof path === \"string\") shape.data.path = path;\n\treturn config.errorFormatter((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, opts), {}, { shape }));\n}\n\n//#endregion\n\n//# sourceMappingURL=getErrorShape-BH60iMC2.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9nZXRFcnJvclNoYXBlLUJINjBpTUMyLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFxRzs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0E7QUFDQSwySUFBMkksT0FBTztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0REFBUTtBQUNoQztBQUNBO0FBQ0EsZ0JBQWdCLDBFQUEwQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxzQkFBc0I7QUFDL0IsU0FBUyxPQUFPO0FBQ2hCO0FBQ0E7QUFDQSxRQUFRLHVFQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxXQUFXLElBQUksT0FBTztBQUMxSDs7QUFFQTtBQUM2UTtBQUM3USIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoZXJpY1xcZHlhZC1hcHBzXFxyb3JrLXVuaXBhbG0tLS1DaC1uZy1uLW5nLWMtR3UtY29weVxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zXFxub2RlX21vZHVsZXNcXEB0cnBjXFxzZXJ2ZXJcXGRpc3RcXGdldEVycm9yU2hhcGUtQkg2MGlNQzIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRSUENfRVJST1JfQ09ERVNfQllfS0VZLCBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiwgaXNPYmplY3QgfSBmcm9tIFwiLi91dGlscy1DTFpuSmRiXy5tanNcIjtcblxuLy8jcmVnaW9uIHJvbGxkb3duOnJ1bnRpbWVcbnZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbigpIHtcblx0cmV0dXJuIG1vZCB8fCAoMCwgY2JbX19nZXRPd25Qcm9wTmFtZXMoY2IpWzBdXSkoKG1vZCA9IHsgZXhwb3J0czoge30gfSkuZXhwb3J0cywgbW9kKSwgbW9kLmV4cG9ydHM7XG59O1xudmFyIF9fY29weVByb3BzID0gKHRvLCBmcm9tLCBleGNlcHQsIGRlc2MpID0+IHtcblx0aWYgKGZyb20gJiYgdHlwZW9mIGZyb20gPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGZyb20gPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIga2V5cyA9IF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pLCBpID0gMCwgbiA9IGtleXMubGVuZ3RoLCBrZXk7IGkgPCBuOyBpKyspIHtcblx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdGlmICghX19oYXNPd25Qcm9wLmNhbGwodG8sIGtleSkgJiYga2V5ICE9PSBleGNlcHQpIF9fZGVmUHJvcCh0bywga2V5LCB7XG5cdFx0XHRnZXQ6ICgoaykgPT4gZnJvbVtrXSkuYmluZChudWxsLCBrZXkpLFxuXHRcdFx0ZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGVcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gdG87XG59O1xudmFyIF9fdG9FU00gPSAobW9kLCBpc05vZGVNb2RlLCB0YXJnZXQpID0+ICh0YXJnZXQgPSBtb2QgIT0gbnVsbCA/IF9fY3JlYXRlKF9fZ2V0UHJvdG9PZihtb2QpKSA6IHt9LCBfX2NvcHlQcm9wcyhpc05vZGVNb2RlIHx8ICFtb2QgfHwgIW1vZC5fX2VzTW9kdWxlID8gX19kZWZQcm9wKHRhcmdldCwgXCJkZWZhdWx0XCIsIHtcblx0dmFsdWU6IG1vZCxcblx0ZW51bWVyYWJsZTogdHJ1ZVxufSkgOiB0YXJnZXQsIG1vZCkpO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2NyZWF0ZVByb3h5LnRzXG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBmcmVlemVJZkF2YWlsYWJsZSA9IChvYmopID0+IHtcblx0aWYgKE9iamVjdC5mcmVlemUpIE9iamVjdC5mcmVlemUob2JqKTtcbn07XG5mdW5jdGlvbiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBwYXRoLCBtZW1vKSB7XG5cdHZhciBfbWVtbyRjYWNoZUtleTtcblx0Y29uc3QgY2FjaGVLZXkgPSBwYXRoLmpvaW4oXCIuXCIpO1xuXHQoX21lbW8kY2FjaGVLZXkgPSBtZW1vW2NhY2hlS2V5XSkgIT09IG51bGwgJiYgX21lbW8kY2FjaGVLZXkgIT09IHZvaWQgMCB8fCAobWVtb1tjYWNoZUtleV0gPSBuZXcgUHJveHkobm9vcCwge1xuXHRcdGdldChfb2JqLCBrZXkpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ICE9PSBcInN0cmluZ1wiIHx8IGtleSA9PT0gXCJ0aGVuXCIpIHJldHVybiB2b2lkIDA7XG5cdFx0XHRyZXR1cm4gY3JlYXRlSW5uZXJQcm94eShjYWxsYmFjaywgWy4uLnBhdGgsIGtleV0sIG1lbW8pO1xuXHRcdH0sXG5cdFx0YXBwbHkoXzEsIF8yLCBhcmdzKSB7XG5cdFx0XHRjb25zdCBsYXN0T2ZQYXRoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXHRcdFx0bGV0IG9wdHMgPSB7XG5cdFx0XHRcdGFyZ3MsXG5cdFx0XHRcdHBhdGhcblx0XHRcdH07XG5cdFx0XHRpZiAobGFzdE9mUGF0aCA9PT0gXCJjYWxsXCIpIG9wdHMgPSB7XG5cdFx0XHRcdGFyZ3M6IGFyZ3MubGVuZ3RoID49IDIgPyBbYXJnc1sxXV0gOiBbXSxcblx0XHRcdFx0cGF0aDogcGF0aC5zbGljZSgwLCAtMSlcblx0XHRcdH07XG5cdFx0XHRlbHNlIGlmIChsYXN0T2ZQYXRoID09PSBcImFwcGx5XCIpIG9wdHMgPSB7XG5cdFx0XHRcdGFyZ3M6IGFyZ3MubGVuZ3RoID49IDIgPyBhcmdzWzFdIDogW10sXG5cdFx0XHRcdHBhdGg6IHBhdGguc2xpY2UoMCwgLTEpXG5cdFx0XHR9O1xuXHRcdFx0ZnJlZXplSWZBdmFpbGFibGUob3B0cy5hcmdzKTtcblx0XHRcdGZyZWV6ZUlmQXZhaWxhYmxlKG9wdHMucGF0aCk7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2sob3B0cyk7XG5cdFx0fVxuXHR9KSk7XG5cdHJldHVybiBtZW1vW2NhY2hlS2V5XTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgcHJveHkgdGhhdCBjYWxscyB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcGF0aCBhbmQgYXJndW1lbnRzXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmNvbnN0IGNyZWF0ZVJlY3Vyc2l2ZVByb3h5ID0gKGNhbGxiYWNrKSA9PiBjcmVhdGVJbm5lclByb3h5KGNhbGxiYWNrLCBbXSwgT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4vKipcbiogVXNlZCBpbiBwbGFjZSBvZiBgbmV3IFByb3h5YCB3aGVyZSBlYWNoIGhhbmRsZXIgd2lsbCBtYXAgMSBsZXZlbCBkZWVwIHRvIGFub3RoZXIgdmFsdWUuXG4qXG4qIEBpbnRlcm5hbFxuKi9cbmNvbnN0IGNyZWF0ZUZsYXRQcm94eSA9IChjYWxsYmFjaykgPT4ge1xuXHRyZXR1cm4gbmV3IFByb3h5KG5vb3AsIHsgZ2V0KF9vYmosIG5hbWUpIHtcblx0XHRpZiAobmFtZSA9PT0gXCJ0aGVuXCIpIHJldHVybiB2b2lkIDA7XG5cdFx0cmV0dXJuIGNhbGxiYWNrKG5hbWUpO1xuXHR9IH0pO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9odHRwL2dldEhUVFBTdGF0dXNDb2RlLnRzXG5jb25zdCBKU09OUlBDMl9UT19IVFRQX0NPREUgPSB7XG5cdFBBUlNFX0VSUk9SOiA0MDAsXG5cdEJBRF9SRVFVRVNUOiA0MDAsXG5cdFVOQVVUSE9SSVpFRDogNDAxLFxuXHRQQVlNRU5UX1JFUVVJUkVEOiA0MDIsXG5cdEZPUkJJRERFTjogNDAzLFxuXHROT1RfRk9VTkQ6IDQwNCxcblx0TUVUSE9EX05PVF9TVVBQT1JURUQ6IDQwNSxcblx0VElNRU9VVDogNDA4LFxuXHRDT05GTElDVDogNDA5LFxuXHRQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG5cdFBBWUxPQURfVE9PX0xBUkdFOiA0MTMsXG5cdFVOU1VQUE9SVEVEX01FRElBX1RZUEU6IDQxNSxcblx0VU5QUk9DRVNTQUJMRV9DT05URU5UOiA0MjIsXG5cdFBSRUNPTkRJVElPTl9SRVFVSVJFRDogNDI4LFxuXHRUT09fTUFOWV9SRVFVRVNUUzogNDI5LFxuXHRDTElFTlRfQ0xPU0VEX1JFUVVFU1Q6IDQ5OSxcblx0SU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG5cdE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuXHRCQURfR0FURVdBWTogNTAyLFxuXHRTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG5cdEdBVEVXQVlfVElNRU9VVDogNTA0XG59O1xuY29uc3QgSFRUUF9DT0RFX1RPX0pTT05SUEMyID0ge1xuXHQ0MDA6IFwiQkFEX1JFUVVFU1RcIixcblx0NDAxOiBcIlVOQVVUSE9SSVpFRFwiLFxuXHQ0MDI6IFwiUEFZTUVOVF9SRVFVSVJFRFwiLFxuXHQ0MDM6IFwiRk9SQklEREVOXCIsXG5cdDQwNDogXCJOT1RfRk9VTkRcIixcblx0NDA1OiBcIk1FVEhPRF9OT1RfU1VQUE9SVEVEXCIsXG5cdDQwODogXCJUSU1FT1VUXCIsXG5cdDQwOTogXCJDT05GTElDVFwiLFxuXHQ0MTI6IFwiUFJFQ09ORElUSU9OX0ZBSUxFRFwiLFxuXHQ0MTM6IFwiUEFZTE9BRF9UT09fTEFSR0VcIixcblx0NDE1OiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0NDIyOiBcIlVOUFJPQ0VTU0FCTEVfQ09OVEVOVFwiLFxuXHQ0Mjg6IFwiUFJFQ09ORElUSU9OX1JFUVVJUkVEXCIsXG5cdDQyOTogXCJUT09fTUFOWV9SRVFVRVNUU1wiLFxuXHQ0OTk6IFwiQ0xJRU5UX0NMT1NFRF9SRVFVRVNUXCIsXG5cdDUwMDogXCJJTlRFUk5BTF9TRVJWRVJfRVJST1JcIixcblx0NTAxOiBcIk5PVF9JTVBMRU1FTlRFRFwiLFxuXHQ1MDI6IFwiQkFEX0dBVEVXQVlcIixcblx0NTAzOiBcIlNFUlZJQ0VfVU5BVkFJTEFCTEVcIixcblx0NTA0OiBcIkdBVEVXQVlfVElNRU9VVFwiXG59O1xuZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSkge1xuXHR2YXIgX0pTT05SUEMyX1RPX0hUVFBfQ09EO1xuXHRyZXR1cm4gKF9KU09OUlBDMl9UT19IVFRQX0NPRCA9IEpTT05SUEMyX1RPX0hUVFBfQ09ERVtjb2RlXSkgIT09IG51bGwgJiYgX0pTT05SUEMyX1RPX0hUVFBfQ09EICE9PSB2b2lkIDAgPyBfSlNPTlJQQzJfVE9fSFRUUF9DT0QgOiA1MDA7XG59XG5mdW5jdGlvbiBnZXRTdGF0dXNLZXlGcm9tQ29kZShjb2RlKSB7XG5cdHZhciBfSFRUUF9DT0RFX1RPX0pTT05SUEM7XG5cdHJldHVybiAoX0hUVFBfQ09ERV9UT19KU09OUlBDID0gSFRUUF9DT0RFX1RPX0pTT05SUEMyW2NvZGVdKSAhPT0gbnVsbCAmJiBfSFRUUF9DT0RFX1RPX0pTT05SUEMgIT09IHZvaWQgMCA/IF9IVFRQX0NPREVfVE9fSlNPTlJQQyA6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCI7XG59XG5mdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZShqc29uKSB7XG5cdGNvbnN0IGFyciA9IEFycmF5LmlzQXJyYXkoanNvbikgPyBqc29uIDogW2pzb25dO1xuXHRjb25zdCBodHRwU3RhdHVzZXMgPSBuZXcgU2V0KGFyci5tYXAoKHJlcykgPT4ge1xuXHRcdGlmIChcImVycm9yXCIgaW4gcmVzICYmIGlzT2JqZWN0KHJlcy5lcnJvci5kYXRhKSkge1xuXHRcdFx0dmFyIF9yZXMkZXJyb3IkZGF0YTtcblx0XHRcdGlmICh0eXBlb2YgKChfcmVzJGVycm9yJGRhdGEgPSByZXMuZXJyb3IuZGF0YSkgPT09IG51bGwgfHwgX3JlcyRlcnJvciRkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVzJGVycm9yJGRhdGFbXCJodHRwU3RhdHVzXCJdKSA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHJlcy5lcnJvci5kYXRhW1wiaHR0cFN0YXR1c1wiXTtcblx0XHRcdGNvbnN0IGNvZGUgPSBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUltyZXMuZXJyb3IuY29kZV07XG5cdFx0XHRyZXR1cm4gZ2V0U3RhdHVzQ29kZUZyb21LZXkoY29kZSk7XG5cdFx0fVxuXHRcdHJldHVybiAyMDA7XG5cdH0pKTtcblx0aWYgKGh0dHBTdGF0dXNlcy5zaXplICE9PSAxKSByZXR1cm4gMjA3O1xuXHRjb25zdCBodHRwU3RhdHVzID0gaHR0cFN0YXR1c2VzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblx0cmV0dXJuIGh0dHBTdGF0dXM7XG59XG5mdW5jdGlvbiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcikge1xuXHRyZXR1cm4gZ2V0U3RhdHVzQ29kZUZyb21LZXkoZXJyb3IuY29kZSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3R5cGVvZi5qc1xudmFyIHJlcXVpcmVfdHlwZW9mID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdHlwZW9mLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdGZ1bmN0aW9uIF90eXBlb2YkMihvKSB7XG5cdFx0XCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YkMiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uKG8kMSkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBvJDE7XG5cdFx0fSA6IGZ1bmN0aW9uKG8kMSkge1xuXHRcdFx0cmV0dXJuIG8kMSAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvJDEuY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvJDEgIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG8kMTtcblx0XHR9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIF90eXBlb2YkMihvKTtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YkMiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSB9KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcbnZhciByZXF1aXJlX3RvUHJpbWl0aXZlID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvdG9QcmltaXRpdmUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIF90eXBlb2YkMSA9IHJlcXVpcmVfdHlwZW9mKClbXCJkZWZhdWx0XCJdO1xuXHRmdW5jdGlvbiB0b1ByaW1pdGl2ZSQxKHQsIHIpIHtcblx0XHRpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mJDEodCkgfHwgIXQpIHJldHVybiB0O1xuXHRcdHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuXHRcdGlmICh2b2lkIDAgIT09IGUpIHtcblx0XHRcdHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuXHRcdFx0aWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZiQxKGkpKSByZXR1cm4gaTtcblx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcblx0XHR9XG5cdFx0cmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IHRvUHJpbWl0aXZlJDEsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3RvUHJvcGVydHlLZXkuanNcbnZhciByZXF1aXJlX3RvUHJvcGVydHlLZXkgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBfdHlwZW9mID0gcmVxdWlyZV90eXBlb2YoKVtcImRlZmF1bHRcIl07XG5cdHZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmVfdG9QcmltaXRpdmUoKTtcblx0ZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSQxKHQpIHtcblx0XHR2YXIgaSA9IHRvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuXHRcdHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSB0b1Byb3BlcnR5S2V5JDEsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXG52YXIgcmVxdWlyZV9kZWZpbmVQcm9wZXJ0eSA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2RlZmluZVByb3BlcnR5LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZV90b1Byb3BlcnR5S2V5KCk7XG5cdGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG5cdFx0cmV0dXJuIChyID0gdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG5cdFx0XHR2YWx1ZTogdCxcblx0XHRcdGVudW1lcmFibGU6ICEwLFxuXHRcdFx0Y29uZmlndXJhYmxlOiAhMCxcblx0XHRcdHdyaXRhYmxlOiAhMFxuXHRcdH0pIDogZVtyXSA9IHQsIGU7XG5cdH1cblx0bW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHksIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL29iamVjdFNwcmVhZDIuanNcbnZhciByZXF1aXJlX29iamVjdFNwcmVhZDIgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9vYmplY3RTcHJlYWQyLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKTtcblx0ZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG5cdFx0dmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0dmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuXHRcdFx0ciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0XHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByJDEpLmVudW1lcmFibGU7XG5cdFx0XHR9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcblx0XHR9XG5cdFx0cmV0dXJuIHQ7XG5cdH1cblx0ZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuXHRcdGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG5cdFx0XHR2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG5cdFx0XHRyICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbihyJDEpIHtcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoZSwgciQxLCB0W3IkMV0pO1xuXHRcdFx0fSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uKHIkMSkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciQxLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIkMSkpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBlO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gX29iamVjdFNwcmVhZDIsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvZXJyb3IvZ2V0RXJyb3JTaGFwZS50c1xudmFyIGltcG9ydF9vYmplY3RTcHJlYWQyID0gX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSwgMSk7XG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZ2V0RXJyb3JTaGFwZShvcHRzKSB7XG5cdGNvbnN0IHsgcGF0aCwgZXJyb3IsIGNvbmZpZyB9ID0gb3B0cztcblx0Y29uc3QgeyBjb2RlIH0gPSBvcHRzLmVycm9yO1xuXHRjb25zdCBzaGFwZSA9IHtcblx0XHRtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuXHRcdGNvZGU6IFRSUENfRVJST1JfQ09ERVNfQllfS0VZW2NvZGVdLFxuXHRcdGRhdGE6IHtcblx0XHRcdGNvZGUsXG5cdFx0XHRodHRwU3RhdHVzOiBnZXRIVFRQU3RhdHVzQ29kZUZyb21FcnJvcihlcnJvcilcblx0XHR9XG5cdH07XG5cdGlmIChjb25maWcuaXNEZXYgJiYgdHlwZW9mIG9wdHMuZXJyb3Iuc3RhY2sgPT09IFwic3RyaW5nXCIpIHNoYXBlLmRhdGEuc3RhY2sgPSBvcHRzLmVycm9yLnN0YWNrO1xuXHRpZiAodHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIpIHNoYXBlLmRhdGEucGF0aCA9IHBhdGg7XG5cdHJldHVybiBjb25maWcuZXJyb3JGb3JtYXR0ZXIoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgb3B0cyksIHt9LCB7IHNoYXBlIH0pKTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBIVFRQX0NPREVfVE9fSlNPTlJQQzIsIEpTT05SUEMyX1RPX0hUVFBfQ09ERSwgX19jb21tb25KUywgX190b0VTTSwgY3JlYXRlRmxhdFByb3h5LCBjcmVhdGVSZWN1cnNpdmVQcm94eSwgZ2V0RXJyb3JTaGFwZSwgZ2V0SFRUUFN0YXR1c0NvZGUsIGdldEhUVFBTdGF0dXNDb2RlRnJvbUVycm9yLCBnZXRTdGF0dXNDb2RlRnJvbUtleSwgZ2V0U3RhdHVzS2V5RnJvbUNvZGUsIHJlcXVpcmVfZGVmaW5lUHJvcGVydHksIHJlcXVpcmVfb2JqZWN0U3ByZWFkMiB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0RXJyb3JTaGFwZS1CSDYwaU1DMi5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/getErrorShape-BH60iMC2.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   behaviorSubject: () => (/* binding */ behaviorSubject),\n/* harmony export */   distinctUntilChanged: () => (/* binding */ distinctUntilChanged),\n/* harmony export */   distinctUntilDeepChanged: () => (/* binding */ distinctUntilDeepChanged),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   share: () => (/* binding */ share),\n/* harmony export */   tap: () => (/* binding */ tap)\n/* harmony export */ });\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\");\n\n\n//#region src/observable/operators.ts\nfunction map(project) {\n\treturn (source) => {\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\tlet index = 0;\n\t\t\tconst subscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tdestination.next(project(value, index++));\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn subscription;\n\t\t});\n\t};\n}\nfunction share(_opts) {\n\treturn (source) => {\n\t\tlet refCount = 0;\n\t\tlet subscription = null;\n\t\tconst observers = [];\n\t\tfunction startIfNeeded() {\n\t\t\tif (subscription) return;\n\t\t\tsubscription = source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$next;\n\t\t\t\t\t\t(_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$error;\n\t\t\t\t\t\t(_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, error);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tfor (const observer of observers) {\n\t\t\t\t\t\tvar _observer$complete;\n\t\t\t\t\t\t(_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction resetIfNeeded() {\n\t\t\tif (refCount === 0 && subscription) {\n\t\t\t\tconst _sub = subscription;\n\t\t\t\tsubscription = null;\n\t\t\t\t_sub.unsubscribe();\n\t\t\t}\n\t\t}\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((subscriber) => {\n\t\t\trefCount++;\n\t\t\tobservers.push(subscriber);\n\t\t\tstartIfNeeded();\n\t\t\treturn { unsubscribe() {\n\t\t\t\trefCount--;\n\t\t\t\tresetIfNeeded();\n\t\t\t\tconst index = observers.findIndex((v) => v === subscriber);\n\t\t\t\tif (index > -1) observers.splice(index, 1);\n\t\t\t} };\n\t\t});\n\t};\n}\nfunction tap(observer) {\n\treturn (source) => {\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tvar _observer$next2;\n\t\t\t\t\t(_observer$next2 = observer.next) === null || _observer$next2 === void 0 || _observer$next2.call(observer, value);\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tvar _observer$error2;\n\t\t\t\t\t(_observer$error2 = observer.error) === null || _observer$error2 === void 0 || _observer$error2.call(observer, error);\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tvar _observer$complete2;\n\t\t\t\t\t(_observer$complete2 = observer.complete) === null || _observer$complete2 === void 0 || _observer$complete2.call(observer);\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b) => a === b) {\n\treturn (source) => {\n\t\treturn (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((destination) => {\n\t\t\tlet lastValue = distinctUnsetMarker;\n\t\t\treturn source.subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tif (lastValue !== distinctUnsetMarker && compare(lastValue, value)) return;\n\t\t\t\t\tlastValue = value;\n\t\t\t\t\tdestination.next(value);\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tdestination.error(error);\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tdestination.complete();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\nconst isDeepEqual = (a, b) => {\n\tif (a === b) return true;\n\tconst bothAreObjects = a && b && typeof a === \"object\" && typeof b === \"object\";\n\treturn !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v]) => isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n\treturn distinctUntilChanged(isDeepEqual);\n}\n\n//#endregion\n//#region src/observable/behaviorSubject.ts\n/**\n* @internal\n* An observable that maintains and provides a \"current value\" to subscribers\n* @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n*/\nfunction behaviorSubject(initialValue) {\n\tlet value = initialValue;\n\tconst observerList = [];\n\tconst addObserver = (observer) => {\n\t\tif (value !== void 0) observer.next(value);\n\t\tobserverList.push(observer);\n\t};\n\tconst removeObserver = (observer) => {\n\t\tobserverList.splice(observerList.indexOf(observer), 1);\n\t};\n\tconst obs = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_0__.observable)((observer) => {\n\t\taddObserver(observer);\n\t\treturn () => {\n\t\t\tremoveObserver(observer);\n\t\t};\n\t});\n\tobs.next = (nextValue) => {\n\t\tif (value === nextValue) return;\n\t\tvalue = nextValue;\n\t\tfor (const observer of observerList) observer.next(nextValue);\n\t};\n\tobs.get = () => value;\n\treturn obs;\n}\n\n//#endregion\n\n//# sourceMappingURL=observable-CUiPknO-.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLUNVaVBrbk8tLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXVEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxTQUFTLG1FQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtRUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1FQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDNEY7QUFDNUYiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGVyaWNcXGR5YWQtYXBwc1xccm9yay11bmlwYWxtLS0tQ2gtbmctbi1uZy1jLUd1LWNvcHlcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB0cnBjK3NlcnZlckAxMS43LjFfdHlwZXNjcmlwdEA1LjkuM1xcbm9kZV9tb2R1bGVzXFxAdHJwY1xcc2VydmVyXFxkaXN0XFxvYnNlcnZhYmxlLUNVaVBrbk8tLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBvYnNlcnZhYmxlIH0gZnJvbSBcIi4vb2JzZXJ2YWJsZS1VTU8zdlVhXy5tanNcIjtcblxuLy8jcmVnaW9uIHNyYy9vYnNlcnZhYmxlL29wZXJhdG9ycy50c1xuZnVuY3Rpb24gbWFwKHByb2plY3QpIHtcblx0cmV0dXJuIChzb3VyY2UpID0+IHtcblx0XHRyZXR1cm4gb2JzZXJ2YWJsZSgoZGVzdGluYXRpb24pID0+IHtcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRjb25zdCBzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dCh2YWx1ZSkge1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLm5leHQocHJvamVjdCh2YWx1ZSwgaW5kZXgrKykpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcihlcnJvcikge1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLmVycm9yKGVycm9yKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGUoKSB7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uY29tcGxldGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gc3Vic2NyaXB0aW9uO1xuXHRcdH0pO1xuXHR9O1xufVxuZnVuY3Rpb24gc2hhcmUoX29wdHMpIHtcblx0cmV0dXJuIChzb3VyY2UpID0+IHtcblx0XHRsZXQgcmVmQ291bnQgPSAwO1xuXHRcdGxldCBzdWJzY3JpcHRpb24gPSBudWxsO1xuXHRcdGNvbnN0IG9ic2VydmVycyA9IFtdO1xuXHRcdGZ1bmN0aW9uIHN0YXJ0SWZOZWVkZWQoKSB7XG5cdFx0XHRpZiAoc3Vic2NyaXB0aW9uKSByZXR1cm47XG5cdFx0XHRzdWJzY3JpcHRpb24gPSBzb3VyY2Uuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dCh2YWx1ZSkge1xuXHRcdFx0XHRcdGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2Ygb2JzZXJ2ZXJzKSB7XG5cdFx0XHRcdFx0XHR2YXIgX29ic2VydmVyJG5leHQ7XG5cdFx0XHRcdFx0XHQoX29ic2VydmVyJG5leHQgPSBvYnNlcnZlci5uZXh0KSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkbmV4dCA9PT0gdm9pZCAwIHx8IF9vYnNlcnZlciRuZXh0LmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGVycm9yKGVycm9yKSB7XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBvYnNlcnZlciBvZiBvYnNlcnZlcnMpIHtcblx0XHRcdFx0XHRcdHZhciBfb2JzZXJ2ZXIkZXJyb3I7XG5cdFx0XHRcdFx0XHQoX29ic2VydmVyJGVycm9yID0gb2JzZXJ2ZXIuZXJyb3IpID09PSBudWxsIHx8IF9vYnNlcnZlciRlcnJvciA9PT0gdm9pZCAwIHx8IF9vYnNlcnZlciRlcnJvci5jYWxsKG9ic2VydmVyLCBlcnJvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVycykge1xuXHRcdFx0XHRcdFx0dmFyIF9vYnNlcnZlciRjb21wbGV0ZTtcblx0XHRcdFx0XHRcdChfb2JzZXJ2ZXIkY29tcGxldGUgPSBvYnNlcnZlci5jb21wbGV0ZSkgPT09IG51bGwgfHwgX29ic2VydmVyJGNvbXBsZXRlID09PSB2b2lkIDAgfHwgX29ic2VydmVyJGNvbXBsZXRlLmNhbGwob2JzZXJ2ZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIHJlc2V0SWZOZWVkZWQoKSB7XG5cdFx0XHRpZiAocmVmQ291bnQgPT09IDAgJiYgc3Vic2NyaXB0aW9uKSB7XG5cdFx0XHRcdGNvbnN0IF9zdWIgPSBzdWJzY3JpcHRpb247XG5cdFx0XHRcdHN1YnNjcmlwdGlvbiA9IG51bGw7XG5cdFx0XHRcdF9zdWIudW5zdWJzY3JpYmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcblx0XHRcdHJlZkNvdW50Kys7XG5cdFx0XHRvYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcblx0XHRcdHN0YXJ0SWZOZWVkZWQoKTtcblx0XHRcdHJldHVybiB7IHVuc3Vic2NyaWJlKCkge1xuXHRcdFx0XHRyZWZDb3VudC0tO1xuXHRcdFx0XHRyZXNldElmTmVlZGVkKCk7XG5cdFx0XHRcdGNvbnN0IGluZGV4ID0gb2JzZXJ2ZXJzLmZpbmRJbmRleCgodikgPT4gdiA9PT0gc3Vic2NyaWJlcik7XG5cdFx0XHRcdGlmIChpbmRleCA+IC0xKSBvYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdH0gfTtcblx0XHR9KTtcblx0fTtcbn1cbmZ1bmN0aW9uIHRhcChvYnNlcnZlcikge1xuXHRyZXR1cm4gKHNvdXJjZSkgPT4ge1xuXHRcdHJldHVybiBvYnNlcnZhYmxlKChkZXN0aW5hdGlvbikgPT4ge1xuXHRcdFx0cmV0dXJuIHNvdXJjZS5zdWJzY3JpYmUoe1xuXHRcdFx0XHRuZXh0KHZhbHVlKSB7XG5cdFx0XHRcdFx0dmFyIF9vYnNlcnZlciRuZXh0Mjtcblx0XHRcdFx0XHQoX29ic2VydmVyJG5leHQyID0gb2JzZXJ2ZXIubmV4dCkgPT09IG51bGwgfHwgX29ic2VydmVyJG5leHQyID09PSB2b2lkIDAgfHwgX29ic2VydmVyJG5leHQyLmNhbGwob2JzZXJ2ZXIsIHZhbHVlKTtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHR2YXIgX29ic2VydmVyJGVycm9yMjtcblx0XHRcdFx0XHQoX29ic2VydmVyJGVycm9yMiA9IG9ic2VydmVyLmVycm9yKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkZXJyb3IyID09PSB2b2lkIDAgfHwgX29ic2VydmVyJGVycm9yMi5jYWxsKG9ic2VydmVyLCBlcnJvcik7XG5cdFx0XHRcdFx0ZGVzdGluYXRpb24uZXJyb3IoZXJyb3IpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0XHR2YXIgX29ic2VydmVyJGNvbXBsZXRlMjtcblx0XHRcdFx0XHQoX29ic2VydmVyJGNvbXBsZXRlMiA9IG9ic2VydmVyLmNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfb2JzZXJ2ZXIkY29tcGxldGUyID09PSB2b2lkIDAgfHwgX29ic2VydmVyJGNvbXBsZXRlMi5jYWxsKG9ic2VydmVyKTtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fTtcbn1cbmNvbnN0IGRpc3RpbmN0VW5zZXRNYXJrZXIgPSBTeW1ib2woKTtcbmZ1bmN0aW9uIGRpc3RpbmN0VW50aWxDaGFuZ2VkKGNvbXBhcmUgPSAoYSwgYikgPT4gYSA9PT0gYikge1xuXHRyZXR1cm4gKHNvdXJjZSkgPT4ge1xuXHRcdHJldHVybiBvYnNlcnZhYmxlKChkZXN0aW5hdGlvbikgPT4ge1xuXHRcdFx0bGV0IGxhc3RWYWx1ZSA9IGRpc3RpbmN0VW5zZXRNYXJrZXI7XG5cdFx0XHRyZXR1cm4gc291cmNlLnN1YnNjcmliZSh7XG5cdFx0XHRcdG5leHQodmFsdWUpIHtcblx0XHRcdFx0XHRpZiAobGFzdFZhbHVlICE9PSBkaXN0aW5jdFVuc2V0TWFya2VyICYmIGNvbXBhcmUobGFzdFZhbHVlLCB2YWx1ZSkpIHJldHVybjtcblx0XHRcdFx0XHRsYXN0VmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRkZXN0aW5hdGlvbi5lcnJvcihlcnJvcik7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uLmNvbXBsZXRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xufVxuY29uc3QgaXNEZWVwRXF1YWwgPSAoYSwgYikgPT4ge1xuXHRpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cdGNvbnN0IGJvdGhBcmVPYmplY3RzID0gYSAmJiBiICYmIHR5cGVvZiBhID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBiID09PSBcIm9iamVjdFwiO1xuXHRyZXR1cm4gISFib3RoQXJlT2JqZWN0cyAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCAmJiBPYmplY3QuZW50cmllcyhhKS5ldmVyeSgoW2ssIHZdKSA9PiBpc0RlZXBFcXVhbCh2LCBiW2tdKSk7XG59O1xuZnVuY3Rpb24gZGlzdGluY3RVbnRpbERlZXBDaGFuZ2VkKCkge1xuXHRyZXR1cm4gZGlzdGluY3RVbnRpbENoYW5nZWQoaXNEZWVwRXF1YWwpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvb2JzZXJ2YWJsZS9iZWhhdmlvclN1YmplY3QudHNcbi8qKlxuKiBAaW50ZXJuYWxcbiogQW4gb2JzZXJ2YWJsZSB0aGF0IG1haW50YWlucyBhbmQgcHJvdmlkZXMgYSBcImN1cnJlbnQgdmFsdWVcIiB0byBzdWJzY3JpYmVyc1xuKiBAc2VlIGh0dHBzOi8vd3d3LmxlYXJucnhqcy5pby9sZWFybi1yeGpzL3N1YmplY3RzL2JlaGF2aW9yc3ViamVjdFxuKi9cbmZ1bmN0aW9uIGJlaGF2aW9yU3ViamVjdChpbml0aWFsVmFsdWUpIHtcblx0bGV0IHZhbHVlID0gaW5pdGlhbFZhbHVlO1xuXHRjb25zdCBvYnNlcnZlckxpc3QgPSBbXTtcblx0Y29uc3QgYWRkT2JzZXJ2ZXIgPSAob2JzZXJ2ZXIpID0+IHtcblx0XHRpZiAodmFsdWUgIT09IHZvaWQgMCkgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG5cdFx0b2JzZXJ2ZXJMaXN0LnB1c2gob2JzZXJ2ZXIpO1xuXHR9O1xuXHRjb25zdCByZW1vdmVPYnNlcnZlciA9IChvYnNlcnZlcikgPT4ge1xuXHRcdG9ic2VydmVyTGlzdC5zcGxpY2Uob2JzZXJ2ZXJMaXN0LmluZGV4T2Yob2JzZXJ2ZXIpLCAxKTtcblx0fTtcblx0Y29uc3Qgb2JzID0gb2JzZXJ2YWJsZSgob2JzZXJ2ZXIpID0+IHtcblx0XHRhZGRPYnNlcnZlcihvYnNlcnZlcik7XG5cdFx0cmV0dXJuICgpID0+IHtcblx0XHRcdHJlbW92ZU9ic2VydmVyKG9ic2VydmVyKTtcblx0XHR9O1xuXHR9KTtcblx0b2JzLm5leHQgPSAobmV4dFZhbHVlKSA9PiB7XG5cdFx0aWYgKHZhbHVlID09PSBuZXh0VmFsdWUpIHJldHVybjtcblx0XHR2YWx1ZSA9IG5leHRWYWx1ZTtcblx0XHRmb3IgKGNvbnN0IG9ic2VydmVyIG9mIG9ic2VydmVyTGlzdCkgb2JzZXJ2ZXIubmV4dChuZXh0VmFsdWUpO1xuXHR9O1xuXHRvYnMuZ2V0ID0gKCkgPT4gdmFsdWU7XG5cdHJldHVybiBvYnM7XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgYmVoYXZpb3JTdWJqZWN0LCBkaXN0aW5jdFVudGlsQ2hhbmdlZCwgZGlzdGluY3RVbnRpbERlZXBDaGFuZ2VkLCBtYXAsIHNoYXJlLCB0YXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUtQ1VpUGtuTy0ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-CUiPknO-.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isObservable: () => (/* binding */ isObservable),\n/* harmony export */   observable: () => (/* binding */ observable),\n/* harmony export */   observableToAsyncIterable: () => (/* binding */ observableToAsyncIterable),\n/* harmony export */   observableToPromise: () => (/* binding */ observableToPromise)\n/* harmony export */ });\n//#region src/observable/observable.ts\n/** @public */\nfunction isObservable(x) {\n\treturn typeof x === \"object\" && x !== null && \"subscribe\" in x;\n}\n/** @public */\nfunction observable(subscribe) {\n\tconst self = {\n\t\tsubscribe(observer) {\n\t\t\tlet teardownRef = null;\n\t\t\tlet isDone = false;\n\t\t\tlet unsubscribed = false;\n\t\t\tlet teardownImmediately = false;\n\t\t\tfunction unsubscribe() {\n\t\t\t\tif (teardownRef === null) {\n\t\t\t\t\tteardownImmediately = true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (unsubscribed) return;\n\t\t\t\tunsubscribed = true;\n\t\t\t\tif (typeof teardownRef === \"function\") teardownRef();\n\t\t\t\telse if (teardownRef) teardownRef.unsubscribe();\n\t\t\t}\n\t\t\tteardownRef = subscribe({\n\t\t\t\tnext(value) {\n\t\t\t\t\tvar _observer$next;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\t(_observer$next = observer.next) === null || _observer$next === void 0 || _observer$next.call(observer, value);\n\t\t\t\t},\n\t\t\t\terror(err) {\n\t\t\t\t\tvar _observer$error;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\t(_observer$error = observer.error) === null || _observer$error === void 0 || _observer$error.call(observer, err);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tvar _observer$complete;\n\t\t\t\t\tif (isDone) return;\n\t\t\t\t\tisDone = true;\n\t\t\t\t\t(_observer$complete = observer.complete) === null || _observer$complete === void 0 || _observer$complete.call(observer);\n\t\t\t\t\tunsubscribe();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (teardownImmediately) unsubscribe();\n\t\t\treturn { unsubscribe };\n\t\t},\n\t\tpipe(...operations) {\n\t\t\treturn operations.reduce(pipeReducer, self);\n\t\t}\n\t};\n\treturn self;\n}\nfunction pipeReducer(prev, fn) {\n\treturn fn(prev);\n}\n/** @internal */\nfunction observableToPromise(observable$1) {\n\tconst ac = new AbortController();\n\tconst promise = new Promise((resolve, reject) => {\n\t\tlet isDone = false;\n\t\tfunction onDone() {\n\t\t\tif (isDone) return;\n\t\t\tisDone = true;\n\t\t\tobs$.unsubscribe();\n\t\t}\n\t\tac.signal.addEventListener(\"abort\", () => {\n\t\t\treject(ac.signal.reason);\n\t\t});\n\t\tconst obs$ = observable$1.subscribe({\n\t\t\tnext(data) {\n\t\t\t\tisDone = true;\n\t\t\t\tresolve(data);\n\t\t\t\tonDone();\n\t\t\t},\n\t\t\terror(data) {\n\t\t\t\treject(data);\n\t\t\t},\n\t\t\tcomplete() {\n\t\t\t\tac.abort();\n\t\t\t\tonDone();\n\t\t\t}\n\t\t});\n\t});\n\treturn promise;\n}\n/**\n* @internal\n*/\nfunction observableToReadableStream(observable$1, signal) {\n\tlet unsub = null;\n\tconst onAbort = () => {\n\t\tunsub === null || unsub === void 0 || unsub.unsubscribe();\n\t\tunsub = null;\n\t\tsignal.removeEventListener(\"abort\", onAbort);\n\t};\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\tunsub = observable$1.subscribe({\n\t\t\t\tnext(data) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: true,\n\t\t\t\t\t\tvalue: data\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\terror(error) {\n\t\t\t\t\tcontroller.enqueue({\n\t\t\t\t\t\tok: false,\n\t\t\t\t\t\terror\n\t\t\t\t\t});\n\t\t\t\t\tcontroller.close();\n\t\t\t\t},\n\t\t\t\tcomplete() {\n\t\t\t\t\tcontroller.close();\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener(\"abort\", onAbort, { once: true });\n\t\t},\n\t\tcancel() {\n\t\t\tonAbort();\n\t\t}\n\t});\n}\n/** @internal */\nfunction observableToAsyncIterable(observable$1, signal) {\n\tconst stream = observableToReadableStream(observable$1, signal);\n\tconst reader = stream.getReader();\n\tconst iterator = {\n\t\tasync next() {\n\t\t\tconst value = await reader.read();\n\t\t\tif (value.done) return {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t\tconst { value: result } = value;\n\t\t\tif (!result.ok) throw result.error;\n\t\t\treturn {\n\t\t\t\tvalue: result.value,\n\t\t\t\tdone: false\n\t\t\t};\n\t\t},\n\t\tasync return() {\n\t\t\tawait reader.cancel();\n\t\t\treturn {\n\t\t\t\tvalue: void 0,\n\t\t\t\tdone: true\n\t\t\t};\n\t\t}\n\t};\n\treturn { [Symbol.asyncIterator]() {\n\t\treturn iterator;\n\t} };\n}\n\n//#endregion\n\n//# sourceMappingURL=observable-UMO3vUa_.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9vYnNlcnZhYmxlLVVNTzN2VWFfLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsWUFBWTtBQUNaLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ29GO0FBQ3BGIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGhlcmljXFxkeWFkLWFwcHNcXHJvcmstdW5pcGFsbS0tLUNoLW5nLW4tbmctYy1HdS1jb3B5XFxub2RlX21vZHVsZXNcXC5wbnBtXFxAdHJwYytzZXJ2ZXJAMTEuNy4xX3R5cGVzY3JpcHRANS45LjNcXG5vZGVfbW9kdWxlc1xcQHRycGNcXHNlcnZlclxcZGlzdFxcb2JzZXJ2YWJsZS1VTU8zdlVhXy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8jcmVnaW9uIHNyYy9vYnNlcnZhYmxlL29ic2VydmFibGUudHNcbi8qKiBAcHVibGljICovXG5mdW5jdGlvbiBpc09ic2VydmFibGUoeCkge1xuXHRyZXR1cm4gdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiYgeCAhPT0gbnVsbCAmJiBcInN1YnNjcmliZVwiIGluIHg7XG59XG4vKiogQHB1YmxpYyAqL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZShzdWJzY3JpYmUpIHtcblx0Y29uc3Qgc2VsZiA9IHtcblx0XHRzdWJzY3JpYmUob2JzZXJ2ZXIpIHtcblx0XHRcdGxldCB0ZWFyZG93blJlZiA9IG51bGw7XG5cdFx0XHRsZXQgaXNEb25lID0gZmFsc2U7XG5cdFx0XHRsZXQgdW5zdWJzY3JpYmVkID0gZmFsc2U7XG5cdFx0XHRsZXQgdGVhcmRvd25JbW1lZGlhdGVseSA9IGZhbHNlO1xuXHRcdFx0ZnVuY3Rpb24gdW5zdWJzY3JpYmUoKSB7XG5cdFx0XHRcdGlmICh0ZWFyZG93blJlZiA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdHRlYXJkb3duSW1tZWRpYXRlbHkgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodW5zdWJzY3JpYmVkKSByZXR1cm47XG5cdFx0XHRcdHVuc3Vic2NyaWJlZCA9IHRydWU7XG5cdFx0XHRcdGlmICh0eXBlb2YgdGVhcmRvd25SZWYgPT09IFwiZnVuY3Rpb25cIikgdGVhcmRvd25SZWYoKTtcblx0XHRcdFx0ZWxzZSBpZiAodGVhcmRvd25SZWYpIHRlYXJkb3duUmVmLnVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9XG5cdFx0XHR0ZWFyZG93blJlZiA9IHN1YnNjcmliZSh7XG5cdFx0XHRcdG5leHQodmFsdWUpIHtcblx0XHRcdFx0XHR2YXIgX29ic2VydmVyJG5leHQ7XG5cdFx0XHRcdFx0aWYgKGlzRG9uZSkgcmV0dXJuO1xuXHRcdFx0XHRcdChfb2JzZXJ2ZXIkbmV4dCA9IG9ic2VydmVyLm5leHQpID09PSBudWxsIHx8IF9vYnNlcnZlciRuZXh0ID09PSB2b2lkIDAgfHwgX29ic2VydmVyJG5leHQuY2FsbChvYnNlcnZlciwgdmFsdWUpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlcnJvcihlcnIpIHtcblx0XHRcdFx0XHR2YXIgX29ic2VydmVyJGVycm9yO1xuXHRcdFx0XHRcdGlmIChpc0RvbmUpIHJldHVybjtcblx0XHRcdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdChfb2JzZXJ2ZXIkZXJyb3IgPSBvYnNlcnZlci5lcnJvcikgPT09IG51bGwgfHwgX29ic2VydmVyJGVycm9yID09PSB2b2lkIDAgfHwgX29ic2VydmVyJGVycm9yLmNhbGwob2JzZXJ2ZXIsIGVycik7XG5cdFx0XHRcdFx0dW5zdWJzY3JpYmUoKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Y29tcGxldGUoKSB7XG5cdFx0XHRcdFx0dmFyIF9vYnNlcnZlciRjb21wbGV0ZTtcblx0XHRcdFx0XHRpZiAoaXNEb25lKSByZXR1cm47XG5cdFx0XHRcdFx0aXNEb25lID0gdHJ1ZTtcblx0XHRcdFx0XHQoX29ic2VydmVyJGNvbXBsZXRlID0gb2JzZXJ2ZXIuY29tcGxldGUpID09PSBudWxsIHx8IF9vYnNlcnZlciRjb21wbGV0ZSA9PT0gdm9pZCAwIHx8IF9vYnNlcnZlciRjb21wbGV0ZS5jYWxsKG9ic2VydmVyKTtcblx0XHRcdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGlmICh0ZWFyZG93bkltbWVkaWF0ZWx5KSB1bnN1YnNjcmliZSgpO1xuXHRcdFx0cmV0dXJuIHsgdW5zdWJzY3JpYmUgfTtcblx0XHR9LFxuXHRcdHBpcGUoLi4ub3BlcmF0aW9ucykge1xuXHRcdFx0cmV0dXJuIG9wZXJhdGlvbnMucmVkdWNlKHBpcGVSZWR1Y2VyLCBzZWxmKTtcblx0XHR9XG5cdH07XG5cdHJldHVybiBzZWxmO1xufVxuZnVuY3Rpb24gcGlwZVJlZHVjZXIocHJldiwgZm4pIHtcblx0cmV0dXJuIGZuKHByZXYpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gb2JzZXJ2YWJsZVRvUHJvbWlzZShvYnNlcnZhYmxlJDEpIHtcblx0Y29uc3QgYWMgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG5cdGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0bGV0IGlzRG9uZSA9IGZhbHNlO1xuXHRcdGZ1bmN0aW9uIG9uRG9uZSgpIHtcblx0XHRcdGlmIChpc0RvbmUpIHJldHVybjtcblx0XHRcdGlzRG9uZSA9IHRydWU7XG5cdFx0XHRvYnMkLnVuc3Vic2NyaWJlKCk7XG5cdFx0fVxuXHRcdGFjLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgKCkgPT4ge1xuXHRcdFx0cmVqZWN0KGFjLnNpZ25hbC5yZWFzb24pO1xuXHRcdH0pO1xuXHRcdGNvbnN0IG9icyQgPSBvYnNlcnZhYmxlJDEuc3Vic2NyaWJlKHtcblx0XHRcdG5leHQoZGF0YSkge1xuXHRcdFx0XHRpc0RvbmUgPSB0cnVlO1xuXHRcdFx0XHRyZXNvbHZlKGRhdGEpO1xuXHRcdFx0XHRvbkRvbmUoKTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcihkYXRhKSB7XG5cdFx0XHRcdHJlamVjdChkYXRhKTtcblx0XHRcdH0sXG5cdFx0XHRjb21wbGV0ZSgpIHtcblx0XHRcdFx0YWMuYWJvcnQoKTtcblx0XHRcdFx0b25Eb25lKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gcHJvbWlzZTtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBvYnNlcnZhYmxlVG9SZWFkYWJsZVN0cmVhbShvYnNlcnZhYmxlJDEsIHNpZ25hbCkge1xuXHRsZXQgdW5zdWIgPSBudWxsO1xuXHRjb25zdCBvbkFib3J0ID0gKCkgPT4ge1xuXHRcdHVuc3ViID09PSBudWxsIHx8IHVuc3ViID09PSB2b2lkIDAgfHwgdW5zdWIudW5zdWJzY3JpYmUoKTtcblx0XHR1bnN1YiA9IG51bGw7XG5cdFx0c2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblx0fTtcblx0cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG5cdFx0c3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0dW5zdWIgPSBvYnNlcnZhYmxlJDEuc3Vic2NyaWJlKHtcblx0XHRcdFx0bmV4dChkYXRhKSB7XG5cdFx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHRcdG9rOiB0cnVlLFxuXHRcdFx0XHRcdFx0dmFsdWU6IGRhdGFcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZXJyb3IoZXJyb3IpIHtcblx0XHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdFx0b2s6IGZhbHNlLFxuXHRcdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNvbXBsZXRlKCkge1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAoc2lnbmFsLmFib3J0ZWQpIG9uQWJvcnQoKTtcblx0XHRcdGVsc2Ugc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0LCB7IG9uY2U6IHRydWUgfSk7XG5cdFx0fSxcblx0XHRjYW5jZWwoKSB7XG5cdFx0XHRvbkFib3J0KCk7XG5cdFx0fVxuXHR9KTtcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUob2JzZXJ2YWJsZSQxLCBzaWduYWwpIHtcblx0Y29uc3Qgc3RyZWFtID0gb2JzZXJ2YWJsZVRvUmVhZGFibGVTdHJlYW0ob2JzZXJ2YWJsZSQxLCBzaWduYWwpO1xuXHRjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdGNvbnN0IGl0ZXJhdG9yID0ge1xuXHRcdGFzeW5jIG5leHQoKSB7XG5cdFx0XHRjb25zdCB2YWx1ZSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cdFx0XHRpZiAodmFsdWUuZG9uZSkgcmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHZvaWQgMCxcblx0XHRcdFx0ZG9uZTogdHJ1ZVxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IHsgdmFsdWU6IHJlc3VsdCB9ID0gdmFsdWU7XG5cdFx0XHRpZiAoIXJlc3VsdC5vaykgdGhyb3cgcmVzdWx0LmVycm9yO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dmFsdWU6IHJlc3VsdC52YWx1ZSxcblx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdH07XG5cdFx0fSxcblx0XHRhc3luYyByZXR1cm4oKSB7XG5cdFx0XHRhd2FpdCByZWFkZXIuY2FuY2VsKCk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR2YWx1ZTogdm9pZCAwLFxuXHRcdFx0XHRkb25lOiB0cnVlXG5cdFx0XHR9O1xuXHRcdH1cblx0fTtcblx0cmV0dXJuIHsgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcblx0XHRyZXR1cm4gaXRlcmF0b3I7XG5cdH0gfTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBpc09ic2VydmFibGUsIG9ic2VydmFibGUsIG9ic2VydmFibGVUb0FzeW5jSXRlcmFibGUsIG9ic2VydmFibGVUb1Byb21pc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW9ic2VydmFibGUtVU1PM3ZVYV8ubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/resolveResponse-DngSgha6.mjs":
/*!*****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/resolveResponse-DngSgha6.mjs ***!
  \*****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Unpromise: () => (/* binding */ Unpromise),\n/* harmony export */   createDeferred: () => (/* binding */ createDeferred),\n/* harmony export */   getRequestInfo: () => (/* binding */ getRequestInfo),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isPromise: () => (/* binding */ isPromise),\n/* harmony export */   iteratorResource: () => (/* binding */ iteratorResource),\n/* harmony export */   jsonlStreamConsumer: () => (/* binding */ jsonlStreamConsumer),\n/* harmony export */   jsonlStreamProducer: () => (/* binding */ jsonlStreamProducer),\n/* harmony export */   makeAsyncResource: () => (/* binding */ makeAsyncResource),\n/* harmony export */   makeResource: () => (/* binding */ makeResource),\n/* harmony export */   parseConnectionParamsFromString: () => (/* binding */ parseConnectionParamsFromString),\n/* harmony export */   parseConnectionParamsFromUnknown: () => (/* binding */ parseConnectionParamsFromUnknown),\n/* harmony export */   require_usingCtx: () => (/* binding */ require_usingCtx),\n/* harmony export */   resolveResponse: () => (/* binding */ resolveResponse),\n/* harmony export */   sseHeaders: () => (/* binding */ sseHeaders),\n/* harmony export */   sseStreamConsumer: () => (/* binding */ sseStreamConsumer),\n/* harmony export */   sseStreamProducer: () => (/* binding */ sseStreamProducer),\n/* harmony export */   takeWithGrace: () => (/* binding */ takeWithGrace),\n/* harmony export */   throwAbortError: () => (/* binding */ throwAbortError),\n/* harmony export */   withMaxDuration: () => (/* binding */ withMaxDuration)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getErrorShape-BH60iMC2.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/getErrorShape-BH60iMC2.mjs\");\n/* harmony import */ var _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracked-Blz8XOf1.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/tracked-Blz8XOf1.mjs\");\n/* harmony import */ var _utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils-CLZnJdb_.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/utils-CLZnJdb_.mjs\");\n/* harmony import */ var _observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./observable-UMO3vUa_.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/observable-UMO3vUa_.mjs\");\n\n\n\n\n\n//#region src/unstable-core-do-not-import/http/parseConnectionParams.ts\nfunction parseConnectionParamsFromUnknown(parsed) {\n\ttry {\n\t\tif (parsed === null) return null;\n\t\tif (!(0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(parsed)) throw new Error(\"Expected object\");\n\t\tconst nonStringValues = Object.entries(parsed).filter(([_key, value]) => typeof value !== \"string\");\n\t\tif (nonStringValues.length > 0) throw new Error(`Expected connectionParams to be string values. Got ${nonStringValues.map(([key, value]) => `${key}: ${typeof value}`).join(\", \")}`);\n\t\treturn parsed;\n\t} catch (cause) {\n\t\tthrow new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"PARSE_ERROR\",\n\t\t\tmessage: \"Invalid connection params shape\",\n\t\t\tcause\n\t\t});\n\t}\n}\nfunction parseConnectionParamsFromString(str) {\n\tlet parsed;\n\ttry {\n\t\tparsed = JSON.parse(str);\n\t} catch (cause) {\n\t\tthrow new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"PARSE_ERROR\",\n\t\t\tmessage: \"Not JSON-parsable query params\",\n\t\t\tcause\n\t\t});\n\t}\n\treturn parseConnectionParamsFromUnknown(parsed);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/contentType.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\n/**\n* Memoize a function that takes no arguments\n* @internal\n*/\nfunction memo(fn) {\n\tlet promise = null;\n\tconst sym = Symbol.for(\"@trpc/server/http/memo\");\n\tlet value = sym;\n\treturn {\n\t\tread: async () => {\n\t\t\tvar _promise;\n\t\t\tif (value !== sym) return value;\n\t\t\t(_promise = promise) !== null && _promise !== void 0 || (promise = fn().catch((cause) => {\n\t\t\t\tif (cause instanceof _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError) throw cause;\n\t\t\t\tthrow new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\t\tmessage: cause instanceof Error ? cause.message : \"Invalid input\",\n\t\t\t\t\tcause\n\t\t\t\t});\n\t\t\t}));\n\t\t\tvalue = await promise;\n\t\t\tpromise = null;\n\t\t\treturn value;\n\t\t},\n\t\tresult: () => {\n\t\t\treturn value !== sym ? value : void 0;\n\t\t}\n\t};\n}\nconst jsonContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get;\n\t\treturn !!((_req$headers$get = req.headers.get(\"content-type\")) === null || _req$headers$get === void 0 ? void 0 : _req$headers$get.startsWith(\"application/json\"));\n\t},\n\tasync parse(opts) {\n\t\tvar _types$values$next$va;\n\t\tconst { req } = opts;\n\t\tconst isBatchCall = opts.searchParams.get(\"batch\") === \"1\";\n\t\tconst paths = isBatchCall ? opts.path.split(\",\") : [opts.path];\n\t\tconst getInputs = memo(async () => {\n\t\t\tlet inputs = void 0;\n\t\t\tif (req.method === \"GET\") {\n\t\t\t\tconst queryInput = opts.searchParams.get(\"input\");\n\t\t\t\tif (queryInput) inputs = JSON.parse(queryInput);\n\t\t\t} else inputs = await req.json();\n\t\t\tif (inputs === void 0) return {};\n\t\t\tif (!isBatchCall) return { 0: opts.router._def._config.transformer.input.deserialize(inputs) };\n\t\t\tif (!(0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(inputs)) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\tmessage: \"\\\"input\\\" needs to be an object when doing a batch call\"\n\t\t\t});\n\t\t\tconst acc = {};\n\t\t\tfor (const index of paths.keys()) {\n\t\t\t\tconst input = inputs[index];\n\t\t\t\tif (input !== void 0) acc[index] = opts.router._def._config.transformer.input.deserialize(input);\n\t\t\t}\n\t\t\treturn acc;\n\t\t});\n\t\tconst calls = await Promise.all(paths.map(async (path, index) => {\n\t\t\tconst procedure = await (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, path);\n\t\t\treturn {\n\t\t\t\tpath,\n\t\t\t\tprocedure,\n\t\t\t\tgetRawInput: async () => {\n\t\t\t\t\tconst inputs = await getInputs.read();\n\t\t\t\t\tlet input = inputs[index];\n\t\t\t\t\tif ((procedure === null || procedure === void 0 ? void 0 : procedure._def.type) === \"subscription\") {\n\t\t\t\t\t\tvar _ref, _opts$headers$get;\n\t\t\t\t\t\tconst lastEventId = (_ref = (_opts$headers$get = opts.headers.get(\"last-event-id\")) !== null && _opts$headers$get !== void 0 ? _opts$headers$get : opts.searchParams.get(\"lastEventId\")) !== null && _ref !== void 0 ? _ref : opts.searchParams.get(\"Last-Event-Id\");\n\t\t\t\t\t\tif (lastEventId) if ((0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(input)) input = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, input), {}, { lastEventId });\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tvar _input;\n\t\t\t\t\t\t\t(_input = input) !== null && _input !== void 0 || (input = { lastEventId });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn input;\n\t\t\t\t},\n\t\t\t\tresult: () => {\n\t\t\t\t\tvar _getInputs$result;\n\t\t\t\t\treturn (_getInputs$result = getInputs.result()) === null || _getInputs$result === void 0 ? void 0 : _getInputs$result[index];\n\t\t\t\t}\n\t\t\t};\n\t\t}));\n\t\tconst types = new Set(calls.map((call) => {\n\t\t\tvar _call$procedure;\n\t\t\treturn (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n\t\t}).filter(Boolean));\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (types.size > 1) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"BAD_REQUEST\",\n\t\t\tmessage: `Cannot mix procedure types in call: ${Array.from(types).join(\", \")}`\n\t\t});\n\t\tconst type = (_types$values$next$va = types.values().next().value) !== null && _types$values$next$va !== void 0 ? _types$values$next$va : \"unknown\";\n\t\tconst connectionParamsStr = opts.searchParams.get(\"connectionParams\");\n\t\tconst info = {\n\t\t\tisBatchCall,\n\t\t\taccept: req.headers.get(\"trpc-accept\"),\n\t\t\tcalls,\n\t\t\ttype,\n\t\t\tconnectionParams: connectionParamsStr === null ? null : parseConnectionParamsFromString(connectionParamsStr),\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t\treturn info;\n\t}\n};\nconst formDataContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get2;\n\t\treturn !!((_req$headers$get2 = req.headers.get(\"content-type\")) === null || _req$headers$get2 === void 0 ? void 0 : _req$headers$get2.startsWith(\"multipart/form-data\"));\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== \"POST\") throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\tmessage: \"Only POST requests are supported for multipart/form-data requests\"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\tconst fd = await req.formData();\n\t\t\treturn fd;\n\t\t});\n\t\tconst procedure = await (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path);\n\t\treturn {\n\t\t\taccept: null,\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\ttype: \"mutation\",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst octetStreamContentTypeHandler = {\n\tisMatch(req) {\n\t\tvar _req$headers$get3;\n\t\treturn !!((_req$headers$get3 = req.headers.get(\"content-type\")) === null || _req$headers$get3 === void 0 ? void 0 : _req$headers$get3.startsWith(\"application/octet-stream\"));\n\t},\n\tasync parse(opts) {\n\t\tconst { req } = opts;\n\t\tif (req.method !== \"POST\") throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\tmessage: \"Only POST requests are supported for application/octet-stream requests\"\n\t\t});\n\t\tconst getInputs = memo(async () => {\n\t\t\treturn req.body;\n\t\t});\n\t\treturn {\n\t\t\tcalls: [{\n\t\t\t\tpath: opts.path,\n\t\t\t\tgetRawInput: getInputs.read,\n\t\t\t\tresult: getInputs.result,\n\t\t\t\tprocedure: await (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getProcedureAtPath)(opts.router, opts.path)\n\t\t\t}],\n\t\t\tisBatchCall: false,\n\t\t\taccept: null,\n\t\t\ttype: \"mutation\",\n\t\t\tconnectionParams: null,\n\t\t\tsignal: req.signal,\n\t\t\turl: opts.url\n\t\t};\n\t}\n};\nconst handlers = [\n\tjsonContentTypeHandler,\n\tformDataContentTypeHandler,\n\toctetStreamContentTypeHandler\n];\nfunction getContentTypeHandler(req) {\n\tconst handler = handlers.find((handler$1) => handler$1.isMatch(req));\n\tif (handler) return handler;\n\tif (!handler && req.method === \"GET\") return jsonContentTypeHandler;\n\tthrow new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\tmessage: req.headers.has(\"content-type\") ? `Unsupported content-type \"${req.headers.get(\"content-type\")}` : \"Missing content-type header\"\n\t});\n}\nasync function getRequestInfo(opts) {\n\tconst handler = getContentTypeHandler(opts.req);\n\treturn await handler.parse(opts);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/abortError.ts\nfunction isAbortError(error) {\n\treturn (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(error) && error[\"name\"] === \"AbortError\";\n}\nfunction throwAbortError(message = \"AbortError\") {\n\tthrow new DOMException(message, \"AbortError\");\n}\n\n//#endregion\n//#region src/vendor/is-plain-object.ts\n/*!\n* is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n*\n* Copyright (c) 2014-2017, Jon Schlinkert.\n* Released under the MIT License.\n*/\nfunction isObject$1(o) {\n\treturn Object.prototype.toString.call(o) === \"[object Object]\";\n}\nfunction isPlainObject(o) {\n\tvar ctor, prot;\n\tif (isObject$1(o) === false) return false;\n\tctor = o.constructor;\n\tif (ctor === void 0) return true;\n\tprot = ctor.prototype;\n\tif (isObject$1(prot) === false) return false;\n\tif (prot.hasOwnProperty(\"isPrototypeOf\") === false) return false;\n\treturn true;\n}\n\n//#endregion\n//#region src/vendor/unpromise/unpromise.ts\nvar import_defineProperty = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.require_defineProperty)(), 1);\nlet _Symbol$toStringTag;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n* which is retained for the lifetime of the original Promise.\n*/\nconst subscribableCache = /* @__PURE__ */ new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n* SubscribedPromises (settled promises are not subscribed - they resolve\n* immediately). */\nconst NOOP = () => {};\n_Symbol$toStringTag = Symbol.toStringTag;\n/**\n* Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n* created once, cached and reused throughout the lifetime of the Promise. Get a\n* Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n*\n* The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n* `.then()` and `.catch()` just once. Promises derived from it use a\n* subscription- (and unsubscription-) based mechanism that monitors these\n* handlers.\n*\n* Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n* `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n* `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n* from the original, potentially long-lived Promise, eliminating memory leaks.\n*\n* This approach can eliminate the memory leaks that otherwise come about from\n* repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n* times on the same long-lived native Promise (subscriptions which can never be\n* cleaned up).\n*\n* `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n* avoiding memory leaks when using long-lived unsettled Promises.\n*\n* `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n* any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n* the scenes, `resolve` is implemented simply as\n* `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n* to tidy up!\n*\n*/\nvar Unpromise = class Unpromise {\n\tconstructor(arg) {\n\t\t(0, import_defineProperty.default)(this, \"promise\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"subscribers\", []);\n\t\t(0, import_defineProperty.default)(this, \"settlement\", null);\n\t\t(0, import_defineProperty.default)(this, _Symbol$toStringTag, \"Unpromise\");\n\t\tif (typeof arg === \"function\") this.promise = new Promise(arg);\n\t\telse this.promise = arg;\n\t\tconst thenReturn = this.promise.then((value) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: \"fulfilled\",\n\t\t\t\tvalue\n\t\t\t};\n\t\t\tsubscribers === null || subscribers === void 0 || subscribers.forEach(({ resolve }) => {\n\t\t\t\tresolve(value);\n\t\t\t});\n\t\t});\n\t\tif (\"catch\" in thenReturn) thenReturn.catch((reason) => {\n\t\t\tconst { subscribers } = this;\n\t\t\tthis.subscribers = null;\n\t\t\tthis.settlement = {\n\t\t\t\tstatus: \"rejected\",\n\t\t\t\treason\n\t\t\t};\n\t\t\tsubscribers === null || subscribers === void 0 || subscribers.forEach(({ reject }) => {\n\t\t\t\treject(reason);\n\t\t\t});\n\t\t});\n\t}\n\t/** Create a promise that mitigates uncontrolled subscription to a long-lived\n\t* Promise via .then() and .catch() - otherwise a source of memory leaks.\n\t*\n\t* The returned promise has an `unsubscribe()` method which can be called when\n\t* the Promise is no longer being tracked by application logic, and which\n\t* ensures that there is no reference chain from the original promise to the\n\t* new one, and therefore no memory leak.\n\t*\n\t* If original promise has not yet settled, this adds a new unique promise\n\t* that listens to then/catch events, along with an `unsubscribe()` method to\n\t* detach it.\n\t*\n\t* If original promise has settled, then creates a new Promise.resolve() or\n\t* Promise.reject() and provided unsubscribe is a noop.\n\t*\n\t* If you call `unsubscribe()` before the returned Promise has settled, it\n\t* will never settle.\n\t*/\n\tsubscribe() {\n\t\tlet promise;\n\t\tlet unsubscribe;\n\t\tconst { settlement } = this;\n\t\tif (settlement === null) {\n\t\t\tif (this.subscribers === null) throw new Error(\"Unpromise settled but still has subscribers\");\n\t\t\tconst subscriber = withResolvers();\n\t\t\tthis.subscribers = listWithMember(this.subscribers, subscriber);\n\t\t\tpromise = subscriber.promise;\n\t\t\tunsubscribe = () => {\n\t\t\t\tif (this.subscribers !== null) this.subscribers = listWithoutMember(this.subscribers, subscriber);\n\t\t\t};\n\t\t} else {\n\t\t\tconst { status } = settlement;\n\t\t\tif (status === \"fulfilled\") promise = Promise.resolve(settlement.value);\n\t\t\telse promise = Promise.reject(settlement.reason);\n\t\t\tunsubscribe = NOOP;\n\t\t}\n\t\treturn Object.assign(promise, { unsubscribe });\n\t}\n\t/** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */\n\tthen(onfulfilled, onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.then(onfulfilled, onrejected), { unsubscribe });\n\t}\n\tcatch(onrejected) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.catch(onrejected), { unsubscribe });\n\t}\n\tfinally(onfinally) {\n\t\tconst subscribed = this.subscribe();\n\t\tconst { unsubscribe } = subscribed;\n\t\treturn Object.assign(subscribed.finally(onfinally), { unsubscribe });\n\t}\n\t/** Unpromise STATIC METHODS */\n\t/** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n\t* of the provided Promise reference) */\n\tstatic proxy(promise) {\n\t\tconst cached = Unpromise.getSubscribablePromise(promise);\n\t\treturn typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n\t}\n\t/** Create and store an Unpromise keyed by an original Promise. */\n\tstatic createSubscribablePromise(promise) {\n\t\tconst created = new Unpromise(promise);\n\t\tsubscribableCache.set(promise, created);\n\t\tsubscribableCache.set(created, created);\n\t\treturn created;\n\t}\n\t/** Retrieve a previously-created Unpromise keyed by an original Promise. */\n\tstatic getSubscribablePromise(promise) {\n\t\treturn subscribableCache.get(promise);\n\t}\n\t/** Promise STATIC METHODS */\n\t/** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n\t* it (that can be later unsubscribed to eliminate Memory leaks) */\n\tstatic resolve(value) {\n\t\tconst promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n\t\treturn Unpromise.proxy(promise).subscribe();\n\t}\n\tstatic async any(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.any(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\tstatic async race(values) {\n\t\tconst valuesArray = Array.isArray(values) ? values : [...values];\n\t\tconst subscribedPromises = valuesArray.map(Unpromise.resolve);\n\t\ttry {\n\t\t\treturn await Promise.race(subscribedPromises);\n\t\t} finally {\n\t\t\tsubscribedPromises.forEach(({ unsubscribe }) => {\n\t\t\t\tunsubscribe();\n\t\t\t});\n\t\t}\n\t}\n\t/** Create a race of SubscribedPromises that will fulfil to a single winning\n\t* Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n\t* accumulating .then() and .catch() subscribers. Allows simple logic to\n\t* consume the result, like...\n\t* ```ts\n\t* const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n\t* if(winner === promiseB){\n\t*   const result = await promiseB;\n\t*   // do the thing\n\t* }\n\t* ```\n\t* */\n\tstatic async raceReferences(promises) {\n\t\tconst selfPromises = promises.map(resolveSelfTuple);\n\t\ttry {\n\t\t\treturn await Promise.race(selfPromises);\n\t\t} finally {\n\t\t\tfor (const promise of selfPromises) promise.unsubscribe();\n\t\t}\n\t}\n};\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n* awaiting the eventual Promise ***reference*** (easy to destructure and\n* exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n* may be ambiguous and therefore hard to identify as the winner of a race).\n* You can call unsubscribe on the Promise to mitigate memory leaks.\n* */\nfunction resolveSelfTuple(promise) {\n\treturn Unpromise.proxy(promise).then(() => [promise]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */\n/** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */\nfunction withResolvers() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((_resolve, _reject) => {\n\t\tresolve = _resolve;\n\t\treject = _reject;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n/** IMMUTABLE LIST OPERATIONS */\nfunction listWithMember(arr, member) {\n\treturn [...arr, member];\n}\nfunction listWithoutIndex(arr, index) {\n\treturn [...arr.slice(0, index), ...arr.slice(index + 1)];\n}\nfunction listWithoutMember(arr, member) {\n\tconst index = arr.indexOf(member);\n\tif (index !== -1) return listWithoutIndex(arr, index);\n\treturn arr;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/disposable.ts\nvar _Symbol, _Symbol$dispose, _Symbol2, _Symbol2$asyncDispose;\n(_Symbol$dispose = (_Symbol = Symbol).dispose) !== null && _Symbol$dispose !== void 0 || (_Symbol.dispose = Symbol());\n(_Symbol2$asyncDispose = (_Symbol2 = Symbol).asyncDispose) !== null && _Symbol2$asyncDispose !== void 0 || (_Symbol2.asyncDispose = Symbol());\n/**\n* Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n* The returned object is the original value augmented with a Symbol.dispose method.\n* @param thing The value to make disposable\n* @param dispose Function to call when disposing the resource\n* @returns The original value with Symbol.dispose method added\n*/\nfunction makeResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.dispose];\n\tit[Symbol.dispose] = () => {\n\t\tdispose();\n\t\texisting === null || existing === void 0 || existing();\n\t};\n\treturn it;\n}\n/**\n* Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n* The returned object is the original value augmented with a Symbol.asyncDispose method.\n* @param thing The value to make async disposable\n* @param dispose Async function to call when disposing the resource\n* @returns The original value with Symbol.asyncDispose method added\n*/\nfunction makeAsyncResource(thing, dispose) {\n\tconst it = thing;\n\tconst existing = it[Symbol.asyncDispose];\n\tit[Symbol.asyncDispose] = async () => {\n\t\tawait dispose();\n\t\tawait (existing === null || existing === void 0 ? void 0 : existing());\n\t};\n\treturn it;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/timerResource.ts\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n\tlet timer = null;\n\treturn makeResource({ start() {\n\t\tif (timer) throw new Error(\"Timer already started\");\n\t\tconst promise = new Promise((resolve) => {\n\t\t\ttimer = setTimeout(() => resolve(disposablePromiseTimerResult), ms);\n\t\t});\n\t\treturn promise;\n\t} }, () => {\n\t\tif (timer) clearTimeout(timer);\n\t});\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\nvar require_usingCtx = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/usingCtx.js\"(exports, module) {\n\tfunction _usingCtx() {\n\t\tvar r = \"function\" == typeof SuppressedError ? SuppressedError : function(r$1, e$1) {\n\t\t\tvar n$1 = Error();\n\t\t\treturn n$1.name = \"SuppressedError\", n$1.error = r$1, n$1.suppressed = e$1, n$1;\n\t\t}, e = {}, n = [];\n\t\tfunction using(r$1, e$1) {\n\t\t\tif (null != e$1) {\n\t\t\t\tif (Object(e$1) !== e$1) throw new TypeError(\"using declarations can only be used with objects, functions, null, or undefined.\");\n\t\t\t\tif (r$1) var o = e$1[Symbol.asyncDispose || Symbol[\"for\"](\"Symbol.asyncDispose\")];\n\t\t\t\tif (void 0 === o && (o = e$1[Symbol.dispose || Symbol[\"for\"](\"Symbol.dispose\")], r$1)) var t = o;\n\t\t\t\tif (\"function\" != typeof o) throw new TypeError(\"Object is not disposable.\");\n\t\t\t\tt && (o = function o$1() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tt.call(e$1);\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn Promise.reject(r$2);\n\t\t\t\t\t}\n\t\t\t\t}), n.push({\n\t\t\t\t\tv: e$1,\n\t\t\t\t\td: o,\n\t\t\t\t\ta: r$1\n\t\t\t\t});\n\t\t\t} else r$1 && n.push({\n\t\t\t\td: e$1,\n\t\t\t\ta: r$1\n\t\t\t});\n\t\t\treturn e$1;\n\t\t}\n\t\treturn {\n\t\t\te,\n\t\t\tu: using.bind(null, !1),\n\t\t\ta: using.bind(null, !0),\n\t\t\td: function d() {\n\t\t\t\tvar o, t = this.e, s = 0;\n\t\t\t\tfunction next() {\n\t\t\t\t\tfor (; o = n.pop();) try {\n\t\t\t\t\t\tif (!o.a && 1 === s) return s = 0, n.push(o), Promise.resolve().then(next);\n\t\t\t\t\t\tif (o.d) {\n\t\t\t\t\t\t\tvar r$1 = o.d.call(o.v);\n\t\t\t\t\t\t\tif (o.a) return s |= 2, Promise.resolve(r$1).then(next, err);\n\t\t\t\t\t\t} else s |= 1;\n\t\t\t\t\t} catch (r$2) {\n\t\t\t\t\t\treturn err(r$2);\n\t\t\t\t\t}\n\t\t\t\t\tif (1 === s) return t !== e ? Promise.reject(t) : Promise.resolve();\n\t\t\t\t\tif (t !== e) throw t;\n\t\t\t\t}\n\t\t\t\tfunction err(n$1) {\n\t\t\t\t\treturn t = t !== e ? new r(n$1, t) : n$1, next();\n\t\t\t\t}\n\t\t\t\treturn next();\n\t\t\t}\n\t\t};\n\t}\n\tmodule.exports = _usingCtx, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\nvar require_OverloadYield = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/OverloadYield.js\"(exports, module) {\n\tfunction _OverloadYield(e, d) {\n\t\tthis.v = e, this.k = d;\n\t}\n\tmodule.exports = _OverloadYield, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\nvar require_awaitAsyncGenerator = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/awaitAsyncGenerator.js\"(exports, module) {\n\tvar OverloadYield$2 = require_OverloadYield();\n\tfunction _awaitAsyncGenerator$5(e) {\n\t\treturn new OverloadYield$2(e, 0);\n\t}\n\tmodule.exports = _awaitAsyncGenerator$5, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\nvar require_wrapAsyncGenerator = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/wrapAsyncGenerator.js\"(exports, module) {\n\tvar OverloadYield$1 = require_OverloadYield();\n\tfunction _wrapAsyncGenerator$6(e) {\n\t\treturn function() {\n\t\t\treturn new AsyncGenerator(e.apply(this, arguments));\n\t\t};\n\t}\n\tfunction AsyncGenerator(e) {\n\t\tvar r, t;\n\t\tfunction resume(r$1, t$1) {\n\t\t\ttry {\n\t\t\t\tvar n = e[r$1](t$1), o = n.value, u = o instanceof OverloadYield$1;\n\t\t\t\tPromise.resolve(u ? o.v : o).then(function(t$2) {\n\t\t\t\t\tif (u) {\n\t\t\t\t\t\tvar i = \"return\" === r$1 ? \"return\" : \"next\";\n\t\t\t\t\t\tif (!o.k || t$2.done) return resume(i, t$2);\n\t\t\t\t\t\tt$2 = e[i](t$2).value;\n\t\t\t\t\t}\n\t\t\t\t\tsettle(n.done ? \"return\" : \"normal\", t$2);\n\t\t\t\t}, function(e$1) {\n\t\t\t\t\tresume(\"throw\", e$1);\n\t\t\t\t});\n\t\t\t} catch (e$1) {\n\t\t\t\tsettle(\"throw\", e$1);\n\t\t\t}\n\t\t}\n\t\tfunction settle(e$1, n) {\n\t\t\tswitch (e$1) {\n\t\t\t\tcase \"return\":\n\t\t\t\t\tr.resolve({\n\t\t\t\t\t\tvalue: n,\n\t\t\t\t\t\tdone: !0\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"throw\":\n\t\t\t\t\tr.reject(n);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault: r.resolve({\n\t\t\t\t\tvalue: n,\n\t\t\t\t\tdone: !1\n\t\t\t\t});\n\t\t\t}\n\t\t\t(r = r.next) ? resume(r.key, r.arg) : t = null;\n\t\t}\n\t\tthis._invoke = function(e$1, n) {\n\t\t\treturn new Promise(function(o, u) {\n\t\t\t\tvar i = {\n\t\t\t\t\tkey: e$1,\n\t\t\t\t\targ: n,\n\t\t\t\t\tresolve: o,\n\t\t\t\t\treject: u,\n\t\t\t\t\tnext: null\n\t\t\t\t};\n\t\t\t\tt ? t = t.next = i : (r = t = i, resume(e$1, n));\n\t\t\t});\n\t\t}, \"function\" != typeof e[\"return\"] && (this[\"return\"] = void 0);\n\t}\n\tAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function() {\n\t\treturn this;\n\t}, AsyncGenerator.prototype.next = function(e) {\n\t\treturn this._invoke(\"next\", e);\n\t}, AsyncGenerator.prototype[\"throw\"] = function(e) {\n\t\treturn this._invoke(\"throw\", e);\n\t}, AsyncGenerator.prototype[\"return\"] = function(e) {\n\t\treturn this._invoke(\"return\", e);\n\t};\n\tmodule.exports = _wrapAsyncGenerator$6, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/asyncIterable.ts\nvar import_usingCtx$4 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$4 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$5 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction iteratorResource(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tif (iterator[Symbol.asyncDispose]) return iterator;\n\treturn makeAsyncResource(iterator, async () => {\n\t\tvar _iterator$return;\n\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t});\n}\n/**\n* Derives a new {@link AsyncGenerator} based on {@link iterable}, that automatically aborts after the specified duration.\n*/\nfunction withMaxDuration(_x, _x2) {\n\treturn _withMaxDuration.apply(this, arguments);\n}\nfunction _withMaxDuration() {\n\t_withMaxDuration = (0, import_wrapAsyncGenerator$5.default)(function* (iterable, opts) {\n\t\ttry {\n\t\t\tvar _usingCtx$1 = (0, import_usingCtx$4.default)();\n\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\t\tconst timer = _usingCtx$1.u(timerResource(opts.maxDurationMs));\n\t\t\tconst timerPromise = timer.start();\n\t\t\tlet result;\n\t\t\twhile (true) {\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([iterator.next(), timerPromise]));\n\t\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\t\tif (result.done) return result;\n\t\t\t\tyield result.value;\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx$1.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$4.default)(_usingCtx$1.d());\n\t\t}\n\t});\n\treturn _withMaxDuration.apply(this, arguments);\n}\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields its first\n* {@link count} values. Then, a grace period of {@link gracePeriodMs} is started in which further\n* values may still come through. After this period, the generator aborts.\n*/\nfunction takeWithGrace(_x3, _x4) {\n\treturn _takeWithGrace.apply(this, arguments);\n}\nfunction _takeWithGrace() {\n\t_takeWithGrace = (0, import_wrapAsyncGenerator$5.default)(function* (iterable, opts) {\n\t\ttry {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx$4.default)();\n\t\t\tconst iterator = _usingCtx3.a(iteratorResource(iterable));\n\t\t\tlet result;\n\t\t\tconst timer = _usingCtx3.u(timerResource(opts.gracePeriodMs));\n\t\t\tlet count = opts.count;\n\t\t\tlet timerPromise = new Promise(() => {});\n\t\t\twhile (true) {\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$4.default)(Unpromise.race([iterator.next(), timerPromise]));\n\t\t\t\tif (result === disposablePromiseTimerResult) throwAbortError();\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t\tif (--count === 0) timerPromise = timer.start();\n\t\t\t\tresult = null;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$4.default)(_usingCtx3.d());\n\t\t}\n\t});\n\treturn _takeWithGrace.apply(this, arguments);\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/createDeferred.ts\nfunction createDeferred() {\n\tlet resolve;\n\tlet reject;\n\tconst promise = new Promise((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn {\n\t\tpromise,\n\t\tresolve,\n\t\treject\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/mergeAsyncIterables.ts\nvar import_usingCtx$3 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$3 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$4 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nfunction createManagedIterator(iterable, onResult) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\tlet state = \"idle\";\n\tfunction cleanup() {\n\t\tstate = \"done\";\n\t\tonResult = () => {};\n\t}\n\tfunction pull() {\n\t\tif (state !== \"idle\") return;\n\t\tstate = \"pending\";\n\t\tconst next = iterator.next();\n\t\tnext.then((result) => {\n\t\t\tif (result.done) {\n\t\t\t\tstate = \"done\";\n\t\t\t\tonResult({\n\t\t\t\t\tstatus: \"return\",\n\t\t\t\t\tvalue: result.value\n\t\t\t\t});\n\t\t\t\tcleanup();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate = \"idle\";\n\t\t\tonResult({\n\t\t\t\tstatus: \"yield\",\n\t\t\t\tvalue: result.value\n\t\t\t});\n\t\t}).catch((cause) => {\n\t\t\tonResult({\n\t\t\t\tstatus: \"error\",\n\t\t\t\terror: cause\n\t\t\t});\n\t\t\tcleanup();\n\t\t});\n\t}\n\treturn {\n\t\tpull,\n\t\tdestroy: async () => {\n\t\t\tvar _iterator$return;\n\t\t\tcleanup();\n\t\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t\t}\n\t};\n}\n/**\n* Creates a new async iterable that merges multiple async iterables into a single stream.\n* Values from the input iterables are yielded in the order they resolve, similar to Promise.race().\n*\n* New iterables can be added dynamically using the returned {@link MergedAsyncIterables.add} method, even after iteration has started.\n*\n* If any of the input iterables throws an error, that error will be propagated through the merged stream.\n* Other iterables will not continue to be processed.\n*\n* @template TYield The type of values yielded by the input iterables\n*/\nfunction mergeAsyncIterables() {\n\tlet state = \"idle\";\n\tlet flushSignal = createDeferred();\n\t/**\n\t* used while {@link state} is `idle`\n\t*/\n\tconst iterables = [];\n\t/**\n\t* used while {@link state} is `pending`\n\t*/\n\tconst iterators = /* @__PURE__ */ new Set();\n\tconst buffer = [];\n\tfunction initIterable(iterable) {\n\t\tif (state !== \"pending\") return;\n\t\tconst iterator = createManagedIterator(iterable, (result) => {\n\t\t\tif (state !== \"pending\") return;\n\t\t\tswitch (result.status) {\n\t\t\t\tcase \"yield\":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"return\":\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"error\":\n\t\t\t\t\tbuffer.push([iterator, result]);\n\t\t\t\t\titerators.delete(iterator);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tflushSignal.resolve();\n\t\t});\n\t\titerators.add(iterator);\n\t\titerator.pull();\n\t}\n\treturn {\n\t\tadd(iterable) {\n\t\t\tswitch (state) {\n\t\t\t\tcase \"idle\":\n\t\t\t\t\titerables.push(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"pending\":\n\t\t\t\t\tinitIterable(iterable);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"done\": break;\n\t\t\t}\n\t\t},\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn (0, import_wrapAsyncGenerator$4.default)(function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$3.default)();\n\t\t\t\t\tif (state !== \"idle\") throw new Error(\"Cannot iterate twice\");\n\t\t\t\t\tstate = \"pending\";\n\t\t\t\t\tconst _finally = _usingCtx$1.a(makeAsyncResource({}, async () => {\n\t\t\t\t\t\tstate = \"done\";\n\t\t\t\t\t\tconst errors = [];\n\t\t\t\t\t\tawait Promise.all(Array.from(iterators.values()).map(async (it) => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait it.destroy();\n\t\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\t\terrors.push(cause);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tbuffer.length = 0;\n\t\t\t\t\t\titerators.clear();\n\t\t\t\t\t\tflushSignal.resolve();\n\t\t\t\t\t\tif (errors.length > 0) throw new AggregateError(errors);\n\t\t\t\t\t}));\n\t\t\t\t\twhile (iterables.length > 0) initIterable(iterables.shift());\n\t\t\t\t\twhile (iterators.size > 0) {\n\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator$3.default)(flushSignal.promise);\n\t\t\t\t\t\twhile (buffer.length > 0) {\n\t\t\t\t\t\t\tconst [iterator, result] = buffer.shift();\n\t\t\t\t\t\t\tswitch (result.status) {\n\t\t\t\t\t\t\t\tcase \"yield\":\n\t\t\t\t\t\t\t\t\tyield result.value;\n\t\t\t\t\t\t\t\t\titerator.pull();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase \"error\": throw result.error;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tflushSignal = createDeferred();\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\tyield (0, import_awaitAsyncGenerator$3.default)(_usingCtx$1.d());\n\t\t\t\t}\n\t\t\t})();\n\t\t}\n\t};\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/readableStreamFrom.ts\n/**\n* Creates a ReadableStream from an AsyncIterable.\n*\n* @param iterable - The source AsyncIterable to stream from\n* @returns A ReadableStream that yields values from the AsyncIterable\n*/\nfunction readableStreamFrom(iterable) {\n\tconst iterator = iterable[Symbol.asyncIterator]();\n\treturn new ReadableStream({\n\t\tasync cancel() {\n\t\t\tvar _iterator$return;\n\t\t\tawait ((_iterator$return = iterator.return) === null || _iterator$return === void 0 ? void 0 : _iterator$return.call(iterator));\n\t\t},\n\t\tasync pull(controller) {\n\t\t\tconst result = await iterator.next();\n\t\t\tif (result.done) {\n\t\t\t\tcontroller.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcontroller.enqueue(result.value);\n\t\t}\n\t});\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/utils/withPing.ts\nvar import_usingCtx$2 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_awaitAsyncGenerator$2 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$3 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nconst PING_SYM = Symbol(\"ping\");\n/**\n* Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n* whenever no value has been yielded for {@link pingIntervalMs}.\n*/\nfunction withPing(_x, _x2) {\n\treturn _withPing.apply(this, arguments);\n}\nfunction _withPing() {\n\t_withPing = (0, import_wrapAsyncGenerator$3.default)(function* (iterable, pingIntervalMs) {\n\t\ttry {\n\t\t\tvar _usingCtx$1 = (0, import_usingCtx$2.default)();\n\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable));\n\t\t\tlet result;\n\t\t\tlet nextPromise = iterator.next();\n\t\t\twhile (true) try {\n\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$2.default)();\n\t\t\t\tconst pingPromise = _usingCtx3.u(timerResource(pingIntervalMs));\n\t\t\t\tresult = yield (0, import_awaitAsyncGenerator$2.default)(Unpromise.race([nextPromise, pingPromise.start()]));\n\t\t\t\tif (result === disposablePromiseTimerResult) {\n\t\t\t\t\tyield PING_SYM;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tnextPromise = iterator.next();\n\t\t\t\tyield result.value;\n\t\t\t\tresult = null;\n\t\t\t} catch (_) {\n\t\t\t\t_usingCtx3.e = _;\n\t\t\t} finally {\n\t\t\t\t_usingCtx3.d();\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx$1.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator$2.default)(_usingCtx$1.d());\n\t\t}\n\t});\n\treturn _withPing.apply(this, arguments);\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\nvar require_asyncIterator = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncIterator.js\"(exports, module) {\n\tfunction _asyncIterator$2(r) {\n\t\tvar n, t, o, e = 2;\n\t\tfor (\"undefined\" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) {\n\t\t\tif (t && null != (n = r[t])) return n.call(r);\n\t\t\tif (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r));\n\t\t\tt = \"@@asyncIterator\", o = \"@@iterator\";\n\t\t}\n\t\tthrow new TypeError(\"Object is not async iterable\");\n\t}\n\tfunction AsyncFromSyncIterator(r) {\n\t\tfunction AsyncFromSyncIteratorContinuation(r$1) {\n\t\t\tif (Object(r$1) !== r$1) return Promise.reject(new TypeError(r$1 + \" is not an object.\"));\n\t\t\tvar n = r$1.done;\n\t\t\treturn Promise.resolve(r$1.value).then(function(r$2) {\n\t\t\t\treturn {\n\t\t\t\t\tvalue: r$2,\n\t\t\t\t\tdone: n\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\treturn AsyncFromSyncIterator = function AsyncFromSyncIterator$1(r$1) {\n\t\t\tthis.s = r$1, this.n = r$1.next;\n\t\t}, AsyncFromSyncIterator.prototype = {\n\t\t\ts: null,\n\t\t\tn: null,\n\t\t\tnext: function next() {\n\t\t\t\treturn AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t\"return\": function _return(r$1) {\n\t\t\t\tvar n = this.s[\"return\"];\n\t\t\t\treturn void 0 === n ? Promise.resolve({\n\t\t\t\t\tvalue: r$1,\n\t\t\t\t\tdone: !0\n\t\t\t\t}) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t},\n\t\t\t\"throw\": function _throw(r$1) {\n\t\t\t\tvar n = this.s[\"return\"];\n\t\t\t\treturn void 0 === n ? Promise.reject(r$1) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments));\n\t\t\t}\n\t\t}, new AsyncFromSyncIterator(r);\n\t}\n\tmodule.exports = _asyncIterator$2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/jsonl.ts\nvar import_awaitAsyncGenerator$1 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$2 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_usingCtx$1 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nvar import_asyncIterator$1 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nconst CHUNK_VALUE_TYPE_PROMISE = 0;\nconst CHUNK_VALUE_TYPE_ASYNC_ITERABLE = 1;\nconst PROMISE_STATUS_FULFILLED = 0;\nconst PROMISE_STATUS_REJECTED = 1;\nconst ASYNC_ITERABLE_STATUS_RETURN = 0;\nconst ASYNC_ITERABLE_STATUS_YIELD = 1;\nconst ASYNC_ITERABLE_STATUS_ERROR = 2;\nfunction isPromise(value) {\n\treturn ((0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) || (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isFunction)(value)) && typeof (value === null || value === void 0 ? void 0 : value[\"then\"]) === \"function\" && typeof (value === null || value === void 0 ? void 0 : value[\"catch\"]) === \"function\";\n}\nvar MaxDepthError = class extends Error {\n\tconstructor(path) {\n\t\tsuper(\"Max depth reached at path: \" + path.join(\".\"));\n\t\tthis.path = path;\n\t}\n};\nfunction createBatchStreamProducer(_x3) {\n\treturn _createBatchStreamProducer.apply(this, arguments);\n}\nfunction _createBatchStreamProducer() {\n\t_createBatchStreamProducer = (0, import_wrapAsyncGenerator$2.default)(function* (opts) {\n\t\tconst { data } = opts;\n\t\tlet counter = 0;\n\t\tconst placeholder = 0;\n\t\tconst mergedIterables = mergeAsyncIterables();\n\t\tfunction registerAsync(callback) {\n\t\t\tconst idx = counter++;\n\t\t\tconst iterable$1 = callback(idx);\n\t\t\tmergedIterables.add(iterable$1);\n\t\t\treturn idx;\n\t\t}\n\t\tfunction encodePromise(promise, path) {\n\t\t\treturn registerAsync(/* @__PURE__ */ function() {\n\t\t\t\tvar _ref = (0, import_wrapAsyncGenerator$2.default)(function* (idx) {\n\t\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tpromise.catch((cause) => {\n\t\t\t\t\t\t\tvar _opts$onError;\n\t\t\t\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tpromise = Promise.reject(error);\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst next = yield (0, import_awaitAsyncGenerator$1.default)(promise);\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tPROMISE_STATUS_FULFILLED,\n\t\t\t\t\t\t\tencode(next, path)\n\t\t\t\t\t\t];\n\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\tvar _opts$onError2, _opts$formatError;\n\t\t\t\t\t\t(_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t});\n\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\tPROMISE_STATUS_REJECTED,\n\t\t\t\t\t\t\t(_opts$formatError = opts.formatError) === null || _opts$formatError === void 0 ? void 0 : _opts$formatError.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function(_x) {\n\t\t\t\t\treturn _ref.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\tfunction encodeAsyncIterable(iterable$1, path) {\n\t\t\treturn registerAsync(/* @__PURE__ */ function() {\n\t\t\t\tvar _ref2 = (0, import_wrapAsyncGenerator$2.default)(function* (idx) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvar _usingCtx$1 = (0, import_usingCtx$1.default)();\n\t\t\t\t\t\tconst error = checkMaxDepth(path);\n\t\t\t\t\t\tif (error) throw error;\n\t\t\t\t\t\tconst iterator = _usingCtx$1.a(iteratorResource(iterable$1));\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\t\tconst next = yield (0, import_awaitAsyncGenerator$1.default)(iterator.next());\n\t\t\t\t\t\t\t\tif (next.done) {\n\t\t\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_RETURN,\n\t\t\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_YIELD,\n\t\t\t\t\t\t\t\t\tencode(next.value, path)\n\t\t\t\t\t\t\t\t];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} catch (cause) {\n\t\t\t\t\t\t\tvar _opts$onError3, _opts$formatError2;\n\t\t\t\t\t\t\t(_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tyield [\n\t\t\t\t\t\t\t\tidx,\n\t\t\t\t\t\t\t\tASYNC_ITERABLE_STATUS_ERROR,\n\t\t\t\t\t\t\t\t(_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, {\n\t\t\t\t\t\t\t\t\terror: cause,\n\t\t\t\t\t\t\t\t\tpath\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t];\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (_) {\n\t\t\t\t\t\t_usingCtx$1.e = _;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tyield (0, import_awaitAsyncGenerator$1.default)(_usingCtx$1.d());\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn function(_x2) {\n\t\t\t\t\treturn _ref2.apply(this, arguments);\n\t\t\t\t};\n\t\t\t}());\n\t\t}\n\t\tfunction checkMaxDepth(path) {\n\t\t\tif (opts.maxDepth && path.length > opts.maxDepth) return new MaxDepthError(path);\n\t\t\treturn null;\n\t\t}\n\t\tfunction encodeAsync(value, path) {\n\t\t\tif (isPromise(value)) return [CHUNK_VALUE_TYPE_PROMISE, encodePromise(value, path)];\n\t\t\tif ((0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(value)) {\n\t\t\t\tif (opts.maxDepth && path.length >= opts.maxDepth) throw new Error(\"Max depth reached\");\n\t\t\t\treturn [CHUNK_VALUE_TYPE_ASYNC_ITERABLE, encodeAsyncIterable(value, path)];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\tfunction encode(value, path) {\n\t\t\tif (value === void 0) return [[]];\n\t\t\tconst reg = encodeAsync(value, path);\n\t\t\tif (reg) return [[placeholder], [null, ...reg]];\n\t\t\tif (!isPlainObject(value)) return [[value]];\n\t\t\tconst newObj = {};\n\t\t\tconst asyncValues = [];\n\t\t\tfor (const [key, item] of Object.entries(value)) {\n\t\t\t\tconst transformed = encodeAsync(item, [...path, key]);\n\t\t\t\tif (!transformed) {\n\t\t\t\t\tnewObj[key] = item;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tnewObj[key] = placeholder;\n\t\t\t\tasyncValues.push([key, ...transformed]);\n\t\t\t}\n\t\t\treturn [[newObj], ...asyncValues];\n\t\t}\n\t\tconst newHead = {};\n\t\tfor (const [key, item] of Object.entries(data)) newHead[key] = encode(item, [key]);\n\t\tyield newHead;\n\t\tlet iterable = mergedIterables;\n\t\tif (opts.pingMs) iterable = withPing(mergedIterables, opts.pingMs);\n\t\tvar _iteratorAbruptCompletion = false;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError;\n\t\ttry {\n\t\t\tfor (var _iterator = (0, import_asyncIterator$1.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator$1.default)(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n\t\t\t\tconst value = _step.value;\n\t\t\t\tyield value;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator$1.default)(_iterator.return());\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t}\n\t\t}\n\t});\n\treturn _createBatchStreamProducer.apply(this, arguments);\n}\n/**\n* JSON Lines stream producer\n* @see https://jsonlines.org/\n*/\nfunction jsonlStreamProducer(opts) {\n\tlet stream = readableStreamFrom(createBatchStreamProducer(opts));\n\tconst { serialize } = opts;\n\tif (serialize) stream = stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(PING_SYM);\n\t\telse controller.enqueue(serialize(chunk));\n\t} }));\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (chunk === PING_SYM) controller.enqueue(\" \");\n\t\telse controller.enqueue(JSON.stringify(chunk) + \"\\n\");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nvar AsyncError = class extends Error {\n\tconstructor(data) {\n\t\tsuper(\"Received error from server\");\n\t\tthis.data = data;\n\t}\n};\nconst nodeJsStreamToReaderEsque = (source) => {\n\treturn { getReader() {\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\tsource.on(\"data\", (chunk) => {\n\t\t\t\tcontroller.enqueue(chunk);\n\t\t\t});\n\t\t\tsource.on(\"end\", () => {\n\t\t\t\tcontroller.close();\n\t\t\t});\n\t\t\tsource.on(\"error\", (error) => {\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\t\t} });\n\t\treturn stream.getReader();\n\t} };\n};\nfunction createLineAccumulator(from) {\n\tconst reader = \"getReader\" in from ? from.getReader() : nodeJsStreamToReaderEsque(from).getReader();\n\tlet lineAggregate = \"\";\n\treturn new ReadableStream({\n\t\tasync pull(controller) {\n\t\t\tconst { done, value } = await reader.read();\n\t\t\tif (done) controller.close();\n\t\t\telse controller.enqueue(value);\n\t\t},\n\t\tcancel() {\n\t\t\treturn reader.cancel();\n\t\t}\n\t}).pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tvar _parts$pop;\n\t\tlineAggregate += chunk;\n\t\tconst parts = lineAggregate.split(\"\\n\");\n\t\tlineAggregate = (_parts$pop = parts.pop()) !== null && _parts$pop !== void 0 ? _parts$pop : \"\";\n\t\tfor (const part of parts) controller.enqueue(part);\n\t} }));\n}\nfunction createConsumerStream(from) {\n\tconst stream = createLineAccumulator(from);\n\tlet sentHead = false;\n\treturn stream.pipeThrough(new TransformStream({ transform(line, controller) {\n\t\tif (!sentHead) {\n\t\t\tconst head = JSON.parse(line);\n\t\t\tcontroller.enqueue(head);\n\t\t\tsentHead = true;\n\t\t} else {\n\t\t\tconst chunk = JSON.parse(line);\n\t\t\tcontroller.enqueue(chunk);\n\t\t}\n\t} }));\n}\n/**\n* Creates a handler for managing stream controllers and their lifecycle\n*/\nfunction createStreamsManager(abortController) {\n\tconst controllerMap = /* @__PURE__ */ new Map();\n\t/**\n\t* Checks if there are no pending controllers or deferred promises\n\t*/\n\tfunction isEmpty() {\n\t\treturn Array.from(controllerMap.values()).every((c) => c.closed);\n\t}\n\t/**\n\t* Creates a stream controller\n\t*/\n\tfunction createStreamController() {\n\t\tlet originalController;\n\t\tconst stream = new ReadableStream({ start(controller) {\n\t\t\toriginalController = controller;\n\t\t} });\n\t\tconst streamController = {\n\t\t\tenqueue: (v) => originalController.enqueue(v),\n\t\t\tclose: () => {\n\t\t\t\toriginalController.close();\n\t\t\t\tclear();\n\t\t\t\tif (isEmpty()) abortController.abort();\n\t\t\t},\n\t\t\tclosed: false,\n\t\t\tgetReaderResource: () => {\n\t\t\t\tconst reader = stream.getReader();\n\t\t\t\treturn makeResource(reader, () => {\n\t\t\t\t\tstreamController.close();\n\t\t\t\t\treader.releaseLock();\n\t\t\t\t});\n\t\t\t},\n\t\t\terror: (reason) => {\n\t\t\t\toriginalController.error(reason);\n\t\t\t\tclear();\n\t\t\t}\n\t\t};\n\t\tfunction clear() {\n\t\t\tObject.assign(streamController, {\n\t\t\t\tclosed: true,\n\t\t\t\tclose: () => {},\n\t\t\t\tenqueue: () => {},\n\t\t\t\tgetReaderResource: null,\n\t\t\t\terror: () => {}\n\t\t\t});\n\t\t}\n\t\treturn streamController;\n\t}\n\t/**\n\t* Gets or creates a stream controller\n\t*/\n\tfunction getOrCreate(chunkId) {\n\t\tlet c = controllerMap.get(chunkId);\n\t\tif (!c) {\n\t\t\tc = createStreamController();\n\t\t\tcontrollerMap.set(chunkId, c);\n\t\t}\n\t\treturn c;\n\t}\n\t/**\n\t* Cancels all pending controllers and rejects deferred promises\n\t*/\n\tfunction cancelAll(reason) {\n\t\tfor (const controller of controllerMap.values()) controller.error(reason);\n\t}\n\treturn {\n\t\tgetOrCreate,\n\t\tcancelAll\n\t};\n}\n/**\n* JSON Lines stream consumer\n* @see https://jsonlines.org/\n*/\nasync function jsonlStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet source = createConsumerStream(opts.from);\n\tif (deserialize) source = source.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tcontroller.enqueue(deserialize(chunk));\n\t} }));\n\tlet headDeferred = createDeferred();\n\tconst streamManager = createStreamsManager(opts.abortController);\n\tfunction decodeChunkDefinition(value) {\n\t\tconst [_path, type, chunkId] = value;\n\t\tconst controller = streamManager.getOrCreate(chunkId);\n\t\tswitch (type) {\n\t\t\tcase CHUNK_VALUE_TYPE_PROMISE: return (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx3 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx3.u(controller.getReaderResource());\n\t\t\t\t\tconst { value: value$1 } = await reader.read();\n\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\tcase PROMISE_STATUS_FULFILLED: return decode(data);\n\t\t\t\t\t\tcase PROMISE_STATUS_REJECTED:\n\t\t\t\t\t\t\tvar _opts$formatError3, _opts$formatError4;\n\t\t\t\t\t\t\tthrow (_opts$formatError3 = (_opts$formatError4 = opts.formatError) === null || _opts$formatError4 === void 0 ? void 0 : _opts$formatError4.call(opts, { error: data })) !== null && _opts$formatError3 !== void 0 ? _opts$formatError3 : new AsyncError(data);\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx3.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx3.d();\n\t\t\t\t}\n\t\t\t});\n\t\t\tcase CHUNK_VALUE_TYPE_ASYNC_ITERABLE: return (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$2.default)(function* () {\n\t\t\t\ttry {\n\t\t\t\t\tvar _usingCtx4 = (0, import_usingCtx$1.default)();\n\t\t\t\t\tconst reader = _usingCtx4.u(controller.getReaderResource());\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tconst { value: value$1 } = yield (0, import_awaitAsyncGenerator$1.default)(reader.read());\n\t\t\t\t\t\tconst [_chunkId, status, data] = value$1;\n\t\t\t\t\t\tswitch (status) {\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_YIELD:\n\t\t\t\t\t\t\t\tyield decode(data);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_RETURN: return decode(data);\n\t\t\t\t\t\t\tcase ASYNC_ITERABLE_STATUS_ERROR:\n\t\t\t\t\t\t\t\tvar _opts$formatError5, _opts$formatError6;\n\t\t\t\t\t\t\t\tthrow (_opts$formatError5 = (_opts$formatError6 = opts.formatError) === null || _opts$formatError6 === void 0 ? void 0 : _opts$formatError6.call(opts, { error: data })) !== null && _opts$formatError5 !== void 0 ? _opts$formatError5 : new AsyncError(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (_) {\n\t\t\t\t\t_usingCtx4.e = _;\n\t\t\t\t} finally {\n\t\t\t\t\t_usingCtx4.d();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t}\n\tfunction decode(value) {\n\t\tconst [[data], ...asyncProps] = value;\n\t\tfor (const value$1 of asyncProps) {\n\t\t\tconst [key] = value$1;\n\t\t\tconst decoded = decodeChunkDefinition(value$1);\n\t\t\tif (key === null) return decoded;\n\t\t\tdata[key] = decoded;\n\t\t}\n\t\treturn data;\n\t}\n\tconst closeOrAbort = (reason) => {\n\t\theadDeferred === null || headDeferred === void 0 || headDeferred.reject(reason);\n\t\tstreamManager.cancelAll(reason);\n\t};\n\tsource.pipeTo(new WritableStream({\n\t\twrite(chunkOrHead) {\n\t\t\tif (headDeferred) {\n\t\t\t\tconst head = chunkOrHead;\n\t\t\t\tfor (const [key, value] of Object.entries(chunkOrHead)) {\n\t\t\t\t\tconst parsed = decode(value);\n\t\t\t\t\thead[key] = parsed;\n\t\t\t\t}\n\t\t\t\theadDeferred.resolve(head);\n\t\t\t\theadDeferred = null;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst chunk = chunkOrHead;\n\t\t\tconst [idx] = chunk;\n\t\t\tconst controller = streamManager.getOrCreate(idx);\n\t\t\tcontroller.enqueue(chunk);\n\t\t},\n\t\tclose: closeOrAbort,\n\t\tabort: closeOrAbort\n\t})).catch((error) => {\n\t\tvar _opts$onError4;\n\t\t(_opts$onError4 = opts.onError) === null || _opts$onError4 === void 0 || _opts$onError4.call(opts, { error });\n\t\tcloseOrAbort(error);\n\t});\n\treturn [await headDeferred.promise];\n}\n\n//#endregion\n//#region ../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\nvar require_asyncGeneratorDelegate = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({ \"../../node_modules/.pnpm/@oxc-project+runtime@0.72.2/node_modules/@oxc-project/runtime/src/helpers/asyncGeneratorDelegate.js\"(exports, module) {\n\tvar OverloadYield = require_OverloadYield();\n\tfunction _asyncGeneratorDelegate$1(t) {\n\t\tvar e = {}, n = !1;\n\t\tfunction pump(e$1, r) {\n\t\t\treturn n = !0, r = new Promise(function(n$1) {\n\t\t\t\tn$1(t[e$1](r));\n\t\t\t}), {\n\t\t\t\tdone: !1,\n\t\t\t\tvalue: new OverloadYield(r, 1)\n\t\t\t};\n\t\t}\n\t\treturn e[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function() {\n\t\t\treturn this;\n\t\t}, e.next = function(t$1) {\n\t\t\treturn n ? (n = !1, t$1) : pump(\"next\", t$1);\n\t\t}, \"function\" == typeof t[\"throw\"] && (e[\"throw\"] = function(t$1) {\n\t\t\tif (n) throw n = !1, t$1;\n\t\t\treturn pump(\"throw\", t$1);\n\t\t}), \"function\" == typeof t[\"return\"] && (e[\"return\"] = function(t$1) {\n\t\t\treturn n ? (n = !1, t$1) : pump(\"return\", t$1);\n\t\t}), e;\n\t}\n\tmodule.exports = _asyncGeneratorDelegate$1, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n} });\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/sse.ts\nvar import_asyncIterator = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncIterator(), 1);\nvar import_awaitAsyncGenerator = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_awaitAsyncGenerator(), 1);\nvar import_wrapAsyncGenerator$1 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_asyncGeneratorDelegate = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_asyncGeneratorDelegate(), 1);\nvar import_usingCtx = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_usingCtx(), 1);\nconst PING_EVENT = \"ping\";\nconst SERIALIZED_ERROR_EVENT = \"serialized-error\";\nconst CONNECTED_EVENT = \"connected\";\nconst RETURN_EVENT = \"return\";\n/**\n*\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamProducer(opts) {\n\tvar _opts$ping$enabled, _opts$ping, _opts$ping$intervalMs, _opts$ping2, _opts$client;\n\tconst { serialize = _utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.identity } = opts;\n\tconst ping = {\n\t\tenabled: (_opts$ping$enabled = (_opts$ping = opts.ping) === null || _opts$ping === void 0 ? void 0 : _opts$ping.enabled) !== null && _opts$ping$enabled !== void 0 ? _opts$ping$enabled : false,\n\t\tintervalMs: (_opts$ping$intervalMs = (_opts$ping2 = opts.ping) === null || _opts$ping2 === void 0 ? void 0 : _opts$ping2.intervalMs) !== null && _opts$ping$intervalMs !== void 0 ? _opts$ping$intervalMs : 1e3\n\t};\n\tconst client = (_opts$client = opts.client) !== null && _opts$client !== void 0 ? _opts$client : {};\n\tif (ping.enabled && client.reconnectAfterInactivityMs && ping.intervalMs > client.reconnectAfterInactivityMs) throw new Error(`Ping interval must be less than client reconnect interval to prevent unnecessary reconnection - ping.intervalMs: ${ping.intervalMs} client.reconnectAfterInactivityMs: ${client.reconnectAfterInactivityMs}`);\n\tfunction generator() {\n\t\treturn _generator.apply(this, arguments);\n\t}\n\tfunction _generator() {\n\t\t_generator = (0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\t\tyield {\n\t\t\t\tevent: CONNECTED_EVENT,\n\t\t\t\tdata: JSON.stringify(client)\n\t\t\t};\n\t\t\tlet iterable = opts.data;\n\t\t\tif (opts.emitAndEndImmediately) iterable = takeWithGrace(iterable, {\n\t\t\t\tcount: 1,\n\t\t\t\tgracePeriodMs: 1\n\t\t\t});\n\t\t\tif (opts.maxDurationMs && opts.maxDurationMs > 0 && opts.maxDurationMs !== Infinity) iterable = withMaxDuration(iterable, { maxDurationMs: opts.maxDurationMs });\n\t\t\tif (ping.enabled && ping.intervalMs !== Infinity && ping.intervalMs > 0) iterable = withPing(iterable, ping.intervalMs);\n\t\t\tlet value;\n\t\t\tlet chunk;\n\t\t\tvar _iteratorAbruptCompletion = false;\n\t\t\tvar _didIteratorError = false;\n\t\t\tvar _iteratorError;\n\t\t\ttry {\n\t\t\t\tfor (var _iterator = (0, import_asyncIterator.default)(iterable), _step; _iteratorAbruptCompletion = !(_step = yield (0, import_awaitAsyncGenerator.default)(_iterator.next())).done; _iteratorAbruptCompletion = false) {\n\t\t\t\t\tvalue = _step.value;\n\t\t\t\t\t{\n\t\t\t\t\t\tif (value === PING_SYM) {\n\t\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\t\tevent: PING_EVENT,\n\t\t\t\t\t\t\t\tdata: \"\"\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchunk = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.isTrackedEnvelope)(value) ? {\n\t\t\t\t\t\t\tid: value[0],\n\t\t\t\t\t\t\tdata: value[1]\n\t\t\t\t\t\t} : { data: value };\n\t\t\t\t\t\tchunk.data = JSON.stringify(serialize(chunk.data));\n\t\t\t\t\t\tyield chunk;\n\t\t\t\t\t\tvalue = null;\n\t\t\t\t\t\tchunk = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\t_didIteratorError = true;\n\t\t\t\t_iteratorError = err;\n\t\t\t} finally {\n\t\t\t\ttry {\n\t\t\t\t\tif (_iteratorAbruptCompletion && _iterator.return != null) yield (0, import_awaitAsyncGenerator.default)(_iterator.return());\n\t\t\t\t} finally {\n\t\t\t\t\tif (_didIteratorError) throw _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn _generator.apply(this, arguments);\n\t}\n\tfunction generatorWithErrorHandling() {\n\t\treturn _generatorWithErrorHandling.apply(this, arguments);\n\t}\n\tfunction _generatorWithErrorHandling() {\n\t\t_generatorWithErrorHandling = (0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\t\ttry {\n\t\t\t\tyield* (0, import_asyncGeneratorDelegate.default)((0, import_asyncIterator.default)(generator()));\n\t\t\t\tyield {\n\t\t\t\t\tevent: RETURN_EVENT,\n\t\t\t\t\tdata: \"\"\n\t\t\t\t};\n\t\t\t} catch (cause) {\n\t\t\t\tvar _opts$formatError, _opts$formatError2;\n\t\t\t\tif (isAbortError(cause)) return;\n\t\t\t\tconst error = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\t\t\t\tconst data = (_opts$formatError = (_opts$formatError2 = opts.formatError) === null || _opts$formatError2 === void 0 ? void 0 : _opts$formatError2.call(opts, { error })) !== null && _opts$formatError !== void 0 ? _opts$formatError : null;\n\t\t\t\tyield {\n\t\t\t\t\tevent: SERIALIZED_ERROR_EVENT,\n\t\t\t\t\tdata: JSON.stringify(serialize(data))\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\treturn _generatorWithErrorHandling.apply(this, arguments);\n\t}\n\tconst stream = readableStreamFrom(generatorWithErrorHandling());\n\treturn stream.pipeThrough(new TransformStream({ transform(chunk, controller) {\n\t\tif (\"event\" in chunk) controller.enqueue(`event: ${chunk.event}\\n`);\n\t\tif (\"data\" in chunk) controller.enqueue(`data: ${chunk.data}\\n`);\n\t\tif (\"id\" in chunk) controller.enqueue(`id: ${chunk.id}\\n`);\n\t\tif (\"comment\" in chunk) controller.enqueue(`: ${chunk.comment}\\n`);\n\t\tcontroller.enqueue(\"\\n\\n\");\n\t} })).pipeThrough(new TextEncoderStream());\n}\nasync function withTimeout(opts) {\n\ttry {\n\t\tvar _usingCtx$1 = (0, import_usingCtx.default)();\n\t\tconst timeoutPromise = _usingCtx$1.u(timerResource(opts.timeoutMs));\n\t\tconst res = await Unpromise.race([opts.promise, timeoutPromise.start()]);\n\t\tif (res === disposablePromiseTimerResult) return await opts.onTimeout();\n\t\treturn res;\n\t} catch (_) {\n\t\t_usingCtx$1.e = _;\n\t} finally {\n\t\t_usingCtx$1.d();\n\t}\n}\n/**\n* @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n*/\nfunction sseStreamConsumer(opts) {\n\tconst { deserialize = (v) => v } = opts;\n\tlet clientOptions = {};\n\tconst signal = opts.signal;\n\tlet _es = null;\n\tconst createStream = () => new ReadableStream({\n\t\tasync start(controller) {\n\t\t\tconst [url, init] = await Promise.all([opts.url(), opts.init()]);\n\t\t\tconst eventSource = _es = new opts.EventSource(url, init);\n\t\t\tcontroller.enqueue({\n\t\t\t\ttype: \"connecting\",\n\t\t\t\teventSource: _es,\n\t\t\t\tevent: null\n\t\t\t});\n\t\t\teventSource.addEventListener(CONNECTED_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst options = JSON.parse(msg.data);\n\t\t\t\tclientOptions = options;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"connected\",\n\t\t\t\t\toptions,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(SERIALIZED_ERROR_EVENT, (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"serialized-error\",\n\t\t\t\t\terror: deserialize(JSON.parse(msg.data)),\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(PING_EVENT, () => {\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"ping\",\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(RETURN_EVENT, () => {\n\t\t\t\teventSource.close();\n\t\t\t\tcontroller.close();\n\t\t\t\t_es = null;\n\t\t\t});\n\t\t\teventSource.addEventListener(\"error\", (event) => {\n\t\t\t\tif (eventSource.readyState === eventSource.CLOSED) controller.error(event);\n\t\t\t\telse controller.enqueue({\n\t\t\t\t\ttype: \"connecting\",\n\t\t\t\t\teventSource,\n\t\t\t\t\tevent\n\t\t\t\t});\n\t\t\t});\n\t\t\teventSource.addEventListener(\"message\", (_msg) => {\n\t\t\t\tconst msg = _msg;\n\t\t\t\tconst chunk = deserialize(JSON.parse(msg.data));\n\t\t\t\tconst def = { data: chunk };\n\t\t\t\tif (msg.lastEventId) def.id = msg.lastEventId;\n\t\t\t\tcontroller.enqueue({\n\t\t\t\t\ttype: \"data\",\n\t\t\t\t\tdata: def,\n\t\t\t\t\teventSource\n\t\t\t\t});\n\t\t\t});\n\t\t\tconst onAbort = () => {\n\t\t\t\ttry {\n\t\t\t\t\teventSource.close();\n\t\t\t\t\tcontroller.close();\n\t\t\t\t} catch (_unused) {}\n\t\t\t};\n\t\t\tif (signal.aborted) onAbort();\n\t\t\telse signal.addEventListener(\"abort\", onAbort);\n\t\t},\n\t\tcancel() {\n\t\t\t_es === null || _es === void 0 || _es.close();\n\t\t}\n\t});\n\tconst getStreamResource = () => {\n\t\tlet stream = createStream();\n\t\tlet reader = stream.getReader();\n\t\tasync function dispose() {\n\t\t\tawait reader.cancel();\n\t\t\t_es = null;\n\t\t}\n\t\treturn makeAsyncResource({\n\t\t\tread() {\n\t\t\t\treturn reader.read();\n\t\t\t},\n\t\t\tasync recreate() {\n\t\t\t\tawait dispose();\n\t\t\t\tstream = createStream();\n\t\t\t\treader = stream.getReader();\n\t\t\t}\n\t\t}, dispose);\n\t};\n\treturn (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator$1.default)(function* () {\n\t\ttry {\n\t\t\tvar _usingCtx3 = (0, import_usingCtx.default)();\n\t\t\tconst stream = _usingCtx3.a(getStreamResource());\n\t\t\twhile (true) {\n\t\t\t\tlet promise = stream.read();\n\t\t\t\tconst timeoutMs = clientOptions.reconnectAfterInactivityMs;\n\t\t\t\tif (timeoutMs) promise = withTimeout({\n\t\t\t\t\tpromise,\n\t\t\t\t\ttimeoutMs,\n\t\t\t\t\tonTimeout: async () => {\n\t\t\t\t\t\tconst res = {\n\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\ttype: \"timeout\",\n\t\t\t\t\t\t\t\tms: timeoutMs,\n\t\t\t\t\t\t\t\teventSource: _es\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdone: false\n\t\t\t\t\t\t};\n\t\t\t\t\t\tawait stream.recreate();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tconst result = yield (0, import_awaitAsyncGenerator.default)(promise);\n\t\t\t\tif (result.done) return result.value;\n\t\t\t\tyield result.value;\n\t\t\t}\n\t\t} catch (_) {\n\t\t\t_usingCtx3.e = _;\n\t\t} finally {\n\t\t\tyield (0, import_awaitAsyncGenerator.default)(_usingCtx3.d());\n\t\t}\n\t}));\n}\nconst sseHeaders = {\n\t\"Content-Type\": \"text/event-stream\",\n\t\"Cache-Control\": \"no-cache, no-transform\",\n\t\"X-Accel-Buffering\": \"no\",\n\tConnection: \"keep-alive\"\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/http/resolveResponse.ts\nvar import_wrapAsyncGenerator = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_wrapAsyncGenerator(), 1);\nvar import_objectSpread2 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.__toESM)((0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.require_objectSpread2)(), 1);\nfunction errorToAsyncIterable(err) {\n\treturn (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)((0, import_wrapAsyncGenerator.default)(function* () {\n\t\tthrow err;\n\t}));\n}\nconst TYPE_ACCEPTED_METHOD_MAP = {\n\tmutation: [\"POST\"],\n\tquery: [\"GET\"],\n\tsubscription: [\"GET\"]\n};\nconst TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE = {\n\tmutation: [\"POST\"],\n\tquery: [\"GET\", \"POST\"],\n\tsubscription: [\"GET\", \"POST\"]\n};\nfunction initResponse(initOpts) {\n\tvar _responseMeta, _info$calls$find$proc, _info$calls$find;\n\tconst { ctx, info, responseMeta, untransformedJSON, errors = [], headers } = initOpts;\n\tlet status = untransformedJSON ? (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getHTTPStatusCode)(untransformedJSON) : 200;\n\tconst eagerGeneration = !untransformedJSON;\n\tconst data = eagerGeneration ? [] : Array.isArray(untransformedJSON) ? untransformedJSON : [untransformedJSON];\n\tconst meta = (_responseMeta = responseMeta === null || responseMeta === void 0 ? void 0 : responseMeta({\n\t\tctx,\n\t\tinfo,\n\t\tpaths: info === null || info === void 0 ? void 0 : info.calls.map((call) => call.path),\n\t\tdata,\n\t\terrors,\n\t\teagerGeneration,\n\t\ttype: (_info$calls$find$proc = info === null || info === void 0 || (_info$calls$find = info.calls.find((call) => {\n\t\t\tvar _call$procedure;\n\t\t\treturn (_call$procedure = call.procedure) === null || _call$procedure === void 0 ? void 0 : _call$procedure._def.type;\n\t\t})) === null || _info$calls$find === void 0 || (_info$calls$find = _info$calls$find.procedure) === null || _info$calls$find === void 0 ? void 0 : _info$calls$find._def.type) !== null && _info$calls$find$proc !== void 0 ? _info$calls$find$proc : \"unknown\"\n\t})) !== null && _responseMeta !== void 0 ? _responseMeta : {};\n\tif (meta.headers) {\n\t\tif (meta.headers instanceof Headers) for (const [key, value] of meta.headers.entries()) headers.append(key, value);\n\t\telse\n /**\n\t\t* @deprecated, delete in v12\n\t\t*/\n\t\tfor (const [key, value] of Object.entries(meta.headers)) if (Array.isArray(value)) for (const v of value) headers.append(key, v);\n\t\telse if (typeof value === \"string\") headers.set(key, value);\n\t}\n\tif (meta.status) status = meta.status;\n\treturn { status };\n}\nfunction caughtErrorToData(cause, errorOpts) {\n\tconst { router, req, onError } = errorOpts.opts;\n\tconst error = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\tonError === null || onError === void 0 || onError({\n\t\terror,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx,\n\t\ttype: errorOpts.type,\n\t\treq\n\t});\n\tconst untransformedJSON = { error: (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\tconfig: router._def._config,\n\t\terror,\n\t\ttype: errorOpts.type,\n\t\tpath: errorOpts.path,\n\t\tinput: errorOpts.input,\n\t\tctx: errorOpts.ctx\n\t}) };\n\tconst transformedJSON = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(router._def._config, untransformedJSON);\n\tconst body = JSON.stringify(transformedJSON);\n\treturn {\n\t\terror,\n\t\tuntransformedJSON,\n\t\tbody\n\t};\n}\n/**\n* Check if a value is a stream-like object\n* - if it's an async iterable\n* - if it's an object with async iterables or promises\n*/\nfunction isDataStream(v) {\n\tif (!(0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isObject)(v)) return false;\n\tif ((0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(v)) return true;\n\treturn Object.values(v).some(isPromise) || Object.values(v).some(_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable);\n}\nasync function resolveResponse(opts) {\n\tvar _ref, _opts$allowBatching, _opts$batching, _opts$allowMethodOver, _config$sse$enabled, _config$sse;\n\tconst { router, req } = opts;\n\tconst headers = new Headers([[\"vary\", \"trpc-accept\"]]);\n\tconst config = router._def._config;\n\tconst url = new URL(req.url);\n\tif (req.method === \"HEAD\") return new Response(null, { status: 204 });\n\tconst allowBatching = (_ref = (_opts$allowBatching = opts.allowBatching) !== null && _opts$allowBatching !== void 0 ? _opts$allowBatching : (_opts$batching = opts.batching) === null || _opts$batching === void 0 ? void 0 : _opts$batching.enabled) !== null && _ref !== void 0 ? _ref : true;\n\tconst allowMethodOverride = ((_opts$allowMethodOver = opts.allowMethodOverride) !== null && _opts$allowMethodOver !== void 0 ? _opts$allowMethodOver : false) && req.method === \"POST\";\n\tconst infoTuple = await (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(async () => {\n\t\ttry {\n\t\t\treturn [void 0, await getRequestInfo({\n\t\t\t\treq,\n\t\t\t\tpath: decodeURIComponent(opts.path),\n\t\t\t\trouter,\n\t\t\t\tsearchParams: url.searchParams,\n\t\t\t\theaders: opts.req.headers,\n\t\t\t\turl\n\t\t\t})];\n\t\t} catch (cause) {\n\t\t\treturn [(0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause), void 0];\n\t\t}\n\t});\n\tconst ctxManager = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(() => {\n\t\tlet result = void 0;\n\t\treturn {\n\t\t\tvalueOrUndefined: () => {\n\t\t\t\tif (!result) return void 0;\n\t\t\t\treturn result[1];\n\t\t\t},\n\t\t\tvalue: () => {\n\t\t\t\tconst [err, ctx] = result;\n\t\t\t\tif (err) throw err;\n\t\t\t\treturn ctx;\n\t\t\t},\n\t\t\tcreate: async (info) => {\n\t\t\t\tif (result) throw new Error(\"This should only be called once - report a bug in tRPC\");\n\t\t\t\ttry {\n\t\t\t\t\tconst ctx = await opts.createContext({ info });\n\t\t\t\t\tresult = [void 0, ctx];\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tresult = [(0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause), void 0];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t});\n\tconst methodMapper = allowMethodOverride ? TYPE_ACCEPTED_METHOD_MAP_WITH_METHOD_OVERRIDE : TYPE_ACCEPTED_METHOD_MAP;\n\t/**\n\t* @deprecated\n\t*/\n\tconst isStreamCall = req.headers.get(\"trpc-accept\") === \"application/jsonl\";\n\tconst experimentalSSE = (_config$sse$enabled = (_config$sse = config.sse) === null || _config$sse === void 0 ? void 0 : _config$sse.enabled) !== null && _config$sse$enabled !== void 0 ? _config$sse$enabled : true;\n\ttry {\n\t\tconst [infoError, info] = infoTuple;\n\t\tif (infoError) throw infoError;\n\t\tif (info.isBatchCall && !allowBatching) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tcode: \"BAD_REQUEST\",\n\t\t\tmessage: `Batching is not enabled on the server`\n\t\t});\n\t\t/* istanbul ignore if -- @preserve */\n\t\tif (isStreamCall && !info.isBatchCall) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\tmessage: `Streaming requests must be batched (you can do a batch of 1)`,\n\t\t\tcode: \"BAD_REQUEST\"\n\t\t});\n\t\tawait ctxManager.create(info);\n\t\tconst rpcCalls = info.calls.map(async (call) => {\n\t\t\tconst proc = call.procedure;\n\t\t\ttry {\n\t\t\t\tif (opts.error) throw opts.error;\n\t\t\t\tif (!proc) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: \"NOT_FOUND\",\n\t\t\t\t\tmessage: `No procedure found on path \"${call.path}\"`\n\t\t\t\t});\n\t\t\t\tif (!methodMapper[proc._def.type].includes(req.method)) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\t\t\tmessage: `Unsupported ${req.method}-request to ${proc._def.type} procedure at path \"${call.path}\"`\n\t\t\t\t});\n\t\t\t\tif (proc._def.type === \"subscription\") {\n\t\t\t\t\t/* istanbul ignore if -- @preserve */\n\t\t\t\t\tif (info.isBatchCall) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\tcode: \"BAD_REQUEST\",\n\t\t\t\t\t\tmessage: `Cannot batch subscription calls`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst data = await proc({\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tgetRawInput: call.getRawInput,\n\t\t\t\t\tctx: ctxManager.value(),\n\t\t\t\t\ttype: proc._def.type,\n\t\t\t\t\tsignal: opts.req.signal\n\t\t\t\t});\n\t\t\t\treturn [void 0, { data }];\n\t\t\t} catch (cause) {\n\t\t\t\tvar _opts$onError, _call$procedure$_def$, _call$procedure2;\n\t\t\t\tconst error = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause);\n\t\t\t\tconst input = call.result();\n\t\t\t\t(_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\terror,\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\tinput,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\ttype: (_call$procedure$_def$ = (_call$procedure2 = call.procedure) === null || _call$procedure2 === void 0 ? void 0 : _call$procedure2._def.type) !== null && _call$procedure$_def$ !== void 0 ? _call$procedure$_def$ : \"unknown\",\n\t\t\t\t\treq: opts.req\n\t\t\t\t});\n\t\t\t\treturn [error, void 0];\n\t\t\t}\n\t\t});\n\t\tif (!info.isBatchCall) {\n\t\t\tconst [call] = info.calls;\n\t\t\tconst [error, result] = await rpcCalls[0];\n\t\t\tswitch (info.type) {\n\t\t\t\tcase \"unknown\":\n\t\t\t\tcase \"mutation\":\n\t\t\t\tcase \"query\": {\n\t\t\t\t\theaders.set(\"content-type\", \"application/json\");\n\t\t\t\t\tif (isDataStream(result === null || result === void 0 ? void 0 : result.data)) throw new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\t\t\tmessage: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n\t\t\t\t\t});\n\t\t\t\t\tconst res = error ? { error: (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\ttype: info.type\n\t\t\t\t\t}) } : { result: { data: result.data } };\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: error ? [error] : [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: [res]\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(JSON.stringify((0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, res)), {\n\t\t\t\t\t\tstatus: headResponse$1.status,\n\t\t\t\t\t\theaders\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcase \"subscription\": {\n\t\t\t\t\tconst iterable = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.run)(() => {\n\t\t\t\t\t\tif (error) return errorToAsyncIterable(error);\n\t\t\t\t\t\tif (!experimentalSSE) return errorToAsyncIterable(new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\t\t\t\t\t\tmessage: \"Missing experimental flag \\\"sseSubscriptions\\\"\"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tif (!(0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) && !(0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_0__.isAsyncIterable)(result.data)) return errorToAsyncIterable(new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\t\t\t\tmessage: `Subscription ${call.path} did not return an observable or a AsyncGenerator`,\n\t\t\t\t\t\t\tcode: \"INTERNAL_SERVER_ERROR\"\n\t\t\t\t\t\t}));\n\t\t\t\t\t\tconst dataAsIterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : result.data;\n\t\t\t\t\t\treturn dataAsIterable;\n\t\t\t\t\t});\n\t\t\t\t\tconst stream = sseStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.sse), {}, {\n\t\t\t\t\t\tdata: iterable,\n\t\t\t\t\t\tserialize: (v) => config.transformer.output.serialize(v),\n\t\t\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\t\t\tvar _call$procedure$_def$2, _call$procedure3, _opts$onError2;\n\t\t\t\t\t\t\tconst error$1 = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n\t\t\t\t\t\t\tconst input = call === null || call === void 0 ? void 0 : call.result();\n\t\t\t\t\t\t\tconst path = call === null || call === void 0 ? void 0 : call.path;\n\t\t\t\t\t\t\tconst type = (_call$procedure$_def$2 = call === null || call === void 0 || (_call$procedure3 = call.procedure) === null || _call$procedure3 === void 0 ? void 0 : _call$procedure3._def.type) !== null && _call$procedure$_def$2 !== void 0 ? _call$procedure$_def$2 : \"unknown\";\n\t\t\t\t\t\t\t(_opts$onError2 = opts.onError) === null || _opts$onError2 === void 0 || _opts$onError2.call(opts, {\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tconst shape = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\t\terror: error$1,\n\t\t\t\t\t\t\t\tinput,\n\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\ttype\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn shape;\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t\tfor (const [key, value] of Object.entries(sseHeaders)) headers.set(key, value);\n\t\t\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\tinfo,\n\t\t\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\t\t\terrors: [],\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tuntransformedJSON: null\n\t\t\t\t\t});\n\t\t\t\t\treturn new Response(stream, {\n\t\t\t\t\t\theaders,\n\t\t\t\t\t\tstatus: headResponse$1.status\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (info.accept === \"application/jsonl\") {\n\t\t\theaders.set(\"content-type\", \"application/json\");\n\t\t\theaders.set(\"transfer-encoding\", \"chunked\");\n\t\t\tconst headResponse$1 = initResponse({\n\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\tinfo,\n\t\t\t\tresponseMeta: opts.responseMeta,\n\t\t\t\terrors: [],\n\t\t\t\theaders,\n\t\t\t\tuntransformedJSON: null\n\t\t\t});\n\t\t\tconst stream = jsonlStreamProducer((0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, config.jsonl), {}, {\n\t\t\t\tmaxDepth: Infinity,\n\t\t\t\tdata: rpcCalls.map(async (res) => {\n\t\t\t\t\tconst [error, result] = await res;\n\t\t\t\t\tconst call = info.calls[0];\n\t\t\t\t\tif (error) {\n\t\t\t\t\t\tvar _procedure$_def$type, _procedure;\n\t\t\t\t\t\treturn { error: (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\t\tconfig,\n\t\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tinput: call.result(),\n\t\t\t\t\t\t\tpath: call.path,\n\t\t\t\t\t\t\ttype: (_procedure$_def$type = (_procedure = call.procedure) === null || _procedure === void 0 ? void 0 : _procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n\t\t\t\t\t\t}) };\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t* Not very pretty, but we need to wrap nested data in promises\n\t\t\t\t\t* Our stream producer will only resolve top-level async values or async values that are directly nested in another async value\n\t\t\t\t\t*/\n\t\t\t\t\tconst iterable = (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.isObservable)(result.data) ? (0,_observable_UMO3vUa_mjs__WEBPACK_IMPORTED_MODULE_3__.observableToAsyncIterable)(result.data, opts.req.signal) : Promise.resolve(result.data);\n\t\t\t\t\treturn { result: Promise.resolve({ data: iterable }) };\n\t\t\t\t}),\n\t\t\t\tserialize: (data) => config.transformer.output.serialize(data),\n\t\t\t\tonError: (cause) => {\n\t\t\t\t\tvar _opts$onError3, _info$type;\n\t\t\t\t\t(_opts$onError3 = opts.onError) === null || _opts$onError3 === void 0 || _opts$onError3.call(opts, {\n\t\t\t\t\t\terror: (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(cause),\n\t\t\t\t\t\tpath: void 0,\n\t\t\t\t\t\tinput: void 0,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\treq: opts.req,\n\t\t\t\t\t\ttype: (_info$type = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type !== void 0 ? _info$type : \"unknown\"\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tformatError(errorOpts) {\n\t\t\t\t\tvar _call$procedure$_def$3, _call$procedure4;\n\t\t\t\t\tconst call = info === null || info === void 0 ? void 0 : info.calls[errorOpts.path[0]];\n\t\t\t\t\tconst error = (0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.getTRPCErrorFromUnknown)(errorOpts.error);\n\t\t\t\t\tconst input = call === null || call === void 0 ? void 0 : call.result();\n\t\t\t\t\tconst path = call === null || call === void 0 ? void 0 : call.path;\n\t\t\t\t\tconst type = (_call$procedure$_def$3 = call === null || call === void 0 || (_call$procedure4 = call.procedure) === null || _call$procedure4 === void 0 ? void 0 : _call$procedure4._def.type) !== null && _call$procedure$_def$3 !== void 0 ? _call$procedure$_def$3 : \"unknown\";\n\t\t\t\t\tconst shape = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\t\tconfig,\n\t\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tinput,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\ttype\n\t\t\t\t\t});\n\t\t\t\t\treturn shape;\n\t\t\t\t}\n\t\t\t}));\n\t\t\treturn new Response(stream, {\n\t\t\t\theaders,\n\t\t\t\tstatus: headResponse$1.status\n\t\t\t});\n\t\t}\n\t\t/**\n\t\t* Non-streaming response:\n\t\t* - await all responses in parallel, blocking on the slowest one\n\t\t* - create headers with known response body\n\t\t* - return a complete HTTPResponse\n\t\t*/\n\t\theaders.set(\"content-type\", \"application/json\");\n\t\tconst results = (await Promise.all(rpcCalls)).map((res) => {\n\t\t\tconst [error, result] = res;\n\t\t\tif (error) return res;\n\t\t\tif (isDataStream(result.data)) return [new _tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.TRPCError({\n\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\",\n\t\t\t\tmessage: \"Cannot use stream-like response in non-streaming request - use httpBatchStreamLink\"\n\t\t\t}), void 0];\n\t\t\treturn res;\n\t\t});\n\t\tconst resultAsRPCResponse = results.map(([error, result], index) => {\n\t\t\tconst call = info.calls[index];\n\t\t\tif (error) {\n\t\t\t\tvar _call$procedure$_def$4, _call$procedure5;\n\t\t\t\treturn { error: (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_2__.getErrorShape)({\n\t\t\t\t\tconfig,\n\t\t\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\t\t\terror,\n\t\t\t\t\tinput: call.result(),\n\t\t\t\t\tpath: call.path,\n\t\t\t\t\ttype: (_call$procedure$_def$4 = (_call$procedure5 = call.procedure) === null || _call$procedure5 === void 0 ? void 0 : _call$procedure5._def.type) !== null && _call$procedure$_def$4 !== void 0 ? _call$procedure$_def$4 : \"unknown\"\n\t\t\t\t}) };\n\t\t\t}\n\t\t\treturn { result: { data: result.data } };\n\t\t});\n\t\tconst errors = results.map(([error]) => error).filter(Boolean);\n\t\tconst headResponse = initResponse({\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON: resultAsRPCResponse,\n\t\t\terrors,\n\t\t\theaders\n\t\t});\n\t\treturn new Response(JSON.stringify((0,_tracked_Blz8XOf1_mjs__WEBPACK_IMPORTED_MODULE_1__.transformTRPCResponse)(config, resultAsRPCResponse)), {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t} catch (cause) {\n\t\tvar _info$type2;\n\t\tconst [_infoError, info] = infoTuple;\n\t\tconst ctx = ctxManager.valueOrUndefined();\n\t\tconst { error, untransformedJSON, body } = caughtErrorToData(cause, {\n\t\t\topts,\n\t\t\tctx: ctxManager.valueOrUndefined(),\n\t\t\ttype: (_info$type2 = info === null || info === void 0 ? void 0 : info.type) !== null && _info$type2 !== void 0 ? _info$type2 : \"unknown\"\n\t\t});\n\t\tconst headResponse = initResponse({\n\t\t\tctx,\n\t\t\tinfo,\n\t\t\tresponseMeta: opts.responseMeta,\n\t\t\tuntransformedJSON,\n\t\t\terrors: [error],\n\t\t\theaders\n\t\t});\n\t\treturn new Response(body, {\n\t\t\tstatus: headResponse.status,\n\t\t\theaders\n\t\t});\n\t}\n}\n\n//#endregion\n\n//# sourceMappingURL=resolveResponse-DngSgha6.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC9yZXNvbHZlUmVzcG9uc2UtRG5nU2doYTYubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvSjtBQUNWO0FBQzlDO0FBQ1I7O0FBRXBGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyw0REFBUTtBQUNmO0FBQ0Esd0dBQXdHLHlDQUF5QyxJQUFJLElBQUksYUFBYSxjQUFjO0FBQ3BMO0FBQ0EsR0FBRztBQUNILFlBQVksNERBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDREQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixvRUFBTyxDQUFDLGtGQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0REFBUztBQUNsQyxjQUFjLDREQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsVUFBVSxNQUFNO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOEJBQThCO0FBQzlCLFFBQVEsNERBQVEsb0JBQW9CLDREQUFTO0FBQzdDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMkJBQTJCLHlF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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxtRUFBZTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLCtHQUErRztBQUM3TDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCLGtFQUFrRTtBQUNsRTtBQUNBO0FB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YTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxZQUFZLFVBQVU7QUFDdEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUNBQXFDLDRFQUFxQjtBQUMxRDtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxVQUFVLGlDQUFpQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDb1g7QUFDcFgiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcaGVyaWNcXGR5YWQtYXBwc1xccm9yay11bmlwYWxtLS0tQ2gtbmctbi1uZy1jLUd1LWNvcHlcXG5vZGVfbW9kdWxlc1xcLnBucG1cXEB0cnBjK3NlcnZlckAxMS43LjFfdHlwZXNjcmlwdEA1LjkuM1xcbm9kZV9tb2R1bGVzXFxAdHJwY1xcc2VydmVyXFxkaXN0XFxyZXNvbHZlUmVzcG9uc2UtRG5nU2doYTYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fY29tbW9uSlMsIF9fdG9FU00sIGdldEVycm9yU2hhcGUsIGdldEhUVFBTdGF0dXNDb2RlLCByZXF1aXJlX2RlZmluZVByb3BlcnR5LCByZXF1aXJlX29iamVjdFNwcmVhZDIgfSBmcm9tIFwiLi9nZXRFcnJvclNoYXBlLUJINjBpTUMyLm1qc1wiO1xuaW1wb3J0IHsgVFJQQ0Vycm9yLCBnZXRQcm9jZWR1cmVBdFBhdGgsIGdldFRSUENFcnJvckZyb21Vbmtub3duLCBpc1RyYWNrZWRFbnZlbG9wZSwgdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlIH0gZnJvbSBcIi4vdHJhY2tlZC1CbHo4WE9mMS5tanNcIjtcbmltcG9ydCB7IGlkZW50aXR5LCBpc0FzeW5jSXRlcmFibGUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBydW4gfSBmcm9tIFwiLi91dGlscy1DTFpuSmRiXy5tanNcIjtcbmltcG9ydCB7IGlzT2JzZXJ2YWJsZSwgb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZSB9IGZyb20gXCIuL29ic2VydmFibGUtVU1PM3ZVYV8ubWpzXCI7XG5cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvcGFyc2VDb25uZWN0aW9uUGFyYW1zLnRzXG5mdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93bihwYXJzZWQpIHtcblx0dHJ5IHtcblx0XHRpZiAocGFyc2VkID09PSBudWxsKSByZXR1cm4gbnVsbDtcblx0XHRpZiAoIWlzT2JqZWN0KHBhcnNlZCkpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG9iamVjdFwiKTtcblx0XHRjb25zdCBub25TdHJpbmdWYWx1ZXMgPSBPYmplY3QuZW50cmllcyhwYXJzZWQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKTtcblx0XHRpZiAobm9uU3RyaW5nVmFsdWVzLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgY29ubmVjdGlvblBhcmFtcyB0byBiZSBzdHJpbmcgdmFsdWVzLiBHb3QgJHtub25TdHJpbmdWYWx1ZXMubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX06ICR7dHlwZW9mIHZhbHVlfWApLmpvaW4oXCIsIFwiKX1gKTtcblx0XHRyZXR1cm4gcGFyc2VkO1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJQQVJTRV9FUlJPUlwiLFxuXHRcdFx0bWVzc2FnZTogXCJJbnZhbGlkIGNvbm5lY3Rpb24gcGFyYW1zIHNoYXBlXCIsXG5cdFx0XHRjYXVzZVxuXHRcdH0pO1xuXHR9XG59XG5mdW5jdGlvbiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tU3RyaW5nKHN0cikge1xuXHRsZXQgcGFyc2VkO1xuXHR0cnkge1xuXHRcdHBhcnNlZCA9IEpTT04ucGFyc2Uoc3RyKTtcblx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHR0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdGNvZGU6IFwiUEFSU0VfRVJST1JcIixcblx0XHRcdG1lc3NhZ2U6IFwiTm90IEpTT04tcGFyc2FibGUgcXVlcnkgcGFyYW1zXCIsXG5cdFx0XHRjYXVzZVxuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93bihwYXJzZWQpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvY29udGVudFR5cGUudHNcbnZhciBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxID0gX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSwgMSk7XG4vKipcbiogTWVtb2l6ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG1lbW8oZm4pIHtcblx0bGV0IHByb21pc2UgPSBudWxsO1xuXHRjb25zdCBzeW0gPSBTeW1ib2wuZm9yKFwiQHRycGMvc2VydmVyL2h0dHAvbWVtb1wiKTtcblx0bGV0IHZhbHVlID0gc3ltO1xuXHRyZXR1cm4ge1xuXHRcdHJlYWQ6IGFzeW5jICgpID0+IHtcblx0XHRcdHZhciBfcHJvbWlzZTtcblx0XHRcdGlmICh2YWx1ZSAhPT0gc3ltKSByZXR1cm4gdmFsdWU7XG5cdFx0XHQoX3Byb21pc2UgPSBwcm9taXNlKSAhPT0gbnVsbCAmJiBfcHJvbWlzZSAhPT0gdm9pZCAwIHx8IChwcm9taXNlID0gZm4oKS5jYXRjaCgoY2F1c2UpID0+IHtcblx0XHRcdFx0aWYgKGNhdXNlIGluc3RhbmNlb2YgVFJQQ0Vycm9yKSB0aHJvdyBjYXVzZTtcblx0XHRcdFx0dGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGNhdXNlIGluc3RhbmNlb2YgRXJyb3IgPyBjYXVzZS5tZXNzYWdlIDogXCJJbnZhbGlkIGlucHV0XCIsXG5cdFx0XHRcdFx0Y2F1c2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KSk7XG5cdFx0XHR2YWx1ZSA9IGF3YWl0IHByb21pc2U7XG5cdFx0XHRwcm9taXNlID0gbnVsbDtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9LFxuXHRcdHJlc3VsdDogKCkgPT4ge1xuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSBzeW0gPyB2YWx1ZSA6IHZvaWQgMDtcblx0XHR9XG5cdH07XG59XG5jb25zdCBqc29uQ29udGVudFR5cGVIYW5kbGVyID0ge1xuXHRpc01hdGNoKHJlcSkge1xuXHRcdHZhciBfcmVxJGhlYWRlcnMkZ2V0O1xuXHRcdHJldHVybiAhISgoX3JlcSRoZWFkZXJzJGdldCA9IHJlcS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgPT09IG51bGwgfHwgX3JlcSRoZWFkZXJzJGdldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JlcSRoZWFkZXJzJGdldC5zdGFydHNXaXRoKFwiYXBwbGljYXRpb24vanNvblwiKSk7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHR2YXIgX3R5cGVzJHZhbHVlcyRuZXh0JHZhO1xuXHRcdGNvbnN0IHsgcmVxIH0gPSBvcHRzO1xuXHRcdGNvbnN0IGlzQmF0Y2hDYWxsID0gb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiYmF0Y2hcIikgPT09IFwiMVwiO1xuXHRcdGNvbnN0IHBhdGhzID0gaXNCYXRjaENhbGwgPyBvcHRzLnBhdGguc3BsaXQoXCIsXCIpIDogW29wdHMucGF0aF07XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRsZXQgaW5wdXRzID0gdm9pZCAwO1xuXHRcdFx0aWYgKHJlcS5tZXRob2QgPT09IFwiR0VUXCIpIHtcblx0XHRcdFx0Y29uc3QgcXVlcnlJbnB1dCA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldChcImlucHV0XCIpO1xuXHRcdFx0XHRpZiAocXVlcnlJbnB1dCkgaW5wdXRzID0gSlNPTi5wYXJzZShxdWVyeUlucHV0KTtcblx0XHRcdH0gZWxzZSBpbnB1dHMgPSBhd2FpdCByZXEuanNvbigpO1xuXHRcdFx0aWYgKGlucHV0cyA9PT0gdm9pZCAwKSByZXR1cm4ge307XG5cdFx0XHRpZiAoIWlzQmF0Y2hDYWxsKSByZXR1cm4geyAwOiBvcHRzLnJvdXRlci5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIuaW5wdXQuZGVzZXJpYWxpemUoaW5wdXRzKSB9O1xuXHRcdFx0aWYgKCFpc09iamVjdChpbnB1dHMpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcIlxcXCJpbnB1dFxcXCIgbmVlZHMgdG8gYmUgYW4gb2JqZWN0IHdoZW4gZG9pbmcgYSBiYXRjaCBjYWxsXCJcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3QgYWNjID0ge307XG5cdFx0XHRmb3IgKGNvbnN0IGluZGV4IG9mIHBhdGhzLmtleXMoKSkge1xuXHRcdFx0XHRjb25zdCBpbnB1dCA9IGlucHV0c1tpbmRleF07XG5cdFx0XHRcdGlmIChpbnB1dCAhPT0gdm9pZCAwKSBhY2NbaW5kZXhdID0gb3B0cy5yb3V0ZXIuX2RlZi5fY29uZmlnLnRyYW5zZm9ybWVyLmlucHV0LmRlc2VyaWFsaXplKGlucHV0KTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhY2M7XG5cdFx0fSk7XG5cdFx0Y29uc3QgY2FsbHMgPSBhd2FpdCBQcm9taXNlLmFsbChwYXRocy5tYXAoYXN5bmMgKHBhdGgsIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBwcm9jZWR1cmUgPSBhd2FpdCBnZXRQcm9jZWR1cmVBdFBhdGgob3B0cy5yb3V0ZXIsIHBhdGgpO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cGF0aCxcblx0XHRcdFx0cHJvY2VkdXJlLFxuXHRcdFx0XHRnZXRSYXdJbnB1dDogYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IGlucHV0cyA9IGF3YWl0IGdldElucHV0cy5yZWFkKCk7XG5cdFx0XHRcdFx0bGV0IGlucHV0ID0gaW5wdXRzW2luZGV4XTtcblx0XHRcdFx0XHRpZiAoKHByb2NlZHVyZSA9PT0gbnVsbCB8fCBwcm9jZWR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2NlZHVyZS5fZGVmLnR5cGUpID09PSBcInN1YnNjcmlwdGlvblwiKSB7XG5cdFx0XHRcdFx0XHR2YXIgX3JlZiwgX29wdHMkaGVhZGVycyRnZXQ7XG5cdFx0XHRcdFx0XHRjb25zdCBsYXN0RXZlbnRJZCA9IChfcmVmID0gKF9vcHRzJGhlYWRlcnMkZ2V0ID0gb3B0cy5oZWFkZXJzLmdldChcImxhc3QtZXZlbnQtaWRcIikpICE9PSBudWxsICYmIF9vcHRzJGhlYWRlcnMkZ2V0ICE9PSB2b2lkIDAgPyBfb3B0cyRoZWFkZXJzJGdldCA6IG9wdHMuc2VhcmNoUGFyYW1zLmdldChcImxhc3RFdmVudElkXCIpKSAhPT0gbnVsbCAmJiBfcmVmICE9PSB2b2lkIDAgPyBfcmVmIDogb3B0cy5zZWFyY2hQYXJhbXMuZ2V0KFwiTGFzdC1FdmVudC1JZFwiKTtcblx0XHRcdFx0XHRcdGlmIChsYXN0RXZlbnRJZCkgaWYgKGlzT2JqZWN0KGlucHV0KSkgaW5wdXQgPSAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSh7fSwgaW5wdXQpLCB7fSwgeyBsYXN0RXZlbnRJZCB9KTtcblx0XHRcdFx0XHRcdGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR2YXIgX2lucHV0O1xuXHRcdFx0XHRcdFx0XHQoX2lucHV0ID0gaW5wdXQpICE9PSBudWxsICYmIF9pbnB1dCAhPT0gdm9pZCAwIHx8IChpbnB1dCA9IHsgbGFzdEV2ZW50SWQgfSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbnB1dDtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzdWx0OiAoKSA9PiB7XG5cdFx0XHRcdFx0dmFyIF9nZXRJbnB1dHMkcmVzdWx0O1xuXHRcdFx0XHRcdHJldHVybiAoX2dldElucHV0cyRyZXN1bHQgPSBnZXRJbnB1dHMucmVzdWx0KCkpID09PSBudWxsIHx8IF9nZXRJbnB1dHMkcmVzdWx0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZ2V0SW5wdXRzJHJlc3VsdFtpbmRleF07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSkpO1xuXHRcdGNvbnN0IHR5cGVzID0gbmV3IFNldChjYWxscy5tYXAoKGNhbGwpID0+IHtcblx0XHRcdHZhciBfY2FsbCRwcm9jZWR1cmU7XG5cdFx0XHRyZXR1cm4gKF9jYWxsJHByb2NlZHVyZSA9IGNhbGwucHJvY2VkdXJlKSA9PT0gbnVsbCB8fCBfY2FsbCRwcm9jZWR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsJHByb2NlZHVyZS5fZGVmLnR5cGU7XG5cdFx0fSkuZmlsdGVyKEJvb2xlYW4pKTtcblx0XHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLS0gQHByZXNlcnZlICovXG5cdFx0aWYgKHR5cGVzLnNpemUgPiAxKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcblx0XHRcdG1lc3NhZ2U6IGBDYW5ub3QgbWl4IHByb2NlZHVyZSB0eXBlcyBpbiBjYWxsOiAke0FycmF5LmZyb20odHlwZXMpLmpvaW4oXCIsIFwiKX1gXG5cdFx0fSk7XG5cdFx0Y29uc3QgdHlwZSA9IChfdHlwZXMkdmFsdWVzJG5leHQkdmEgPSB0eXBlcy52YWx1ZXMoKS5uZXh0KCkudmFsdWUpICE9PSBudWxsICYmIF90eXBlcyR2YWx1ZXMkbmV4dCR2YSAhPT0gdm9pZCAwID8gX3R5cGVzJHZhbHVlcyRuZXh0JHZhIDogXCJ1bmtub3duXCI7XG5cdFx0Y29uc3QgY29ubmVjdGlvblBhcmFtc1N0ciA9IG9wdHMuc2VhcmNoUGFyYW1zLmdldChcImNvbm5lY3Rpb25QYXJhbXNcIik7XG5cdFx0Y29uc3QgaW5mbyA9IHtcblx0XHRcdGlzQmF0Y2hDYWxsLFxuXHRcdFx0YWNjZXB0OiByZXEuaGVhZGVycy5nZXQoXCJ0cnBjLWFjY2VwdFwiKSxcblx0XHRcdGNhbGxzLFxuXHRcdFx0dHlwZSxcblx0XHRcdGNvbm5lY3Rpb25QYXJhbXM6IGNvbm5lY3Rpb25QYXJhbXNTdHIgPT09IG51bGwgPyBudWxsIDogcGFyc2VDb25uZWN0aW9uUGFyYW1zRnJvbVN0cmluZyhjb25uZWN0aW9uUGFyYW1zU3RyKSxcblx0XHRcdHNpZ25hbDogcmVxLnNpZ25hbCxcblx0XHRcdHVybDogb3B0cy51cmxcblx0XHR9O1xuXHRcdHJldHVybiBpbmZvO1xuXHR9XG59O1xuY29uc3QgZm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXIgPSB7XG5cdGlzTWF0Y2gocmVxKSB7XG5cdFx0dmFyIF9yZXEkaGVhZGVycyRnZXQyO1xuXHRcdHJldHVybiAhISgoX3JlcSRoZWFkZXJzJGdldDIgPSByZXEuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpID09PSBudWxsIHx8IF9yZXEkaGVhZGVycyRnZXQyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcmVxJGhlYWRlcnMkZ2V0Mi5zdGFydHNXaXRoKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSk7XG5cdH0sXG5cdGFzeW5jIHBhcnNlKG9wdHMpIHtcblx0XHRjb25zdCB7IHJlcSB9ID0gb3B0cztcblx0XHRpZiAocmVxLm1ldGhvZCAhPT0gXCJQT1NUXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0bWVzc2FnZTogXCJPbmx5IFBPU1QgcmVxdWVzdHMgYXJlIHN1cHBvcnRlZCBmb3IgbXVsdGlwYXJ0L2Zvcm0tZGF0YSByZXF1ZXN0c1wiXG5cdFx0fSk7XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRjb25zdCBmZCA9IGF3YWl0IHJlcS5mb3JtRGF0YSgpO1xuXHRcdFx0cmV0dXJuIGZkO1xuXHRcdH0pO1xuXHRcdGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgb3B0cy5wYXRoKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBudWxsLFxuXHRcdFx0Y2FsbHM6IFt7XG5cdFx0XHRcdHBhdGg6IG9wdHMucGF0aCxcblx0XHRcdFx0Z2V0UmF3SW5wdXQ6IGdldElucHV0cy5yZWFkLFxuXHRcdFx0XHRyZXN1bHQ6IGdldElucHV0cy5yZXN1bHQsXG5cdFx0XHRcdHByb2NlZHVyZVxuXHRcdFx0fV0sXG5cdFx0XHRpc0JhdGNoQ2FsbDogZmFsc2UsXG5cdFx0XHR0eXBlOiBcIm11dGF0aW9uXCIsXG5cdFx0XHRjb25uZWN0aW9uUGFyYW1zOiBudWxsLFxuXHRcdFx0c2lnbmFsOiByZXEuc2lnbmFsLFxuXHRcdFx0dXJsOiBvcHRzLnVybFxuXHRcdH07XG5cdH1cbn07XG5jb25zdCBvY3RldFN0cmVhbUNvbnRlbnRUeXBlSGFuZGxlciA9IHtcblx0aXNNYXRjaChyZXEpIHtcblx0XHR2YXIgX3JlcSRoZWFkZXJzJGdldDM7XG5cdFx0cmV0dXJuICEhKChfcmVxJGhlYWRlcnMkZ2V0MyA9IHJlcS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSkgPT09IG51bGwgfHwgX3JlcSRoZWFkZXJzJGdldDMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yZXEkaGVhZGVycyRnZXQzLnN0YXJ0c1dpdGgoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIikpO1xuXHR9LFxuXHRhc3luYyBwYXJzZShvcHRzKSB7XG5cdFx0Y29uc3QgeyByZXEgfSA9IG9wdHM7XG5cdFx0aWYgKHJlcS5tZXRob2QgIT09IFwiUE9TVFwiKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdGNvZGU6IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIixcblx0XHRcdG1lc3NhZ2U6IFwiT25seSBQT1NUIHJlcXVlc3RzIGFyZSBzdXBwb3J0ZWQgZm9yIGFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSByZXF1ZXN0c1wiXG5cdFx0fSk7XG5cdFx0Y29uc3QgZ2V0SW5wdXRzID0gbWVtbyhhc3luYyAoKSA9PiB7XG5cdFx0XHRyZXR1cm4gcmVxLmJvZHk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNhbGxzOiBbe1xuXHRcdFx0XHRwYXRoOiBvcHRzLnBhdGgsXG5cdFx0XHRcdGdldFJhd0lucHV0OiBnZXRJbnB1dHMucmVhZCxcblx0XHRcdFx0cmVzdWx0OiBnZXRJbnB1dHMucmVzdWx0LFxuXHRcdFx0XHRwcm9jZWR1cmU6IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgb3B0cy5wYXRoKVxuXHRcdFx0fV0sXG5cdFx0XHRpc0JhdGNoQ2FsbDogZmFsc2UsXG5cdFx0XHRhY2NlcHQ6IG51bGwsXG5cdFx0XHR0eXBlOiBcIm11dGF0aW9uXCIsXG5cdFx0XHRjb25uZWN0aW9uUGFyYW1zOiBudWxsLFxuXHRcdFx0c2lnbmFsOiByZXEuc2lnbmFsLFxuXHRcdFx0dXJsOiBvcHRzLnVybFxuXHRcdH07XG5cdH1cbn07XG5jb25zdCBoYW5kbGVycyA9IFtcblx0anNvbkNvbnRlbnRUeXBlSGFuZGxlcixcblx0Zm9ybURhdGFDb250ZW50VHlwZUhhbmRsZXIsXG5cdG9jdGV0U3RyZWFtQ29udGVudFR5cGVIYW5kbGVyXG5dO1xuZnVuY3Rpb24gZ2V0Q29udGVudFR5cGVIYW5kbGVyKHJlcSkge1xuXHRjb25zdCBoYW5kbGVyID0gaGFuZGxlcnMuZmluZCgoaGFuZGxlciQxKSA9PiBoYW5kbGVyJDEuaXNNYXRjaChyZXEpKTtcblx0aWYgKGhhbmRsZXIpIHJldHVybiBoYW5kbGVyO1xuXHRpZiAoIWhhbmRsZXIgJiYgcmVxLm1ldGhvZCA9PT0gXCJHRVRcIikgcmV0dXJuIGpzb25Db250ZW50VHlwZUhhbmRsZXI7XG5cdHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiLFxuXHRcdG1lc3NhZ2U6IHJlcS5oZWFkZXJzLmhhcyhcImNvbnRlbnQtdHlwZVwiKSA/IGBVbnN1cHBvcnRlZCBjb250ZW50LXR5cGUgXCIke3JlcS5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKX1gIDogXCJNaXNzaW5nIGNvbnRlbnQtdHlwZSBoZWFkZXJcIlxuXHR9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFJlcXVlc3RJbmZvKG9wdHMpIHtcblx0Y29uc3QgaGFuZGxlciA9IGdldENvbnRlbnRUeXBlSGFuZGxlcihvcHRzLnJlcSk7XG5cdHJldHVybiBhd2FpdCBoYW5kbGVyLnBhcnNlKG9wdHMpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L2h0dHAvYWJvcnRFcnJvci50c1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG5cdHJldHVybiBpc09iamVjdChlcnJvcikgJiYgZXJyb3JbXCJuYW1lXCJdID09PSBcIkFib3J0RXJyb3JcIjtcbn1cbmZ1bmN0aW9uIHRocm93QWJvcnRFcnJvcihtZXNzYWdlID0gXCJBYm9ydEVycm9yXCIpIHtcblx0dGhyb3cgbmV3IERPTUV4Y2VwdGlvbihtZXNzYWdlLCBcIkFib3J0RXJyb3JcIik7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy92ZW5kb3IvaXMtcGxhaW4tb2JqZWN0LnRzXG4vKiFcbiogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4qXG4qIENvcHlyaWdodCAoYykgMjAxNC0yMDE3LCBKb24gU2NobGlua2VydC5cbiogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cbmZ1bmN0aW9uIGlzT2JqZWN0JDEobykge1xuXHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG5cdHZhciBjdG9yLCBwcm90O1xuXHRpZiAoaXNPYmplY3QkMShvKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0Y3RvciA9IG8uY29uc3RydWN0b3I7XG5cdGlmIChjdG9yID09PSB2b2lkIDApIHJldHVybiB0cnVlO1xuXHRwcm90ID0gY3Rvci5wcm90b3R5cGU7XG5cdGlmIChpc09iamVjdCQxKHByb3QpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eShcImlzUHJvdG90eXBlT2ZcIikgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiB0cnVlO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdmVuZG9yL3VucHJvbWlzZS91bnByb21pc2UudHNcbnZhciBpbXBvcnRfZGVmaW5lUHJvcGVydHkgPSBfX3RvRVNNKHJlcXVpcmVfZGVmaW5lUHJvcGVydHkoKSwgMSk7XG5sZXQgX1N5bWJvbCR0b1N0cmluZ1RhZztcbi8qKiBNZW1vcnkgc2FmZSAod2Vha21hcHBlZCkgY2FjaGUgb2YgdGhlIFByb3h5UHJvbWlzZSBmb3IgZWFjaCBQcm9taXNlLFxuKiB3aGljaCBpcyByZXRhaW5lZCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBvcmlnaW5hbCBQcm9taXNlLlxuKi9cbmNvbnN0IHN1YnNjcmliYWJsZUNhY2hlID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrTWFwKCk7XG4vKiogQSBOT09QIGZ1bmN0aW9uIGFsbG93aW5nIGEgY29uc2lzdGVudCBpbnRlcmZhY2UgZm9yIHNldHRsZWRcbiogU3Vic2NyaWJlZFByb21pc2VzIChzZXR0bGVkIHByb21pc2VzIGFyZSBub3Qgc3Vic2NyaWJlZCAtIHRoZXkgcmVzb2x2ZVxuKiBpbW1lZGlhdGVseSkuICovXG5jb25zdCBOT09QID0gKCkgPT4ge307XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuLyoqXG4qIEV2ZXJ5IGBQcm9taXNlPFQ+YCBjYW4gYmUgc2hhZG93ZWQgYnkgYSBzaW5nbGUgYFByb3h5UHJvbWlzZTxUPmAuIEl0IGlzXG4qIGNyZWF0ZWQgb25jZSwgY2FjaGVkIGFuZCByZXVzZWQgdGhyb3VnaG91dCB0aGUgbGlmZXRpbWUgb2YgdGhlIFByb21pc2UuIEdldCBhXG4qIFByb21pc2UncyBQcm94eVByb21pc2UgdXNpbmcgYFVucHJvbWlzZS5wcm94eShwcm9taXNlKWAuXG4qXG4qIFRoZSBgUHJveHlQcm9taXNlPFQ+YCBhdHRhY2hlcyBoYW5kbGVycyB0byB0aGUgb3JpZ2luYWwgYFByb21pc2U8VD5gXG4qIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBqdXN0IG9uY2UuIFByb21pc2VzIGRlcml2ZWQgZnJvbSBpdCB1c2UgYVxuKiBzdWJzY3JpcHRpb24tIChhbmQgdW5zdWJzY3JpcHRpb24tKSBiYXNlZCBtZWNoYW5pc20gdGhhdCBtb25pdG9ycyB0aGVzZVxuKiBoYW5kbGVycy5cbipcbiogRXZlcnkgdGltZSB5b3UgY2FsbCBgLnN1YnNjcmliZSgpYCwgYC50aGVuKClgIGAuY2F0Y2goKWAgb3IgYC5maW5hbGx5KClgIG9uIGFcbiogYFByb3h5UHJvbWlzZTxUPmAgaXQgcmV0dXJucyBhIGBTdWJzY3JpYmVkUHJvbWlzZTxUPmAgaGF2aW5nIGFuIGFkZGl0aW9uYWxcbiogYHVuc3Vic2NyaWJlKClgIG1ldGhvZC4gQ2FsbGluZyBgdW5zdWJzY3JpYmUoKWAgZGV0YWNoZXMgcmVmZXJlbmNlIGNoYWluc1xuKiBmcm9tIHRoZSBvcmlnaW5hbCwgcG90ZW50aWFsbHkgbG9uZy1saXZlZCBQcm9taXNlLCBlbGltaW5hdGluZyBtZW1vcnkgbGVha3MuXG4qXG4qIFRoaXMgYXBwcm9hY2ggY2FuIGVsaW1pbmF0ZSB0aGUgbWVtb3J5IGxlYWtzIHRoYXQgb3RoZXJ3aXNlIGNvbWUgYWJvdXQgZnJvbVxuKiByZXBlYXRlZCBgcmFjZSgpYCBvciBgYW55KClgIGNhbGxzIGludm9raW5nIGAudGhlbigpYCBhbmQgYC5jYXRjaCgpYCBtdWx0aXBsZVxuKiB0aW1lcyBvbiB0aGUgc2FtZSBsb25nLWxpdmVkIG5hdGl2ZSBQcm9taXNlIChzdWJzY3JpcHRpb25zIHdoaWNoIGNhbiBuZXZlciBiZVxuKiBjbGVhbmVkIHVwKS5cbipcbiogYFVucHJvbWlzZS5yYWNlKHByb21pc2VzKWAgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgYFByb21pc2UucmFjZWBcbiogYXZvaWRpbmcgbWVtb3J5IGxlYWtzIHdoZW4gdXNpbmcgbG9uZy1saXZlZCB1bnNldHRsZWQgUHJvbWlzZXMuXG4qXG4qIGBVbnByb21pc2UuYW55KHByb21pc2VzKWAgaXMgYSByZWZlcmVuY2UgaW1wbGVtZW50YXRpb24gb2YgYFByb21pc2UuYW55YFxuKiBhdm9pZGluZyBtZW1vcnkgbGVha3Mgd2hlbiB1c2luZyBsb25nLWxpdmVkIHVuc2V0dGxlZCBQcm9taXNlcy5cbipcbiogYFVucHJvbWlzZS5yZXNvbHZlKHByb21pc2UpYCByZXR1cm5zIGFuIGVwaGVtZXJhbCBgU3Vic2NyaWJlZFByb21pc2U8VD5gIGZvclxuKiBhbnkgZ2l2ZW4gYFByb21pc2U8VD5gIGZhY2lsaXRhdGluZyBhcmJpdHJhcnkgYXN5bmMvYXdhaXQgcGF0dGVybnMuIEJlaGluZFxuKiB0aGUgc2NlbmVzLCBgcmVzb2x2ZWAgaXMgaW1wbGVtZW50ZWQgc2ltcGx5IGFzXG4qIGBVbnByb21pc2UucHJveHkocHJvbWlzZSkuc3Vic2NyaWJlKClgLiBEb24ndCBmb3JnZXQgdG8gY2FsbCBgLnVuc3Vic2NyaWJlKClgXG4qIHRvIHRpZHkgdXAhXG4qXG4qL1xudmFyIFVucHJvbWlzZSA9IGNsYXNzIFVucHJvbWlzZSB7XG5cdGNvbnN0cnVjdG9yKGFyZykge1xuXHRcdCgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgXCJwcm9taXNlXCIsIHZvaWQgMCk7XG5cdFx0KDAsIGltcG9ydF9kZWZpbmVQcm9wZXJ0eS5kZWZhdWx0KSh0aGlzLCBcInN1YnNjcmliZXJzXCIsIFtdKTtcblx0XHQoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5LmRlZmF1bHQpKHRoaXMsIFwic2V0dGxlbWVudFwiLCBudWxsKTtcblx0XHQoMCwgaW1wb3J0X2RlZmluZVByb3BlcnR5LmRlZmF1bHQpKHRoaXMsIF9TeW1ib2wkdG9TdHJpbmdUYWcsIFwiVW5wcm9taXNlXCIpO1xuXHRcdGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIpIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGFyZyk7XG5cdFx0ZWxzZSB0aGlzLnByb21pc2UgPSBhcmc7XG5cdFx0Y29uc3QgdGhlblJldHVybiA9IHRoaXMucHJvbWlzZS50aGVuKCh2YWx1ZSkgPT4ge1xuXHRcdFx0Y29uc3QgeyBzdWJzY3JpYmVycyB9ID0gdGhpcztcblx0XHRcdHRoaXMuc3Vic2NyaWJlcnMgPSBudWxsO1xuXHRcdFx0dGhpcy5zZXR0bGVtZW50ID0ge1xuXHRcdFx0XHRzdGF0dXM6IFwiZnVsZmlsbGVkXCIsXG5cdFx0XHRcdHZhbHVlXG5cdFx0XHR9O1xuXHRcdFx0c3Vic2NyaWJlcnMgPT09IG51bGwgfHwgc3Vic2NyaWJlcnMgPT09IHZvaWQgMCB8fCBzdWJzY3JpYmVycy5mb3JFYWNoKCh7IHJlc29sdmUgfSkgPT4ge1xuXHRcdFx0XHRyZXNvbHZlKHZhbHVlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdGlmIChcImNhdGNoXCIgaW4gdGhlblJldHVybikgdGhlblJldHVybi5jYXRjaCgocmVhc29uKSA9PiB7XG5cdFx0XHRjb25zdCB7IHN1YnNjcmliZXJzIH0gPSB0aGlzO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IG51bGw7XG5cdFx0XHR0aGlzLnNldHRsZW1lbnQgPSB7XG5cdFx0XHRcdHN0YXR1czogXCJyZWplY3RlZFwiLFxuXHRcdFx0XHRyZWFzb25cblx0XHRcdH07XG5cdFx0XHRzdWJzY3JpYmVycyA9PT0gbnVsbCB8fCBzdWJzY3JpYmVycyA9PT0gdm9pZCAwIHx8IHN1YnNjcmliZXJzLmZvckVhY2goKHsgcmVqZWN0IH0pID0+IHtcblx0XHRcdFx0cmVqZWN0KHJlYXNvbik7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fVxuXHQvKiogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IG1pdGlnYXRlcyB1bmNvbnRyb2xsZWQgc3Vic2NyaXB0aW9uIHRvIGEgbG9uZy1saXZlZFxuXHQqIFByb21pc2UgdmlhIC50aGVuKCkgYW5kIC5jYXRjaCgpIC0gb3RoZXJ3aXNlIGEgc291cmNlIG9mIG1lbW9yeSBsZWFrcy5cblx0KlxuXHQqIFRoZSByZXR1cm5lZCBwcm9taXNlIGhhcyBhbiBgdW5zdWJzY3JpYmUoKWAgbWV0aG9kIHdoaWNoIGNhbiBiZSBjYWxsZWQgd2hlblxuXHQqIHRoZSBQcm9taXNlIGlzIG5vIGxvbmdlciBiZWluZyB0cmFja2VkIGJ5IGFwcGxpY2F0aW9uIGxvZ2ljLCBhbmQgd2hpY2hcblx0KiBlbnN1cmVzIHRoYXQgdGhlcmUgaXMgbm8gcmVmZXJlbmNlIGNoYWluIGZyb20gdGhlIG9yaWdpbmFsIHByb21pc2UgdG8gdGhlXG5cdCogbmV3IG9uZSwgYW5kIHRoZXJlZm9yZSBubyBtZW1vcnkgbGVhay5cblx0KlxuXHQqIElmIG9yaWdpbmFsIHByb21pc2UgaGFzIG5vdCB5ZXQgc2V0dGxlZCwgdGhpcyBhZGRzIGEgbmV3IHVuaXF1ZSBwcm9taXNlXG5cdCogdGhhdCBsaXN0ZW5zIHRvIHRoZW4vY2F0Y2ggZXZlbnRzLCBhbG9uZyB3aXRoIGFuIGB1bnN1YnNjcmliZSgpYCBtZXRob2QgdG9cblx0KiBkZXRhY2ggaXQuXG5cdCpcblx0KiBJZiBvcmlnaW5hbCBwcm9taXNlIGhhcyBzZXR0bGVkLCB0aGVuIGNyZWF0ZXMgYSBuZXcgUHJvbWlzZS5yZXNvbHZlKCkgb3Jcblx0KiBQcm9taXNlLnJlamVjdCgpIGFuZCBwcm92aWRlZCB1bnN1YnNjcmliZSBpcyBhIG5vb3AuXG5cdCpcblx0KiBJZiB5b3UgY2FsbCBgdW5zdWJzY3JpYmUoKWAgYmVmb3JlIHRoZSByZXR1cm5lZCBQcm9taXNlIGhhcyBzZXR0bGVkLCBpdFxuXHQqIHdpbGwgbmV2ZXIgc2V0dGxlLlxuXHQqL1xuXHRzdWJzY3JpYmUoKSB7XG5cdFx0bGV0IHByb21pc2U7XG5cdFx0bGV0IHVuc3Vic2NyaWJlO1xuXHRcdGNvbnN0IHsgc2V0dGxlbWVudCB9ID0gdGhpcztcblx0XHRpZiAoc2V0dGxlbWVudCA9PT0gbnVsbCkge1xuXHRcdFx0aWYgKHRoaXMuc3Vic2NyaWJlcnMgPT09IG51bGwpIHRocm93IG5ldyBFcnJvcihcIlVucHJvbWlzZSBzZXR0bGVkIGJ1dCBzdGlsbCBoYXMgc3Vic2NyaWJlcnNcIik7XG5cdFx0XHRjb25zdCBzdWJzY3JpYmVyID0gd2l0aFJlc29sdmVycygpO1xuXHRcdFx0dGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRoTWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuXHRcdFx0cHJvbWlzZSA9IHN1YnNjcmliZXIucHJvbWlzZTtcblx0XHRcdHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuXHRcdFx0XHRpZiAodGhpcy5zdWJzY3JpYmVycyAhPT0gbnVsbCkgdGhpcy5zdWJzY3JpYmVycyA9IGxpc3RXaXRob3V0TWVtYmVyKHRoaXMuc3Vic2NyaWJlcnMsIHN1YnNjcmliZXIpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgeyBzdGF0dXMgfSA9IHNldHRsZW1lbnQ7XG5cdFx0XHRpZiAoc3RhdHVzID09PSBcImZ1bGZpbGxlZFwiKSBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHNldHRsZW1lbnQudmFsdWUpO1xuXHRcdFx0ZWxzZSBwcm9taXNlID0gUHJvbWlzZS5yZWplY3Qoc2V0dGxlbWVudC5yZWFzb24pO1xuXHRcdFx0dW5zdWJzY3JpYmUgPSBOT09QO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9taXNlLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdC8qKiBTVEFOREFSRCBQUk9NSVNFIE1FVEhPRFMgKGJ1dCByZXR1cm5pbmcgYSBTdWJzY3JpYmVkUHJvbWlzZSkgKi9cblx0dGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCkge1xuXHRcdGNvbnN0IHN1YnNjcmliZWQgPSB0aGlzLnN1YnNjcmliZSgpO1xuXHRcdGNvbnN0IHsgdW5zdWJzY3JpYmUgfSA9IHN1YnNjcmliZWQ7XG5cdFx0cmV0dXJuIE9iamVjdC5hc3NpZ24oc3Vic2NyaWJlZC50aGVuKG9uZnVsZmlsbGVkLCBvbnJlamVjdGVkKSwgeyB1bnN1YnNjcmliZSB9KTtcblx0fVxuXHRjYXRjaChvbnJlamVjdGVkKSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLmNhdGNoKG9ucmVqZWN0ZWQpLCB7IHVuc3Vic2NyaWJlIH0pO1xuXHR9XG5cdGZpbmFsbHkob25maW5hbGx5KSB7XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZCA9IHRoaXMuc3Vic2NyaWJlKCk7XG5cdFx0Y29uc3QgeyB1bnN1YnNjcmliZSB9ID0gc3Vic2NyaWJlZDtcblx0XHRyZXR1cm4gT2JqZWN0LmFzc2lnbihzdWJzY3JpYmVkLmZpbmFsbHkob25maW5hbGx5KSwgeyB1bnN1YnNjcmliZSB9KTtcblx0fVxuXHQvKiogVW5wcm9taXNlIFNUQVRJQyBNRVRIT0RTICovXG5cdC8qKiBDcmVhdGUgb3IgUmV0cmlldmUgdGhlIHByb3h5IFVucHJvbWlzZSAoYSByZS11c2VkIFVucHJvbWlzZSBmb3IgdGhlIFZNIGxpZmV0aW1lXG5cdCogb2YgdGhlIHByb3ZpZGVkIFByb21pc2UgcmVmZXJlbmNlKSAqL1xuXHRzdGF0aWMgcHJveHkocHJvbWlzZSkge1xuXHRcdGNvbnN0IGNhY2hlZCA9IFVucHJvbWlzZS5nZXRTdWJzY3JpYmFibGVQcm9taXNlKHByb21pc2UpO1xuXHRcdHJldHVybiB0eXBlb2YgY2FjaGVkICE9PSBcInVuZGVmaW5lZFwiID8gY2FjaGVkIDogVW5wcm9taXNlLmNyZWF0ZVN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSk7XG5cdH1cblx0LyoqIENyZWF0ZSBhbmQgc3RvcmUgYW4gVW5wcm9taXNlIGtleWVkIGJ5IGFuIG9yaWdpbmFsIFByb21pc2UuICovXG5cdHN0YXRpYyBjcmVhdGVTdWJzY3JpYmFibGVQcm9taXNlKHByb21pc2UpIHtcblx0XHRjb25zdCBjcmVhdGVkID0gbmV3IFVucHJvbWlzZShwcm9taXNlKTtcblx0XHRzdWJzY3JpYmFibGVDYWNoZS5zZXQocHJvbWlzZSwgY3JlYXRlZCk7XG5cdFx0c3Vic2NyaWJhYmxlQ2FjaGUuc2V0KGNyZWF0ZWQsIGNyZWF0ZWQpO1xuXHRcdHJldHVybiBjcmVhdGVkO1xuXHR9XG5cdC8qKiBSZXRyaWV2ZSBhIHByZXZpb3VzbHktY3JlYXRlZCBVbnByb21pc2Uga2V5ZWQgYnkgYW4gb3JpZ2luYWwgUHJvbWlzZS4gKi9cblx0c3RhdGljIGdldFN1YnNjcmliYWJsZVByb21pc2UocHJvbWlzZSkge1xuXHRcdHJldHVybiBzdWJzY3JpYmFibGVDYWNoZS5nZXQocHJvbWlzZSk7XG5cdH1cblx0LyoqIFByb21pc2UgU1RBVElDIE1FVEhPRFMgKi9cblx0LyoqIExvb2t1cCB0aGUgVW5wcm9taXNlIGZvciB0aGlzIHByb21pc2UsIGFuZCBkZXJpdmUgYSBTdWJzY3JpYmVkUHJvbWlzZSBmcm9tXG5cdCogaXQgKHRoYXQgY2FuIGJlIGxhdGVyIHVuc3Vic2NyaWJlZCB0byBlbGltaW5hdGUgTWVtb3J5IGxlYWtzKSAqL1xuXHRzdGF0aWMgcmVzb2x2ZSh2YWx1ZSkge1xuXHRcdGNvbnN0IHByb21pc2UgPSB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgXCJ0aGVuXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIiA/IHZhbHVlIDogUHJvbWlzZS5yZXNvbHZlKHZhbHVlKTtcblx0XHRyZXR1cm4gVW5wcm9taXNlLnByb3h5KHByb21pc2UpLnN1YnNjcmliZSgpO1xuXHR9XG5cdHN0YXRpYyBhc3luYyBhbnkodmFsdWVzKSB7XG5cdFx0Y29uc3QgdmFsdWVzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyB2YWx1ZXMgOiBbLi4udmFsdWVzXTtcblx0XHRjb25zdCBzdWJzY3JpYmVkUHJvbWlzZXMgPSB2YWx1ZXNBcnJheS5tYXAoVW5wcm9taXNlLnJlc29sdmUpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5hbnkoc3Vic2NyaWJlZFByb21pc2VzKTtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0c3Vic2NyaWJlZFByb21pc2VzLmZvckVhY2goKHsgdW5zdWJzY3JpYmUgfSkgPT4ge1xuXHRcdFx0XHR1bnN1YnNjcmliZSgpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cdHN0YXRpYyBhc3luYyByYWNlKHZhbHVlcykge1xuXHRcdGNvbnN0IHZhbHVlc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gdmFsdWVzIDogWy4uLnZhbHVlc107XG5cdFx0Y29uc3Qgc3Vic2NyaWJlZFByb21pc2VzID0gdmFsdWVzQXJyYXkubWFwKFVucHJvbWlzZS5yZXNvbHZlKTtcblx0XHR0cnkge1xuXHRcdFx0cmV0dXJuIGF3YWl0IFByb21pc2UucmFjZShzdWJzY3JpYmVkUHJvbWlzZXMpO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHRzdWJzY3JpYmVkUHJvbWlzZXMuZm9yRWFjaCgoeyB1bnN1YnNjcmliZSB9KSA9PiB7XG5cdFx0XHRcdHVuc3Vic2NyaWJlKCk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0LyoqIENyZWF0ZSBhIHJhY2Ugb2YgU3Vic2NyaWJlZFByb21pc2VzIHRoYXQgd2lsbCBmdWxmaWwgdG8gYSBzaW5nbGUgd2lubmluZ1xuXHQqIFByb21pc2UgKGluIGEgMS1UdXBsZSkuIEVsaW1pbmF0ZXMgbWVtb3J5IGxlYWtzIGZyb20gbG9uZy1saXZlZCBwcm9taXNlc1xuXHQqIGFjY3VtdWxhdGluZyAudGhlbigpIGFuZCAuY2F0Y2goKSBzdWJzY3JpYmVycy4gQWxsb3dzIHNpbXBsZSBsb2dpYyB0b1xuXHQqIGNvbnN1bWUgdGhlIHJlc3VsdCwgbGlrZS4uLlxuXHQqIGBgYHRzXG5cdCogY29uc3QgWyB3aW5uZXIgXSA9IGF3YWl0IFVucHJvbWlzZS5yYWNlKFsgcHJvbWlzZUEsIHByb21pc2VCIF0pO1xuXHQqIGlmKHdpbm5lciA9PT0gcHJvbWlzZUIpe1xuXHQqICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZUI7XG5cdCogICAvLyBkbyB0aGUgdGhpbmdcblx0KiB9XG5cdCogYGBgXG5cdCogKi9cblx0c3RhdGljIGFzeW5jIHJhY2VSZWZlcmVuY2VzKHByb21pc2VzKSB7XG5cdFx0Y29uc3Qgc2VsZlByb21pc2VzID0gcHJvbWlzZXMubWFwKHJlc29sdmVTZWxmVHVwbGUpO1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gYXdhaXQgUHJvbWlzZS5yYWNlKHNlbGZQcm9taXNlcyk7XG5cdFx0fSBmaW5hbGx5IHtcblx0XHRcdGZvciAoY29uc3QgcHJvbWlzZSBvZiBzZWxmUHJvbWlzZXMpIHByb21pc2UudW5zdWJzY3JpYmUoKTtcblx0XHR9XG5cdH1cbn07XG4vKiogUHJvbWlzZXMgYSAxLXR1cGxlIGNvbnRhaW5pbmcgdGhlIG9yaWdpbmFsIHByb21pc2Ugd2hlbiBpdCByZXNvbHZlcy4gQWxsb3dzXG4qIGF3YWl0aW5nIHRoZSBldmVudHVhbCBQcm9taXNlICoqKnJlZmVyZW5jZSoqKiAoZWFzeSB0byBkZXN0cnVjdHVyZSBhbmRcbiogZXhhY3RseSBjb21wYXJlIHdpdGggPT09KS4gQXZvaWRzIHJlc29sdmluZyB0byB0aGUgUHJvbWlzZSAqKip2YWx1ZSoqKiAod2hpY2hcbiogbWF5IGJlIGFtYmlndW91cyBhbmQgdGhlcmVmb3JlIGhhcmQgdG8gaWRlbnRpZnkgYXMgdGhlIHdpbm5lciBvZiBhIHJhY2UpLlxuKiBZb3UgY2FuIGNhbGwgdW5zdWJzY3JpYmUgb24gdGhlIFByb21pc2UgdG8gbWl0aWdhdGUgbWVtb3J5IGxlYWtzLlxuKiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNlbGZUdXBsZShwcm9taXNlKSB7XG5cdHJldHVybiBVbnByb21pc2UucHJveHkocHJvbWlzZSkudGhlbigoKSA9PiBbcHJvbWlzZV0pO1xufVxuLyoqIFZFTkRPUkVEIChGdXR1cmUpIFBST01JU0UgVVRJTElUSUVTICovXG4vKiogUmVmZXJlbmNlIGltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXByb21pc2Utd2l0aC1yZXNvbHZlcnMgKi9cbmZ1bmN0aW9uIHdpdGhSZXNvbHZlcnMoKSB7XG5cdGxldCByZXNvbHZlO1xuXHRsZXQgcmVqZWN0O1xuXHRjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG5cdFx0cmVzb2x2ZSA9IF9yZXNvbHZlO1xuXHRcdHJlamVjdCA9IF9yZWplY3Q7XG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHByb21pc2UsXG5cdFx0cmVzb2x2ZSxcblx0XHRyZWplY3Rcblx0fTtcbn1cbi8qKiBJTU1VVEFCTEUgTElTVCBPUEVSQVRJT05TICovXG5mdW5jdGlvbiBsaXN0V2l0aE1lbWJlcihhcnIsIG1lbWJlcikge1xuXHRyZXR1cm4gWy4uLmFyciwgbWVtYmVyXTtcbn1cbmZ1bmN0aW9uIGxpc3RXaXRob3V0SW5kZXgoYXJyLCBpbmRleCkge1xuXHRyZXR1cm4gWy4uLmFyci5zbGljZSgwLCBpbmRleCksIC4uLmFyci5zbGljZShpbmRleCArIDEpXTtcbn1cbmZ1bmN0aW9uIGxpc3RXaXRob3V0TWVtYmVyKGFyciwgbWVtYmVyKSB7XG5cdGNvbnN0IGluZGV4ID0gYXJyLmluZGV4T2YobWVtYmVyKTtcblx0aWYgKGluZGV4ICE9PSAtMSkgcmV0dXJuIGxpc3RXaXRob3V0SW5kZXgoYXJyLCBpbmRleCk7XG5cdHJldHVybiBhcnI7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2Rpc3Bvc2FibGUudHNcbnZhciBfU3ltYm9sLCBfU3ltYm9sJGRpc3Bvc2UsIF9TeW1ib2wyLCBfU3ltYm9sMiRhc3luY0Rpc3Bvc2U7XG4oX1N5bWJvbCRkaXNwb3NlID0gKF9TeW1ib2wgPSBTeW1ib2wpLmRpc3Bvc2UpICE9PSBudWxsICYmIF9TeW1ib2wkZGlzcG9zZSAhPT0gdm9pZCAwIHx8IChfU3ltYm9sLmRpc3Bvc2UgPSBTeW1ib2woKSk7XG4oX1N5bWJvbDIkYXN5bmNEaXNwb3NlID0gKF9TeW1ib2wyID0gU3ltYm9sKS5hc3luY0Rpc3Bvc2UpICE9PSBudWxsICYmIF9TeW1ib2wyJGFzeW5jRGlzcG9zZSAhPT0gdm9pZCAwIHx8IChfU3ltYm9sMi5hc3luY0Rpc3Bvc2UgPSBTeW1ib2woKSk7XG4vKipcbiogVGFrZXMgYSB2YWx1ZSBhbmQgYSBkaXNwb3NlIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9iamVjdCB0aGF0IGltcGxlbWVudHMgdGhlIERpc3Bvc2FibGUgaW50ZXJmYWNlLlxuKiBUaGUgcmV0dXJuZWQgb2JqZWN0IGlzIHRoZSBvcmlnaW5hbCB2YWx1ZSBhdWdtZW50ZWQgd2l0aCBhIFN5bWJvbC5kaXNwb3NlIG1ldGhvZC5cbiogQHBhcmFtIHRoaW5nIFRoZSB2YWx1ZSB0byBtYWtlIGRpc3Bvc2FibGVcbiogQHBhcmFtIGRpc3Bvc2UgRnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRpc3Bvc2luZyB0aGUgcmVzb3VyY2VcbiogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmRpc3Bvc2UgbWV0aG9kIGFkZGVkXG4qL1xuZnVuY3Rpb24gbWFrZVJlc291cmNlKHRoaW5nLCBkaXNwb3NlKSB7XG5cdGNvbnN0IGl0ID0gdGhpbmc7XG5cdGNvbnN0IGV4aXN0aW5nID0gaXRbU3ltYm9sLmRpc3Bvc2VdO1xuXHRpdFtTeW1ib2wuZGlzcG9zZV0gPSAoKSA9PiB7XG5cdFx0ZGlzcG9zZSgpO1xuXHRcdGV4aXN0aW5nID09PSBudWxsIHx8IGV4aXN0aW5nID09PSB2b2lkIDAgfHwgZXhpc3RpbmcoKTtcblx0fTtcblx0cmV0dXJuIGl0O1xufVxuLyoqXG4qIFRha2VzIGEgdmFsdWUgYW5kIGFuIGFzeW5jIGRpc3Bvc2UgZnVuY3Rpb24gYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHRoYXQgaW1wbGVtZW50cyB0aGUgQXN5bmNEaXNwb3NhYmxlIGludGVyZmFjZS5cbiogVGhlIHJldHVybmVkIG9iamVjdCBpcyB0aGUgb3JpZ2luYWwgdmFsdWUgYXVnbWVudGVkIHdpdGggYSBTeW1ib2wuYXN5bmNEaXNwb3NlIG1ldGhvZC5cbiogQHBhcmFtIHRoaW5nIFRoZSB2YWx1ZSB0byBtYWtlIGFzeW5jIGRpc3Bvc2FibGVcbiogQHBhcmFtIGRpc3Bvc2UgQXN5bmMgZnVuY3Rpb24gdG8gY2FsbCB3aGVuIGRpc3Bvc2luZyB0aGUgcmVzb3VyY2VcbiogQHJldHVybnMgVGhlIG9yaWdpbmFsIHZhbHVlIHdpdGggU3ltYm9sLmFzeW5jRGlzcG9zZSBtZXRob2QgYWRkZWRcbiovXG5mdW5jdGlvbiBtYWtlQXN5bmNSZXNvdXJjZSh0aGluZywgZGlzcG9zZSkge1xuXHRjb25zdCBpdCA9IHRoaW5nO1xuXHRjb25zdCBleGlzdGluZyA9IGl0W1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuXHRpdFtTeW1ib2wuYXN5bmNEaXNwb3NlXSA9IGFzeW5jICgpID0+IHtcblx0XHRhd2FpdCBkaXNwb3NlKCk7XG5cdFx0YXdhaXQgKGV4aXN0aW5nID09PSBudWxsIHx8IGV4aXN0aW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBleGlzdGluZygpKTtcblx0fTtcblx0cmV0dXJuIGl0O1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy90aW1lclJlc291cmNlLnRzXG5jb25zdCBkaXNwb3NhYmxlUHJvbWlzZVRpbWVyUmVzdWx0ID0gU3ltYm9sKCk7XG5mdW5jdGlvbiB0aW1lclJlc291cmNlKG1zKSB7XG5cdGxldCB0aW1lciA9IG51bGw7XG5cdHJldHVybiBtYWtlUmVzb3VyY2UoeyBzdGFydCgpIHtcblx0XHRpZiAodGltZXIpIHRocm93IG5ldyBFcnJvcihcIlRpbWVyIGFscmVhZHkgc3RhcnRlZFwiKTtcblx0XHRjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcblx0XHRcdHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpLCBtcyk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHByb21pc2U7XG5cdH0gfSwgKCkgPT4ge1xuXHRcdGlmICh0aW1lcikgY2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0fSk7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3VzaW5nQ3R4LmpzXG52YXIgcmVxdWlyZV91c2luZ0N0eCA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL3VzaW5nQ3R4LmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdGZ1bmN0aW9uIF91c2luZ0N0eCgpIHtcblx0XHR2YXIgciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3VwcHJlc3NlZEVycm9yID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24ociQxLCBlJDEpIHtcblx0XHRcdHZhciBuJDEgPSBFcnJvcigpO1xuXHRcdFx0cmV0dXJuIG4kMS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgbiQxLmVycm9yID0gciQxLCBuJDEuc3VwcHJlc3NlZCA9IGUkMSwgbiQxO1xuXHRcdH0sIGUgPSB7fSwgbiA9IFtdO1xuXHRcdGZ1bmN0aW9uIHVzaW5nKHIkMSwgZSQxKSB7XG5cdFx0XHRpZiAobnVsbCAhPSBlJDEpIHtcblx0XHRcdFx0aWYgKE9iamVjdChlJDEpICE9PSBlJDEpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ1c2luZyBkZWNsYXJhdGlvbnMgY2FuIG9ubHkgYmUgdXNlZCB3aXRoIG9iamVjdHMsIGZ1bmN0aW9ucywgbnVsbCwgb3IgdW5kZWZpbmVkLlwiKTtcblx0XHRcdFx0aWYgKHIkMSkgdmFyIG8gPSBlJDFbU3ltYm9sLmFzeW5jRGlzcG9zZSB8fCBTeW1ib2xbXCJmb3JcIl0oXCJTeW1ib2wuYXN5bmNEaXNwb3NlXCIpXTtcblx0XHRcdFx0aWYgKHZvaWQgMCA9PT0gbyAmJiAobyA9IGUkMVtTeW1ib2wuZGlzcG9zZSB8fCBTeW1ib2xbXCJmb3JcIl0oXCJTeW1ib2wuZGlzcG9zZVwiKV0sIHIkMSkpIHZhciB0ID0gbztcblx0XHRcdFx0aWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbykgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBpcyBub3QgZGlzcG9zYWJsZS5cIik7XG5cdFx0XHRcdHQgJiYgKG8gPSBmdW5jdGlvbiBvJDEoKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHQuY2FsbChlJDEpO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKHIkMikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KHIkMik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KSwgbi5wdXNoKHtcblx0XHRcdFx0XHR2OiBlJDEsXG5cdFx0XHRcdFx0ZDogbyxcblx0XHRcdFx0XHRhOiByJDFcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGVsc2UgciQxICYmIG4ucHVzaCh7XG5cdFx0XHRcdGQ6IGUkMSxcblx0XHRcdFx0YTogciQxXG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBlJDE7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHRlLFxuXHRcdFx0dTogdXNpbmcuYmluZChudWxsLCAhMSksXG5cdFx0XHRhOiB1c2luZy5iaW5kKG51bGwsICEwKSxcblx0XHRcdGQ6IGZ1bmN0aW9uIGQoKSB7XG5cdFx0XHRcdHZhciBvLCB0ID0gdGhpcy5lLCBzID0gMDtcblx0XHRcdFx0ZnVuY3Rpb24gbmV4dCgpIHtcblx0XHRcdFx0XHRmb3IgKDsgbyA9IG4ucG9wKCk7KSB0cnkge1xuXHRcdFx0XHRcdFx0aWYgKCFvLmEgJiYgMSA9PT0gcykgcmV0dXJuIHMgPSAwLCBuLnB1c2gobyksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG5cdFx0XHRcdFx0XHRpZiAoby5kKSB7XG5cdFx0XHRcdFx0XHRcdHZhciByJDEgPSBvLmQuY2FsbChvLnYpO1xuXHRcdFx0XHRcdFx0XHRpZiAoby5hKSByZXR1cm4gcyB8PSAyLCBQcm9taXNlLnJlc29sdmUociQxKS50aGVuKG5leHQsIGVycik7XG5cdFx0XHRcdFx0XHR9IGVsc2UgcyB8PSAxO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKHIkMikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVycihyJDIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoMSA9PT0gcykgcmV0dXJuIHQgIT09IGUgPyBQcm9taXNlLnJlamVjdCh0KSA6IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0XHRcdGlmICh0ICE9PSBlKSB0aHJvdyB0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZ1bmN0aW9uIGVycihuJDEpIHtcblx0XHRcdFx0XHRyZXR1cm4gdCA9IHQgIT09IGUgPyBuZXcgcihuJDEsIHQpIDogbiQxLCBuZXh0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG5leHQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gX3VzaW5nQ3R4LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9PdmVybG9hZFlpZWxkLmpzXG52YXIgcmVxdWlyZV9PdmVybG9hZFlpZWxkID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvT3ZlcmxvYWRZaWVsZC5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHRmdW5jdGlvbiBfT3ZlcmxvYWRZaWVsZChlLCBkKSB7XG5cdFx0dGhpcy52ID0gZSwgdGhpcy5rID0gZDtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9PdmVybG9hZFlpZWxkLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG59IH0pO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiAuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hd2FpdEFzeW5jR2VuZXJhdG9yLmpzXG52YXIgcmVxdWlyZV9hd2FpdEFzeW5jR2VuZXJhdG9yID0gX19jb21tb25KUyh7IFwiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvYXdhaXRBc3luY0dlbmVyYXRvci5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuXHR2YXIgT3ZlcmxvYWRZaWVsZCQyID0gcmVxdWlyZV9PdmVybG9hZFlpZWxkKCk7XG5cdGZ1bmN0aW9uIF9hd2FpdEFzeW5jR2VuZXJhdG9yJDUoZSkge1xuXHRcdHJldHVybiBuZXcgT3ZlcmxvYWRZaWVsZCQyKGUsIDApO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gX2F3YWl0QXN5bmNHZW5lcmF0b3IkNSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSB9KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvd3JhcEFzeW5jR2VuZXJhdG9yLmpzXG52YXIgcmVxdWlyZV93cmFwQXN5bmNHZW5lcmF0b3IgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy93cmFwQXN5bmNHZW5lcmF0b3IuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcblx0dmFyIE92ZXJsb2FkWWllbGQkMSA9IHJlcXVpcmVfT3ZlcmxvYWRZaWVsZCgpO1xuXHRmdW5jdGlvbiBfd3JhcEFzeW5jR2VuZXJhdG9yJDYoZSkge1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgQXN5bmNHZW5lcmF0b3IoZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcblx0XHR9O1xuXHR9XG5cdGZ1bmN0aW9uIEFzeW5jR2VuZXJhdG9yKGUpIHtcblx0XHR2YXIgciwgdDtcblx0XHRmdW5jdGlvbiByZXN1bWUociQxLCB0JDEpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBuID0gZVtyJDFdKHQkMSksIG8gPSBuLnZhbHVlLCB1ID0gbyBpbnN0YW5jZW9mIE92ZXJsb2FkWWllbGQkMTtcblx0XHRcdFx0UHJvbWlzZS5yZXNvbHZlKHUgPyBvLnYgOiBvKS50aGVuKGZ1bmN0aW9uKHQkMikge1xuXHRcdFx0XHRcdGlmICh1KSB7XG5cdFx0XHRcdFx0XHR2YXIgaSA9IFwicmV0dXJuXCIgPT09IHIkMSA/IFwicmV0dXJuXCIgOiBcIm5leHRcIjtcblx0XHRcdFx0XHRcdGlmICghby5rIHx8IHQkMi5kb25lKSByZXR1cm4gcmVzdW1lKGksIHQkMik7XG5cdFx0XHRcdFx0XHR0JDIgPSBlW2ldKHQkMikudmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNldHRsZShuLmRvbmUgPyBcInJldHVyblwiIDogXCJub3JtYWxcIiwgdCQyKTtcblx0XHRcdFx0fSwgZnVuY3Rpb24oZSQxKSB7XG5cdFx0XHRcdFx0cmVzdW1lKFwidGhyb3dcIiwgZSQxKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9IGNhdGNoIChlJDEpIHtcblx0XHRcdFx0c2V0dGxlKFwidGhyb3dcIiwgZSQxKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0ZnVuY3Rpb24gc2V0dGxlKGUkMSwgbikge1xuXHRcdFx0c3dpdGNoIChlJDEpIHtcblx0XHRcdFx0Y2FzZSBcInJldHVyblwiOlxuXHRcdFx0XHRcdHIucmVzb2x2ZSh7XG5cdFx0XHRcdFx0XHR2YWx1ZTogbixcblx0XHRcdFx0XHRcdGRvbmU6ICEwXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJ0aHJvd1wiOlxuXHRcdFx0XHRcdHIucmVqZWN0KG4pO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRkZWZhdWx0OiByLnJlc29sdmUoe1xuXHRcdFx0XHRcdHZhbHVlOiBuLFxuXHRcdFx0XHRcdGRvbmU6ICExXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0KHIgPSByLm5leHQpID8gcmVzdW1lKHIua2V5LCByLmFyZykgOiB0ID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5faW52b2tlID0gZnVuY3Rpb24oZSQxLCBuKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obywgdSkge1xuXHRcdFx0XHR2YXIgaSA9IHtcblx0XHRcdFx0XHRrZXk6IGUkMSxcblx0XHRcdFx0XHRhcmc6IG4sXG5cdFx0XHRcdFx0cmVzb2x2ZTogbyxcblx0XHRcdFx0XHRyZWplY3Q6IHUsXG5cdFx0XHRcdFx0bmV4dDogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0ID8gdCA9IHQubmV4dCA9IGkgOiAociA9IHQgPSBpLCByZXN1bWUoZSQxLCBuKSk7XG5cdFx0XHR9KTtcblx0XHR9LCBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGVbXCJyZXR1cm5cIl0gJiYgKHRoaXNbXCJyZXR1cm5cIl0gPSB2b2lkIDApO1xuXHR9XG5cdEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZVtcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRyZXR1cm4gdGhpcy5faW52b2tlKFwibmV4dFwiLCBlKTtcblx0fSwgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1widGhyb3dcIl0gPSBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludm9rZShcInRocm93XCIsIGUpO1xuXHR9LCBBc3luY0dlbmVyYXRvci5wcm90b3R5cGVbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbihlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludm9rZShcInJldHVyblwiLCBlKTtcblx0fTtcblx0bW9kdWxlLmV4cG9ydHMgPSBfd3JhcEFzeW5jR2VuZXJhdG9yJDYsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3V0aWxzL2FzeW5jSXRlcmFibGUudHNcbnZhciBpbXBvcnRfdXNpbmdDdHgkNCA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbnZhciBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQ0ID0gX190b0VTTShyZXF1aXJlX2F3YWl0QXN5bmNHZW5lcmF0b3IoKSwgMSk7XG52YXIgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQ1ID0gX190b0VTTShyZXF1aXJlX3dyYXBBc3luY0dlbmVyYXRvcigpLCAxKTtcbmZ1bmN0aW9uIGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0aWYgKGl0ZXJhdG9yW1N5bWJvbC5hc3luY0Rpc3Bvc2VdKSByZXR1cm4gaXRlcmF0b3I7XG5cdHJldHVybiBtYWtlQXN5bmNSZXNvdXJjZShpdGVyYXRvciwgYXN5bmMgKCkgPT4ge1xuXHRcdHZhciBfaXRlcmF0b3IkcmV0dXJuO1xuXHRcdGF3YWl0ICgoX2l0ZXJhdG9yJHJldHVybiA9IGl0ZXJhdG9yLnJldHVybikgPT09IG51bGwgfHwgX2l0ZXJhdG9yJHJldHVybiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2l0ZXJhdG9yJHJldHVybi5jYWxsKGl0ZXJhdG9yKSk7XG5cdH0pO1xufVxuLyoqXG4qIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvbiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IGF1dG9tYXRpY2FsbHkgYWJvcnRzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXG4qL1xuZnVuY3Rpb24gd2l0aE1heER1cmF0aW9uKF94LCBfeDIpIHtcblx0cmV0dXJuIF93aXRoTWF4RHVyYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF93aXRoTWF4RHVyYXRpb24oKSB7XG5cdF93aXRoTWF4RHVyYXRpb24gPSAoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQ1LmRlZmF1bHQpKGZ1bmN0aW9uKiAoaXRlcmFibGUsIG9wdHMpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQ0LmRlZmF1bHQpKCk7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IF91c2luZ0N0eCQxLmEoaXRlcmF0b3JSZXNvdXJjZShpdGVyYWJsZSkpO1xuXHRcdFx0Y29uc3QgdGltZXIgPSBfdXNpbmdDdHgkMS51KHRpbWVyUmVzb3VyY2Uob3B0cy5tYXhEdXJhdGlvbk1zKSk7XG5cdFx0XHRjb25zdCB0aW1lclByb21pc2UgPSB0aW1lci5zdGFydCgpO1xuXHRcdFx0bGV0IHJlc3VsdDtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQ0LmRlZmF1bHQpKFVucHJvbWlzZS5yYWNlKFtpdGVyYXRvci5uZXh0KCksIHRpbWVyUHJvbWlzZV0pKTtcblx0XHRcdFx0aWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkgdGhyb3dBYm9ydEVycm9yKCk7XG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkgcmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0eWllbGQgcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRyZXN1bHQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdF91c2luZ0N0eCQxLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkNC5kZWZhdWx0KShfdXNpbmdDdHgkMS5kKCkpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBfd2l0aE1heER1cmF0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG4vKipcbiogRGVyaXZlcyBhIG5ldyB7QGxpbmsgQXN5bmNHZW5lcmF0b3J9IGJhc2VkIG9mIHtAbGluayBpdGVyYWJsZX0sIHRoYXQgeWllbGRzIGl0cyBmaXJzdFxuKiB7QGxpbmsgY291bnR9IHZhbHVlcy4gVGhlbiwgYSBncmFjZSBwZXJpb2Qgb2Yge0BsaW5rIGdyYWNlUGVyaW9kTXN9IGlzIHN0YXJ0ZWQgaW4gd2hpY2ggZnVydGhlclxuKiB2YWx1ZXMgbWF5IHN0aWxsIGNvbWUgdGhyb3VnaC4gQWZ0ZXIgdGhpcyBwZXJpb2QsIHRoZSBnZW5lcmF0b3IgYWJvcnRzLlxuKi9cbmZ1bmN0aW9uIHRha2VXaXRoR3JhY2UoX3gzLCBfeDQpIHtcblx0cmV0dXJuIF90YWtlV2l0aEdyYWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfdGFrZVdpdGhHcmFjZSgpIHtcblx0X3Rha2VXaXRoR3JhY2UgPSAoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQ1LmRlZmF1bHQpKGZ1bmN0aW9uKiAoaXRlcmFibGUsIG9wdHMpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIF91c2luZ0N0eDMgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDQuZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4My5hKGl0ZXJhdG9yUmVzb3VyY2UoaXRlcmFibGUpKTtcblx0XHRcdGxldCByZXN1bHQ7XG5cdFx0XHRjb25zdCB0aW1lciA9IF91c2luZ0N0eDMudSh0aW1lclJlc291cmNlKG9wdHMuZ3JhY2VQZXJpb2RNcykpO1xuXHRcdFx0bGV0IGNvdW50ID0gb3B0cy5jb3VudDtcblx0XHRcdGxldCB0aW1lclByb21pc2UgPSBuZXcgUHJvbWlzZSgoKSA9PiB7fSk7XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRyZXN1bHQgPSB5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkNC5kZWZhdWx0KShVbnByb21pc2UucmFjZShbaXRlcmF0b3IubmV4dCgpLCB0aW1lclByb21pc2VdKSk7XG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHRocm93QWJvcnRFcnJvcigpO1xuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdHlpZWxkIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0aWYgKC0tY291bnQgPT09IDApIHRpbWVyUHJvbWlzZSA9IHRpbWVyLnN0YXJ0KCk7XG5cdFx0XHRcdHJlc3VsdCA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoXykge1xuXHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0eWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDQuZGVmYXVsdCkoX3VzaW5nQ3R4My5kKCkpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBfdGFrZVdpdGhHcmFjZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy9jcmVhdGVEZWZlcnJlZC50c1xuZnVuY3Rpb24gY3JlYXRlRGVmZXJyZWQoKSB7XG5cdGxldCByZXNvbHZlO1xuXHRsZXQgcmVqZWN0O1xuXHRjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cdFx0cmVzb2x2ZSA9IHJlcztcblx0XHRyZWplY3QgPSByZWo7XG5cdH0pO1xuXHRyZXR1cm4ge1xuXHRcdHByb21pc2UsXG5cdFx0cmVzb2x2ZSxcblx0XHRyZWplY3Rcblx0fTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvbWVyZ2VBc3luY0l0ZXJhYmxlcy50c1xudmFyIGltcG9ydF91c2luZ0N0eCQzID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xudmFyIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDMgPSBfX3RvRVNNKHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDQgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xuZnVuY3Rpb24gY3JlYXRlTWFuYWdlZEl0ZXJhdG9yKGl0ZXJhYmxlLCBvblJlc3VsdCkge1xuXHRjb25zdCBpdGVyYXRvciA9IGl0ZXJhYmxlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpO1xuXHRsZXQgc3RhdGUgPSBcImlkbGVcIjtcblx0ZnVuY3Rpb24gY2xlYW51cCgpIHtcblx0XHRzdGF0ZSA9IFwiZG9uZVwiO1xuXHRcdG9uUmVzdWx0ID0gKCkgPT4ge307XG5cdH1cblx0ZnVuY3Rpb24gcHVsbCgpIHtcblx0XHRpZiAoc3RhdGUgIT09IFwiaWRsZVwiKSByZXR1cm47XG5cdFx0c3RhdGUgPSBcInBlbmRpbmdcIjtcblx0XHRjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuXHRcdG5leHQudGhlbigocmVzdWx0KSA9PiB7XG5cdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0c3RhdGUgPSBcImRvbmVcIjtcblx0XHRcdFx0b25SZXN1bHQoe1xuXHRcdFx0XHRcdHN0YXR1czogXCJyZXR1cm5cIixcblx0XHRcdFx0XHR2YWx1ZTogcmVzdWx0LnZhbHVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRjbGVhbnVwKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHN0YXRlID0gXCJpZGxlXCI7XG5cdFx0XHRvblJlc3VsdCh7XG5cdFx0XHRcdHN0YXR1czogXCJ5aWVsZFwiLFxuXHRcdFx0XHR2YWx1ZTogcmVzdWx0LnZhbHVlXG5cdFx0XHR9KTtcblx0XHR9KS5jYXRjaCgoY2F1c2UpID0+IHtcblx0XHRcdG9uUmVzdWx0KHtcblx0XHRcdFx0c3RhdHVzOiBcImVycm9yXCIsXG5cdFx0XHRcdGVycm9yOiBjYXVzZVxuXHRcdFx0fSk7XG5cdFx0XHRjbGVhbnVwKCk7XG5cdFx0fSk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRwdWxsLFxuXHRcdGRlc3Ryb3k6IGFzeW5jICgpID0+IHtcblx0XHRcdHZhciBfaXRlcmF0b3IkcmV0dXJuO1xuXHRcdFx0Y2xlYW51cCgpO1xuXHRcdFx0YXdhaXQgKChfaXRlcmF0b3IkcmV0dXJuID0gaXRlcmF0b3IucmV0dXJuKSA9PT0gbnVsbCB8fCBfaXRlcmF0b3IkcmV0dXJuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaXRlcmF0b3IkcmV0dXJuLmNhbGwoaXRlcmF0b3IpKTtcblx0XHR9XG5cdH07XG59XG4vKipcbiogQ3JlYXRlcyBhIG5ldyBhc3luYyBpdGVyYWJsZSB0aGF0IG1lcmdlcyBtdWx0aXBsZSBhc3luYyBpdGVyYWJsZXMgaW50byBhIHNpbmdsZSBzdHJlYW0uXG4qIFZhbHVlcyBmcm9tIHRoZSBpbnB1dCBpdGVyYWJsZXMgYXJlIHlpZWxkZWQgaW4gdGhlIG9yZGVyIHRoZXkgcmVzb2x2ZSwgc2ltaWxhciB0byBQcm9taXNlLnJhY2UoKS5cbipcbiogTmV3IGl0ZXJhYmxlcyBjYW4gYmUgYWRkZWQgZHluYW1pY2FsbHkgdXNpbmcgdGhlIHJldHVybmVkIHtAbGluayBNZXJnZWRBc3luY0l0ZXJhYmxlcy5hZGR9IG1ldGhvZCwgZXZlbiBhZnRlciBpdGVyYXRpb24gaGFzIHN0YXJ0ZWQuXG4qXG4qIElmIGFueSBvZiB0aGUgaW5wdXQgaXRlcmFibGVzIHRocm93cyBhbiBlcnJvciwgdGhhdCBlcnJvciB3aWxsIGJlIHByb3BhZ2F0ZWQgdGhyb3VnaCB0aGUgbWVyZ2VkIHN0cmVhbS5cbiogT3RoZXIgaXRlcmFibGVzIHdpbGwgbm90IGNvbnRpbnVlIHRvIGJlIHByb2Nlc3NlZC5cbipcbiogQHRlbXBsYXRlIFRZaWVsZCBUaGUgdHlwZSBvZiB2YWx1ZXMgeWllbGRlZCBieSB0aGUgaW5wdXQgaXRlcmFibGVzXG4qL1xuZnVuY3Rpb24gbWVyZ2VBc3luY0l0ZXJhYmxlcygpIHtcblx0bGV0IHN0YXRlID0gXCJpZGxlXCI7XG5cdGxldCBmbHVzaFNpZ25hbCA9IGNyZWF0ZURlZmVycmVkKCk7XG5cdC8qKlxuXHQqIHVzZWQgd2hpbGUge0BsaW5rIHN0YXRlfSBpcyBgaWRsZWBcblx0Ki9cblx0Y29uc3QgaXRlcmFibGVzID0gW107XG5cdC8qKlxuXHQqIHVzZWQgd2hpbGUge0BsaW5rIHN0YXRlfSBpcyBgcGVuZGluZ2Bcblx0Ki9cblx0Y29uc3QgaXRlcmF0b3JzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcblx0Y29uc3QgYnVmZmVyID0gW107XG5cdGZ1bmN0aW9uIGluaXRJdGVyYWJsZShpdGVyYWJsZSkge1xuXHRcdGlmIChzdGF0ZSAhPT0gXCJwZW5kaW5nXCIpIHJldHVybjtcblx0XHRjb25zdCBpdGVyYXRvciA9IGNyZWF0ZU1hbmFnZWRJdGVyYXRvcihpdGVyYWJsZSwgKHJlc3VsdCkgPT4ge1xuXHRcdFx0aWYgKHN0YXRlICE9PSBcInBlbmRpbmdcIikgcmV0dXJuO1xuXHRcdFx0c3dpdGNoIChyZXN1bHQuc3RhdHVzKSB7XG5cdFx0XHRcdGNhc2UgXCJ5aWVsZFwiOlxuXHRcdFx0XHRcdGJ1ZmZlci5wdXNoKFtpdGVyYXRvciwgcmVzdWx0XSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJyZXR1cm5cIjpcblx0XHRcdFx0XHRpdGVyYXRvcnMuZGVsZXRlKGl0ZXJhdG9yKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImVycm9yXCI6XG5cdFx0XHRcdFx0YnVmZmVyLnB1c2goW2l0ZXJhdG9yLCByZXN1bHRdKTtcblx0XHRcdFx0XHRpdGVyYXRvcnMuZGVsZXRlKGl0ZXJhdG9yKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGZsdXNoU2lnbmFsLnJlc29sdmUoKTtcblx0XHR9KTtcblx0XHRpdGVyYXRvcnMuYWRkKGl0ZXJhdG9yKTtcblx0XHRpdGVyYXRvci5wdWxsKCk7XG5cdH1cblx0cmV0dXJuIHtcblx0XHRhZGQoaXRlcmFibGUpIHtcblx0XHRcdHN3aXRjaCAoc3RhdGUpIHtcblx0XHRcdFx0Y2FzZSBcImlkbGVcIjpcblx0XHRcdFx0XHRpdGVyYWJsZXMucHVzaChpdGVyYWJsZSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgXCJwZW5kaW5nXCI6XG5cdFx0XHRcdFx0aW5pdEl0ZXJhYmxlKGl0ZXJhYmxlKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImRvbmVcIjogYnJlYWs7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuXHRcdFx0cmV0dXJuICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDQuZGVmYXVsdCkoZnVuY3Rpb24qICgpIHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YXIgX3VzaW5nQ3R4JDEgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDMuZGVmYXVsdCkoKTtcblx0XHRcdFx0XHRpZiAoc3RhdGUgIT09IFwiaWRsZVwiKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaXRlcmF0ZSB0d2ljZVwiKTtcblx0XHRcdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiO1xuXHRcdFx0XHRcdGNvbnN0IF9maW5hbGx5ID0gX3VzaW5nQ3R4JDEuYShtYWtlQXN5bmNSZXNvdXJjZSh7fSwgYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3RhdGUgPSBcImRvbmVcIjtcblx0XHRcdFx0XHRcdGNvbnN0IGVycm9ycyA9IFtdO1xuXHRcdFx0XHRcdFx0YXdhaXQgUHJvbWlzZS5hbGwoQXJyYXkuZnJvbShpdGVyYXRvcnMudmFsdWVzKCkpLm1hcChhc3luYyAoaXQpID0+IHtcblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHRhd2FpdCBpdC5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGNhdXNlKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3JzLnB1c2goY2F1c2UpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRidWZmZXIubGVuZ3RoID0gMDtcblx0XHRcdFx0XHRcdGl0ZXJhdG9ycy5jbGVhcigpO1xuXHRcdFx0XHRcdFx0Zmx1c2hTaWduYWwucmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0aWYgKGVycm9ycy5sZW5ndGggPiAwKSB0aHJvdyBuZXcgQWdncmVnYXRlRXJyb3IoZXJyb3JzKTtcblx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0d2hpbGUgKGl0ZXJhYmxlcy5sZW5ndGggPiAwKSBpbml0SXRlcmFibGUoaXRlcmFibGVzLnNoaWZ0KCkpO1xuXHRcdFx0XHRcdHdoaWxlIChpdGVyYXRvcnMuc2l6ZSA+IDApIHtcblx0XHRcdFx0XHRcdHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQzLmRlZmF1bHQpKGZsdXNoU2lnbmFsLnByb21pc2UpO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGJ1ZmZlci5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IFtpdGVyYXRvciwgcmVzdWx0XSA9IGJ1ZmZlci5zaGlmdCgpO1xuXHRcdFx0XHRcdFx0XHRzd2l0Y2ggKHJlc3VsdC5zdGF0dXMpIHtcblx0XHRcdFx0XHRcdFx0XHRjYXNlIFwieWllbGRcIjpcblx0XHRcdFx0XHRcdFx0XHRcdHlpZWxkIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGl0ZXJhdG9yLnB1bGwoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdGNhc2UgXCJlcnJvclwiOiB0aHJvdyByZXN1bHQuZXJyb3I7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZsdXNoU2lnbmFsID0gY3JlYXRlRGVmZXJyZWQoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkMy5kZWZhdWx0KShfdXNpbmdDdHgkMS5kKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSgpO1xuXHRcdH1cblx0fTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdXRpbHMvcmVhZGFibGVTdHJlYW1Gcm9tLnRzXG4vKipcbiogQ3JlYXRlcyBhIFJlYWRhYmxlU3RyZWFtIGZyb20gYW4gQXN5bmNJdGVyYWJsZS5cbipcbiogQHBhcmFtIGl0ZXJhYmxlIC0gVGhlIHNvdXJjZSBBc3luY0l0ZXJhYmxlIHRvIHN0cmVhbSBmcm9tXG4qIEByZXR1cm5zIEEgUmVhZGFibGVTdHJlYW0gdGhhdCB5aWVsZHMgdmFsdWVzIGZyb20gdGhlIEFzeW5jSXRlcmFibGVcbiovXG5mdW5jdGlvbiByZWFkYWJsZVN0cmVhbUZyb20oaXRlcmFibGUpIHtcblx0Y29uc3QgaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcblx0cmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG5cdFx0YXN5bmMgY2FuY2VsKCkge1xuXHRcdFx0dmFyIF9pdGVyYXRvciRyZXR1cm47XG5cdFx0XHRhd2FpdCAoKF9pdGVyYXRvciRyZXR1cm4gPSBpdGVyYXRvci5yZXR1cm4pID09PSBudWxsIHx8IF9pdGVyYXRvciRyZXR1cm4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pdGVyYXRvciRyZXR1cm4uY2FsbChpdGVyYXRvcikpO1xuXHRcdH0sXG5cdFx0YXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdW5zdGFibGUtY29yZS1kby1ub3QtaW1wb3J0L3N0cmVhbS91dGlscy93aXRoUGluZy50c1xudmFyIGltcG9ydF91c2luZ0N0eCQyID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xudmFyIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDIgPSBfX3RvRVNNKHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDMgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xuY29uc3QgUElOR19TWU0gPSBTeW1ib2woXCJwaW5nXCIpO1xuLyoqXG4qIERlcml2ZXMgYSBuZXcge0BsaW5rIEFzeW5jR2VuZXJhdG9yfSBiYXNlZCBvZiB7QGxpbmsgaXRlcmFibGV9LCB0aGF0IHlpZWxkcyB7QGxpbmsgUElOR19TWU19XG4qIHdoZW5ldmVyIG5vIHZhbHVlIGhhcyBiZWVuIHlpZWxkZWQgZm9yIHtAbGluayBwaW5nSW50ZXJ2YWxNc30uXG4qL1xuZnVuY3Rpb24gd2l0aFBpbmcoX3gsIF94Mikge1xuXHRyZXR1cm4gX3dpdGhQaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBfd2l0aFBpbmcoKSB7XG5cdF93aXRoUGluZyA9ICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDMuZGVmYXVsdCkoZnVuY3Rpb24qIChpdGVyYWJsZSwgcGluZ0ludGVydmFsTXMpIHtcblx0XHR0cnkge1xuXHRcdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eCQyLmRlZmF1bHQpKCk7XG5cdFx0XHRjb25zdCBpdGVyYXRvciA9IF91c2luZ0N0eCQxLmEoaXRlcmF0b3JSZXNvdXJjZShpdGVyYWJsZSkpO1xuXHRcdFx0bGV0IHJlc3VsdDtcblx0XHRcdGxldCBuZXh0UHJvbWlzZSA9IGl0ZXJhdG9yLm5leHQoKTtcblx0XHRcdHdoaWxlICh0cnVlKSB0cnkge1xuXHRcdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMi5kZWZhdWx0KSgpO1xuXHRcdFx0XHRjb25zdCBwaW5nUHJvbWlzZSA9IF91c2luZ0N0eDMudSh0aW1lclJlc291cmNlKHBpbmdJbnRlcnZhbE1zKSk7XG5cdFx0XHRcdHJlc3VsdCA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQyLmRlZmF1bHQpKFVucHJvbWlzZS5yYWNlKFtuZXh0UHJvbWlzZSwgcGluZ1Byb21pc2Uuc3RhcnQoKV0pKTtcblx0XHRcdFx0aWYgKHJlc3VsdCA9PT0gZGlzcG9zYWJsZVByb21pc2VUaW1lclJlc3VsdCkge1xuXHRcdFx0XHRcdHlpZWxkIFBJTkdfU1lNO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChyZXN1bHQuZG9uZSkgcmV0dXJuIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0bmV4dFByb21pc2UgPSBpdGVyYXRvci5uZXh0KCk7XG5cdFx0XHRcdHlpZWxkIHJlc3VsdC52YWx1ZTtcblx0XHRcdFx0cmVzdWx0ID0gbnVsbDtcblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0X3VzaW5nQ3R4My5lID0gXztcblx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdF91c2luZ0N0eDMuZCgpO1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdF91c2luZ0N0eCQxLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkMi5kZWZhdWx0KShfdXNpbmdDdHgkMS5kKCkpO1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiBfd2l0aFBpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BveGMtcHJvamVjdCtydW50aW1lQDAuNzIuMi9ub2RlX21vZHVsZXMvQG94Yy1wcm9qZWN0L3J1bnRpbWUvc3JjL2hlbHBlcnMvYXN5bmNJdGVyYXRvci5qc1xudmFyIHJlcXVpcmVfYXN5bmNJdGVyYXRvciA9IF9fY29tbW9uSlMoeyBcIi4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2FzeW5jSXRlcmF0b3IuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcblx0ZnVuY3Rpb24gX2FzeW5jSXRlcmF0b3IkMihyKSB7XG5cdFx0dmFyIG4sIHQsIG8sIGUgPSAyO1xuXHRcdGZvciAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmICh0ID0gU3ltYm9sLmFzeW5jSXRlcmF0b3IsIG8gPSBTeW1ib2wuaXRlcmF0b3IpOyBlLS07KSB7XG5cdFx0XHRpZiAodCAmJiBudWxsICE9IChuID0gclt0XSkpIHJldHVybiBuLmNhbGwocik7XG5cdFx0XHRpZiAobyAmJiBudWxsICE9IChuID0gcltvXSkpIHJldHVybiBuZXcgQXN5bmNGcm9tU3luY0l0ZXJhdG9yKG4uY2FsbChyKSk7XG5cdFx0XHR0ID0gXCJAQGFzeW5jSXRlcmF0b3JcIiwgbyA9IFwiQEBpdGVyYXRvclwiO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGlzIG5vdCBhc3luYyBpdGVyYWJsZVwiKTtcblx0fVxuXHRmdW5jdGlvbiBBc3luY0Zyb21TeW5jSXRlcmF0b3Iocikge1xuXHRcdGZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvckNvbnRpbnVhdGlvbihyJDEpIHtcblx0XHRcdGlmIChPYmplY3QociQxKSAhPT0gciQxKSByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFR5cGVFcnJvcihyJDEgKyBcIiBpcyBub3QgYW4gb2JqZWN0LlwiKSk7XG5cdFx0XHR2YXIgbiA9IHIkMS5kb25lO1xuXHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShyJDEudmFsdWUpLnRoZW4oZnVuY3Rpb24ociQyKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHIkMixcblx0XHRcdFx0XHRkb25lOiBuXG5cdFx0XHRcdH07XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIEFzeW5jRnJvbVN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIEFzeW5jRnJvbVN5bmNJdGVyYXRvciQxKHIkMSkge1xuXHRcdFx0dGhpcy5zID0gciQxLCB0aGlzLm4gPSByJDEubmV4dDtcblx0XHR9LCBBc3luY0Zyb21TeW5jSXRlcmF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0czogbnVsbCxcblx0XHRcdG46IG51bGwsXG5cdFx0XHRuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuXHRcdFx0XHRyZXR1cm4gQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKHRoaXMubi5hcHBseSh0aGlzLnMsIGFyZ3VtZW50cykpO1xuXHRcdFx0fSxcblx0XHRcdFwicmV0dXJuXCI6IGZ1bmN0aW9uIF9yZXR1cm4ociQxKSB7XG5cdFx0XHRcdHZhciBuID0gdGhpcy5zW1wicmV0dXJuXCJdO1xuXHRcdFx0XHRyZXR1cm4gdm9pZCAwID09PSBuID8gUHJvbWlzZS5yZXNvbHZlKHtcblx0XHRcdFx0XHR2YWx1ZTogciQxLFxuXHRcdFx0XHRcdGRvbmU6ICEwXG5cdFx0XHRcdH0pIDogQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKG4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcblx0XHRcdH0sXG5cdFx0XHRcInRocm93XCI6IGZ1bmN0aW9uIF90aHJvdyhyJDEpIHtcblx0XHRcdFx0dmFyIG4gPSB0aGlzLnNbXCJyZXR1cm5cIl07XG5cdFx0XHRcdHJldHVybiB2b2lkIDAgPT09IG4gPyBQcm9taXNlLnJlamVjdChyJDEpIDogQXN5bmNGcm9tU3luY0l0ZXJhdG9yQ29udGludWF0aW9uKG4uYXBwbHkodGhpcy5zLCBhcmd1bWVudHMpKTtcblx0XHRcdH1cblx0XHR9LCBuZXcgQXN5bmNGcm9tU3luY0l0ZXJhdG9yKHIpO1xuXHR9XG5cdG1vZHVsZS5leHBvcnRzID0gX2FzeW5jSXRlcmF0b3IkMiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xufSB9KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vanNvbmwudHNcbnZhciBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQxID0gX190b0VTTShyZXF1aXJlX2F3YWl0QXN5bmNHZW5lcmF0b3IoKSwgMSk7XG52YXIgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQyID0gX190b0VTTShyZXF1aXJlX3dyYXBBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfdXNpbmdDdHgkMSA9IF9fdG9FU00ocmVxdWlyZV91c2luZ0N0eCgpLCAxKTtcbnZhciBpbXBvcnRfYXN5bmNJdGVyYXRvciQxID0gX190b0VTTShyZXF1aXJlX2FzeW5jSXRlcmF0b3IoKSwgMSk7XG5jb25zdCBDSFVOS19WQUxVRV9UWVBFX1BST01JU0UgPSAwO1xuY29uc3QgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRSA9IDE7XG5jb25zdCBQUk9NSVNFX1NUQVRVU19GVUxGSUxMRUQgPSAwO1xuY29uc3QgUFJPTUlTRV9TVEFUVVNfUkVKRUNURUQgPSAxO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX1JFVFVSTiA9IDA7XG5jb25zdCBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQgPSAxO1xuY29uc3QgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SID0gMjtcbmZ1bmN0aW9uIGlzUHJvbWlzZSh2YWx1ZSkge1xuXHRyZXR1cm4gKGlzT2JqZWN0KHZhbHVlKSB8fCBpc0Z1bmN0aW9uKHZhbHVlKSkgJiYgdHlwZW9mICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFsdWVbXCJ0aGVuXCJdKSA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbHVlW1wiY2F0Y2hcIl0pID09PSBcImZ1bmN0aW9uXCI7XG59XG52YXIgTWF4RGVwdGhFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihwYXRoKSB7XG5cdFx0c3VwZXIoXCJNYXggZGVwdGggcmVhY2hlZCBhdCBwYXRoOiBcIiArIHBhdGguam9pbihcIi5cIikpO1xuXHRcdHRoaXMucGF0aCA9IHBhdGg7XG5cdH1cbn07XG5mdW5jdGlvbiBjcmVhdGVCYXRjaFN0cmVhbVByb2R1Y2VyKF94Mykge1xuXHRyZXR1cm4gX2NyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9jcmVhdGVCYXRjaFN0cmVhbVByb2R1Y2VyKCkge1xuXHRfY3JlYXRlQmF0Y2hTdHJlYW1Qcm9kdWNlciA9ICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDIuZGVmYXVsdCkoZnVuY3Rpb24qIChvcHRzKSB7XG5cdFx0Y29uc3QgeyBkYXRhIH0gPSBvcHRzO1xuXHRcdGxldCBjb3VudGVyID0gMDtcblx0XHRjb25zdCBwbGFjZWhvbGRlciA9IDA7XG5cdFx0Y29uc3QgbWVyZ2VkSXRlcmFibGVzID0gbWVyZ2VBc3luY0l0ZXJhYmxlcygpO1xuXHRcdGZ1bmN0aW9uIHJlZ2lzdGVyQXN5bmMoY2FsbGJhY2spIHtcblx0XHRcdGNvbnN0IGlkeCA9IGNvdW50ZXIrKztcblx0XHRcdGNvbnN0IGl0ZXJhYmxlJDEgPSBjYWxsYmFjayhpZHgpO1xuXHRcdFx0bWVyZ2VkSXRlcmFibGVzLmFkZChpdGVyYWJsZSQxKTtcblx0XHRcdHJldHVybiBpZHg7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGVuY29kZVByb21pc2UocHJvbWlzZSwgcGF0aCkge1xuXHRcdFx0cmV0dXJuIHJlZ2lzdGVyQXN5bmMoLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX3JlZiA9ICgwLCBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDIuZGVmYXVsdCkoZnVuY3Rpb24qIChpZHgpIHtcblx0XHRcdFx0XHRjb25zdCBlcnJvciA9IGNoZWNrTWF4RGVwdGgocGF0aCk7XG5cdFx0XHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRwcm9taXNlLmNhdGNoKChjYXVzZSkgPT4ge1xuXHRcdFx0XHRcdFx0XHR2YXIgX29wdHMkb25FcnJvcjtcblx0XHRcdFx0XHRcdFx0KF9vcHRzJG9uRXJyb3IgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IgPT09IHZvaWQgMCB8fCBfb3B0cyRvbkVycm9yLmNhbGwob3B0cywge1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjYXVzZSxcblx0XHRcdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRwcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV4dCA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKHByb21pc2UpO1xuXHRcdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdFBST01JU0VfU1RBVFVTX0ZVTEZJTExFRCxcblx0XHRcdFx0XHRcdFx0ZW5jb2RlKG5leHQsIHBhdGgpXG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKGNhdXNlKSB7XG5cdFx0XHRcdFx0XHR2YXIgX29wdHMkb25FcnJvcjIsIF9vcHRzJGZvcm1hdEVycm9yO1xuXHRcdFx0XHRcdFx0KF9vcHRzJG9uRXJyb3IyID0gb3B0cy5vbkVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRvbkVycm9yMiA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3IyLmNhbGwob3B0cywge1xuXHRcdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRcdHBhdGhcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdFBST01JU0VfU1RBVFVTX1JFSkVDVEVELFxuXHRcdFx0XHRcdFx0XHQoX29wdHMkZm9ybWF0RXJyb3IgPSBvcHRzLmZvcm1hdEVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRmb3JtYXRFcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkZm9ybWF0RXJyb3IuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNhdXNlLFxuXHRcdFx0XHRcdFx0XHRcdHBhdGhcblx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKF94KSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH0oKSk7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGVuY29kZUFzeW5jSXRlcmFibGUoaXRlcmFibGUkMSwgcGF0aCkge1xuXHRcdFx0cmV0dXJuIHJlZ2lzdGVyQXN5bmMoLyogQF9fUFVSRV9fICovIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgX3JlZjIgPSAoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQyLmRlZmF1bHQpKGZ1bmN0aW9uKiAoaWR4KSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHZhciBfdXNpbmdDdHgkMSA9ICgwLCBpbXBvcnRfdXNpbmdDdHgkMS5kZWZhdWx0KSgpO1xuXHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IgPSBjaGVja01heERlcHRoKHBhdGgpO1xuXHRcdFx0XHRcdFx0aWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblx0XHRcdFx0XHRcdGNvbnN0IGl0ZXJhdG9yID0gX3VzaW5nQ3R4JDEuYShpdGVyYXRvclJlc291cmNlKGl0ZXJhYmxlJDEpKTtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y29uc3QgbmV4dCA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKGl0ZXJhdG9yLm5leHQoKSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKG5leHQuZG9uZSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0eWllbGQgW1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk4sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGVuY29kZShuZXh0LnZhbHVlLCBwYXRoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdFx0XHRpZHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQsXG5cdFx0XHRcdFx0XHRcdFx0XHRlbmNvZGUobmV4dC52YWx1ZSwgcGF0aClcblx0XHRcdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgX29wdHMkb25FcnJvcjMsIF9vcHRzJGZvcm1hdEVycm9yMjtcblx0XHRcdFx0XHRcdFx0KF9vcHRzJG9uRXJyb3IzID0gb3B0cy5vbkVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRvbkVycm9yMyA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3IzLmNhbGwob3B0cywge1xuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjYXVzZSxcblx0XHRcdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR5aWVsZCBbXG5cdFx0XHRcdFx0XHRcdFx0aWR4LFxuXHRcdFx0XHRcdFx0XHRcdEFTWU5DX0lURVJBQkxFX1NUQVRVU19FUlJPUixcblx0XHRcdFx0XHRcdFx0XHQoX29wdHMkZm9ybWF0RXJyb3IyID0gb3B0cy5mb3JtYXRFcnJvcikgPT09IG51bGwgfHwgX29wdHMkZm9ybWF0RXJyb3IyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRmb3JtYXRFcnJvcjIuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogY2F1c2UsXG5cdFx0XHRcdFx0XHRcdFx0XHRwYXRoXG5cdFx0XHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRcdFx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0XHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdFx0eWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDEuZGVmYXVsdCkoX3VzaW5nQ3R4JDEuZCgpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oX3gyKSB7XG5cdFx0XHRcdFx0cmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCkpO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBjaGVja01heERlcHRoKHBhdGgpIHtcblx0XHRcdGlmIChvcHRzLm1heERlcHRoICYmIHBhdGgubGVuZ3RoID4gb3B0cy5tYXhEZXB0aCkgcmV0dXJuIG5ldyBNYXhEZXB0aEVycm9yKHBhdGgpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdGZ1bmN0aW9uIGVuY29kZUFzeW5jKHZhbHVlLCBwYXRoKSB7XG5cdFx0XHRpZiAoaXNQcm9taXNlKHZhbHVlKSkgcmV0dXJuIFtDSFVOS19WQUxVRV9UWVBFX1BST01JU0UsIGVuY29kZVByb21pc2UodmFsdWUsIHBhdGgpXTtcblx0XHRcdGlmIChpc0FzeW5jSXRlcmFibGUodmFsdWUpKSB7XG5cdFx0XHRcdGlmIChvcHRzLm1heERlcHRoICYmIHBhdGgubGVuZ3RoID49IG9wdHMubWF4RGVwdGgpIHRocm93IG5ldyBFcnJvcihcIk1heCBkZXB0aCByZWFjaGVkXCIpO1xuXHRcdFx0XHRyZXR1cm4gW0NIVU5LX1ZBTFVFX1RZUEVfQVNZTkNfSVRFUkFCTEUsIGVuY29kZUFzeW5jSXRlcmFibGUodmFsdWUsIHBhdGgpXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRmdW5jdGlvbiBlbmNvZGUodmFsdWUsIHBhdGgpIHtcblx0XHRcdGlmICh2YWx1ZSA9PT0gdm9pZCAwKSByZXR1cm4gW1tdXTtcblx0XHRcdGNvbnN0IHJlZyA9IGVuY29kZUFzeW5jKHZhbHVlLCBwYXRoKTtcblx0XHRcdGlmIChyZWcpIHJldHVybiBbW3BsYWNlaG9sZGVyXSwgW251bGwsIC4uLnJlZ11dO1xuXHRcdFx0aWYgKCFpc1BsYWluT2JqZWN0KHZhbHVlKSkgcmV0dXJuIFtbdmFsdWVdXTtcblx0XHRcdGNvbnN0IG5ld09iaiA9IHt9O1xuXHRcdFx0Y29uc3QgYXN5bmNWYWx1ZXMgPSBbXTtcblx0XHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG5cdFx0XHRcdGNvbnN0IHRyYW5zZm9ybWVkID0gZW5jb2RlQXN5bmMoaXRlbSwgWy4uLnBhdGgsIGtleV0pO1xuXHRcdFx0XHRpZiAoIXRyYW5zZm9ybWVkKSB7XG5cdFx0XHRcdFx0bmV3T2JqW2tleV0gPSBpdGVtO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld09ialtrZXldID0gcGxhY2Vob2xkZXI7XG5cdFx0XHRcdGFzeW5jVmFsdWVzLnB1c2goW2tleSwgLi4udHJhbnNmb3JtZWRdKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBbW25ld09ial0sIC4uLmFzeW5jVmFsdWVzXTtcblx0XHR9XG5cdFx0Y29uc3QgbmV3SGVhZCA9IHt9O1xuXHRcdGZvciAoY29uc3QgW2tleSwgaXRlbV0gb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIG5ld0hlYWRba2V5XSA9IGVuY29kZShpdGVtLCBba2V5XSk7XG5cdFx0eWllbGQgbmV3SGVhZDtcblx0XHRsZXQgaXRlcmFibGUgPSBtZXJnZWRJdGVyYWJsZXM7XG5cdFx0aWYgKG9wdHMucGluZ01zKSBpdGVyYWJsZSA9IHdpdGhQaW5nKG1lcmdlZEl0ZXJhYmxlcywgb3B0cy5waW5nTXMpO1xuXHRcdHZhciBfaXRlcmF0b3JBYnJ1cHRDb21wbGV0aW9uID0gZmFsc2U7XG5cdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdFx0dmFyIF9pdGVyYXRvckVycm9yO1xuXHRcdHRyeSB7XG5cdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgaW1wb3J0X2FzeW5jSXRlcmF0b3IkMS5kZWZhdWx0KShpdGVyYWJsZSksIF9zdGVwOyBfaXRlcmF0b3JBYnJ1cHRDb21wbGV0aW9uID0gIShfc3RlcCA9IHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKF9pdGVyYXRvci5uZXh0KCkpKS5kb25lOyBfaXRlcmF0b3JBYnJ1cHRDb21wbGV0aW9uID0gZmFsc2UpIHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBfc3RlcC52YWx1ZTtcblx0XHRcdFx0eWllbGQgdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0XHRfaXRlcmF0b3JFcnJvciA9IGVycjtcblx0XHR9IGZpbmFsbHkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKF9pdGVyYXRvckFicnVwdENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yLnJldHVybiAhPSBudWxsKSB5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IkMS5kZWZhdWx0KShfaXRlcmF0b3IucmV0dXJuKCkpO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0aWYgKF9kaWRJdGVyYXRvckVycm9yKSB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gX2NyZWF0ZUJhdGNoU3RyZWFtUHJvZHVjZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbi8qKlxuKiBKU09OIExpbmVzIHN0cmVhbSBwcm9kdWNlclxuKiBAc2VlIGh0dHBzOi8vanNvbmxpbmVzLm9yZy9cbiovXG5mdW5jdGlvbiBqc29ubFN0cmVhbVByb2R1Y2VyKG9wdHMpIHtcblx0bGV0IHN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtRnJvbShjcmVhdGVCYXRjaFN0cmVhbVByb2R1Y2VyKG9wdHMpKTtcblx0Y29uc3QgeyBzZXJpYWxpemUgfSA9IG9wdHM7XG5cdGlmIChzZXJpYWxpemUpIHN0cmVhbSA9IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG5cdFx0aWYgKGNodW5rID09PSBQSU5HX1NZTSkgY29udHJvbGxlci5lbnF1ZXVlKFBJTkdfU1lNKTtcblx0XHRlbHNlIGNvbnRyb2xsZXIuZW5xdWV1ZShzZXJpYWxpemUoY2h1bmspKTtcblx0fSB9KSk7XG5cdHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2gobmV3IFRyYW5zZm9ybVN0cmVhbSh7IHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuXHRcdGlmIChjaHVuayA9PT0gUElOR19TWU0pIGNvbnRyb2xsZXIuZW5xdWV1ZShcIiBcIik7XG5cdFx0ZWxzZSBjb250cm9sbGVyLmVucXVldWUoSlNPTi5zdHJpbmdpZnkoY2h1bmspICsgXCJcXG5cIik7XG5cdH0gfSkpLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKTtcbn1cbnZhciBBc3luY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKGRhdGEpIHtcblx0XHRzdXBlcihcIlJlY2VpdmVkIGVycm9yIGZyb20gc2VydmVyXCIpO1xuXHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdH1cbn07XG5jb25zdCBub2RlSnNTdHJlYW1Ub1JlYWRlckVzcXVlID0gKHNvdXJjZSkgPT4ge1xuXHRyZXR1cm4geyBnZXRSZWFkZXIoKSB7XG5cdFx0Y29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHsgc3RhcnQoY29udHJvbGxlcikge1xuXHRcdFx0c291cmNlLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcblx0XHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcblx0XHRcdH0pO1xuXHRcdFx0c291cmNlLm9uKFwiZW5kXCIsICgpID0+IHtcblx0XHRcdFx0Y29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0fSk7XG5cdFx0XHRzb3VyY2Uub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHtcblx0XHRcdFx0Y29udHJvbGxlci5lcnJvcihlcnJvcik7XG5cdFx0XHR9KTtcblx0XHR9IH0pO1xuXHRcdHJldHVybiBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdH0gfTtcbn07XG5mdW5jdGlvbiBjcmVhdGVMaW5lQWNjdW11bGF0b3IoZnJvbSkge1xuXHRjb25zdCByZWFkZXIgPSBcImdldFJlYWRlclwiIGluIGZyb20gPyBmcm9tLmdldFJlYWRlcigpIDogbm9kZUpzU3RyZWFtVG9SZWFkZXJFc3F1ZShmcm9tKS5nZXRSZWFkZXIoKTtcblx0bGV0IGxpbmVBZ2dyZWdhdGUgPSBcIlwiO1xuXHRyZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcblx0XHRcdGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG5cdFx0XHRpZiAoZG9uZSkgY29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0ZWxzZSBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuXHRcdH0sXG5cdFx0Y2FuY2VsKCkge1xuXHRcdFx0cmV0dXJuIHJlYWRlci5jYW5jZWwoKTtcblx0XHR9XG5cdH0pLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG5cdFx0dmFyIF9wYXJ0cyRwb3A7XG5cdFx0bGluZUFnZ3JlZ2F0ZSArPSBjaHVuaztcblx0XHRjb25zdCBwYXJ0cyA9IGxpbmVBZ2dyZWdhdGUuc3BsaXQoXCJcXG5cIik7XG5cdFx0bGluZUFnZ3JlZ2F0ZSA9IChfcGFydHMkcG9wID0gcGFydHMucG9wKCkpICE9PSBudWxsICYmIF9wYXJ0cyRwb3AgIT09IHZvaWQgMCA/IF9wYXJ0cyRwb3AgOiBcIlwiO1xuXHRcdGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykgY29udHJvbGxlci5lbnF1ZXVlKHBhcnQpO1xuXHR9IH0pKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbnN1bWVyU3RyZWFtKGZyb20pIHtcblx0Y29uc3Qgc3RyZWFtID0gY3JlYXRlTGluZUFjY3VtdWxhdG9yKGZyb20pO1xuXHRsZXQgc2VudEhlYWQgPSBmYWxzZTtcblx0cmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHsgdHJhbnNmb3JtKGxpbmUsIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoIXNlbnRIZWFkKSB7XG5cdFx0XHRjb25zdCBoZWFkID0gSlNPTi5wYXJzZShsaW5lKTtcblx0XHRcdGNvbnRyb2xsZXIuZW5xdWV1ZShoZWFkKTtcblx0XHRcdHNlbnRIZWFkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgY2h1bmsgPSBKU09OLnBhcnNlKGxpbmUpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcblx0XHR9XG5cdH0gfSkpO1xufVxuLyoqXG4qIENyZWF0ZXMgYSBoYW5kbGVyIGZvciBtYW5hZ2luZyBzdHJlYW0gY29udHJvbGxlcnMgYW5kIHRoZWlyIGxpZmVjeWNsZVxuKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbXNNYW5hZ2VyKGFib3J0Q29udHJvbGxlcikge1xuXHRjb25zdCBjb250cm9sbGVyTWFwID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcblx0LyoqXG5cdCogQ2hlY2tzIGlmIHRoZXJlIGFyZSBubyBwZW5kaW5nIGNvbnRyb2xsZXJzIG9yIGRlZmVycmVkIHByb21pc2VzXG5cdCovXG5cdGZ1bmN0aW9uIGlzRW1wdHkoKSB7XG5cdFx0cmV0dXJuIEFycmF5LmZyb20oY29udHJvbGxlck1hcC52YWx1ZXMoKSkuZXZlcnkoKGMpID0+IGMuY2xvc2VkKTtcblx0fVxuXHQvKipcblx0KiBDcmVhdGVzIGEgc3RyZWFtIGNvbnRyb2xsZXJcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlU3RyZWFtQ29udHJvbGxlcigpIHtcblx0XHRsZXQgb3JpZ2luYWxDb250cm9sbGVyO1xuXHRcdGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7IHN0YXJ0KGNvbnRyb2xsZXIpIHtcblx0XHRcdG9yaWdpbmFsQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0fSB9KTtcblx0XHRjb25zdCBzdHJlYW1Db250cm9sbGVyID0ge1xuXHRcdFx0ZW5xdWV1ZTogKHYpID0+IG9yaWdpbmFsQ29udHJvbGxlci5lbnF1ZXVlKHYpLFxuXHRcdFx0Y2xvc2U6ICgpID0+IHtcblx0XHRcdFx0b3JpZ2luYWxDb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdGNsZWFyKCk7XG5cdFx0XHRcdGlmIChpc0VtcHR5KCkpIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuXHRcdFx0fSxcblx0XHRcdGNsb3NlZDogZmFsc2UsXG5cdFx0XHRnZXRSZWFkZXJSZXNvdXJjZTogKCkgPT4ge1xuXHRcdFx0XHRjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdFx0XHRcdHJldHVybiBtYWtlUmVzb3VyY2UocmVhZGVyLCAoKSA9PiB7XG5cdFx0XHRcdFx0c3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuXHRcdFx0XHRcdHJlYWRlci5yZWxlYXNlTG9jaygpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogKHJlYXNvbikgPT4ge1xuXHRcdFx0XHRvcmlnaW5hbENvbnRyb2xsZXIuZXJyb3IocmVhc29uKTtcblx0XHRcdFx0Y2xlYXIoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdFx0T2JqZWN0LmFzc2lnbihzdHJlYW1Db250cm9sbGVyLCB7XG5cdFx0XHRcdGNsb3NlZDogdHJ1ZSxcblx0XHRcdFx0Y2xvc2U6ICgpID0+IHt9LFxuXHRcdFx0XHRlbnF1ZXVlOiAoKSA9PiB7fSxcblx0XHRcdFx0Z2V0UmVhZGVyUmVzb3VyY2U6IG51bGwsXG5cdFx0XHRcdGVycm9yOiAoKSA9PiB7fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJlYW1Db250cm9sbGVyO1xuXHR9XG5cdC8qKlxuXHQqIEdldHMgb3IgY3JlYXRlcyBhIHN0cmVhbSBjb250cm9sbGVyXG5cdCovXG5cdGZ1bmN0aW9uIGdldE9yQ3JlYXRlKGNodW5rSWQpIHtcblx0XHRsZXQgYyA9IGNvbnRyb2xsZXJNYXAuZ2V0KGNodW5rSWQpO1xuXHRcdGlmICghYykge1xuXHRcdFx0YyA9IGNyZWF0ZVN0cmVhbUNvbnRyb2xsZXIoKTtcblx0XHRcdGNvbnRyb2xsZXJNYXAuc2V0KGNodW5rSWQsIGMpO1xuXHRcdH1cblx0XHRyZXR1cm4gYztcblx0fVxuXHQvKipcblx0KiBDYW5jZWxzIGFsbCBwZW5kaW5nIGNvbnRyb2xsZXJzIGFuZCByZWplY3RzIGRlZmVycmVkIHByb21pc2VzXG5cdCovXG5cdGZ1bmN0aW9uIGNhbmNlbEFsbChyZWFzb24pIHtcblx0XHRmb3IgKGNvbnN0IGNvbnRyb2xsZXIgb2YgY29udHJvbGxlck1hcC52YWx1ZXMoKSkgY29udHJvbGxlci5lcnJvcihyZWFzb24pO1xuXHR9XG5cdHJldHVybiB7XG5cdFx0Z2V0T3JDcmVhdGUsXG5cdFx0Y2FuY2VsQWxsXG5cdH07XG59XG4vKipcbiogSlNPTiBMaW5lcyBzdHJlYW0gY29uc3VtZXJcbiogQHNlZSBodHRwczovL2pzb25saW5lcy5vcmcvXG4qL1xuYXN5bmMgZnVuY3Rpb24ganNvbmxTdHJlYW1Db25zdW1lcihvcHRzKSB7XG5cdGNvbnN0IHsgZGVzZXJpYWxpemUgPSAodikgPT4gdiB9ID0gb3B0cztcblx0bGV0IHNvdXJjZSA9IGNyZWF0ZUNvbnN1bWVyU3RyZWFtKG9wdHMuZnJvbSk7XG5cdGlmIChkZXNlcmlhbGl6ZSkgc291cmNlID0gc291cmNlLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRjb250cm9sbGVyLmVucXVldWUoZGVzZXJpYWxpemUoY2h1bmspKTtcblx0fSB9KSk7XG5cdGxldCBoZWFkRGVmZXJyZWQgPSBjcmVhdGVEZWZlcnJlZCgpO1xuXHRjb25zdCBzdHJlYW1NYW5hZ2VyID0gY3JlYXRlU3RyZWFtc01hbmFnZXIob3B0cy5hYm9ydENvbnRyb2xsZXIpO1xuXHRmdW5jdGlvbiBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUpIHtcblx0XHRjb25zdCBbX3BhdGgsIHR5cGUsIGNodW5rSWRdID0gdmFsdWU7XG5cdFx0Y29uc3QgY29udHJvbGxlciA9IHN0cmVhbU1hbmFnZXIuZ2V0T3JDcmVhdGUoY2h1bmtJZCk7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlIENIVU5LX1ZBTFVFX1RZUEVfUFJPTUlTRTogcmV0dXJuIHJ1bihhc3luYyAoKSA9PiB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIF91c2luZ0N0eDMgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDEuZGVmYXVsdCkoKTtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSBfdXNpbmdDdHgzLnUoY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpKTtcblx0XHRcdFx0XHRjb25zdCB7IHZhbHVlOiB2YWx1ZSQxIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuXHRcdFx0XHRcdGNvbnN0IFtfY2h1bmtJZCwgc3RhdHVzLCBkYXRhXSA9IHZhbHVlJDE7XG5cdFx0XHRcdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdFx0XHRcdGNhc2UgUFJPTUlTRV9TVEFUVVNfRlVMRklMTEVEOiByZXR1cm4gZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0Y2FzZSBQUk9NSVNFX1NUQVRVU19SRUpFQ1RFRDpcblx0XHRcdFx0XHRcdFx0dmFyIF9vcHRzJGZvcm1hdEVycm9yMywgX29wdHMkZm9ybWF0RXJyb3I0O1xuXHRcdFx0XHRcdFx0XHR0aHJvdyAoX29wdHMkZm9ybWF0RXJyb3IzID0gKF9vcHRzJGZvcm1hdEVycm9yNCA9IG9wdHMuZm9ybWF0RXJyb3IpID09PSBudWxsIHx8IF9vcHRzJGZvcm1hdEVycm9yNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkZm9ybWF0RXJyb3I0LmNhbGwob3B0cywgeyBlcnJvcjogZGF0YSB9KSkgIT09IG51bGwgJiYgX29wdHMkZm9ybWF0RXJyb3IzICE9PSB2b2lkIDAgPyBfb3B0cyRmb3JtYXRFcnJvcjMgOiBuZXcgQXN5bmNFcnJvcihkYXRhKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdF91c2luZ0N0eDMuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdGNhc2UgQ0hVTktfVkFMVUVfVFlQRV9BU1lOQ19JVEVSQUJMRTogcmV0dXJuIHJ1bigoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQyLmRlZmF1bHQpKGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIF91c2luZ0N0eDQgPSAoMCwgaW1wb3J0X3VzaW5nQ3R4JDEuZGVmYXVsdCkoKTtcblx0XHRcdFx0XHRjb25zdCByZWFkZXIgPSBfdXNpbmdDdHg0LnUoY29udHJvbGxlci5nZXRSZWFkZXJSZXNvdXJjZSgpKTtcblx0XHRcdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgeyB2YWx1ZTogdmFsdWUkMSB9ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yJDEuZGVmYXVsdCkocmVhZGVyLnJlYWQoKSk7XG5cdFx0XHRcdFx0XHRjb25zdCBbX2NodW5rSWQsIHN0YXR1cywgZGF0YV0gPSB2YWx1ZSQxO1xuXHRcdFx0XHRcdFx0c3dpdGNoIChzdGF0dXMpIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSBBU1lOQ19JVEVSQUJMRV9TVEFUVVNfWUlFTEQ6XG5cdFx0XHRcdFx0XHRcdFx0eWllbGQgZGVjb2RlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlIEFTWU5DX0lURVJBQkxFX1NUQVRVU19SRVRVUk46IHJldHVybiBkZWNvZGUoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGNhc2UgQVNZTkNfSVRFUkFCTEVfU1RBVFVTX0VSUk9SOlxuXHRcdFx0XHRcdFx0XHRcdHZhciBfb3B0cyRmb3JtYXRFcnJvcjUsIF9vcHRzJGZvcm1hdEVycm9yNjtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyAoX29wdHMkZm9ybWF0RXJyb3I1ID0gKF9vcHRzJGZvcm1hdEVycm9yNiA9IG9wdHMuZm9ybWF0RXJyb3IpID09PSBudWxsIHx8IF9vcHRzJGZvcm1hdEVycm9yNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkZm9ybWF0RXJyb3I2LmNhbGwob3B0cywgeyBlcnJvcjogZGF0YSB9KSkgIT09IG51bGwgJiYgX29wdHMkZm9ybWF0RXJyb3I1ICE9PSB2b2lkIDAgPyBfb3B0cyRmb3JtYXRFcnJvcjUgOiBuZXcgQXN5bmNFcnJvcihkYXRhKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0XHRfdXNpbmdDdHg0LmUgPSBfO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdF91c2luZ0N0eDQuZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9XG5cdGZ1bmN0aW9uIGRlY29kZSh2YWx1ZSkge1xuXHRcdGNvbnN0IFtbZGF0YV0sIC4uLmFzeW5jUHJvcHNdID0gdmFsdWU7XG5cdFx0Zm9yIChjb25zdCB2YWx1ZSQxIG9mIGFzeW5jUHJvcHMpIHtcblx0XHRcdGNvbnN0IFtrZXldID0gdmFsdWUkMTtcblx0XHRcdGNvbnN0IGRlY29kZWQgPSBkZWNvZGVDaHVua0RlZmluaXRpb24odmFsdWUkMSk7XG5cdFx0XHRpZiAoa2V5ID09PSBudWxsKSByZXR1cm4gZGVjb2RlZDtcblx0XHRcdGRhdGFba2V5XSA9IGRlY29kZWQ7XG5cdFx0fVxuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGNvbnN0IGNsb3NlT3JBYm9ydCA9IChyZWFzb24pID0+IHtcblx0XHRoZWFkRGVmZXJyZWQgPT09IG51bGwgfHwgaGVhZERlZmVycmVkID09PSB2b2lkIDAgfHwgaGVhZERlZmVycmVkLnJlamVjdChyZWFzb24pO1xuXHRcdHN0cmVhbU1hbmFnZXIuY2FuY2VsQWxsKHJlYXNvbik7XG5cdH07XG5cdHNvdXJjZS5waXBlVG8obmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHR3cml0ZShjaHVua09ySGVhZCkge1xuXHRcdFx0aWYgKGhlYWREZWZlcnJlZCkge1xuXHRcdFx0XHRjb25zdCBoZWFkID0gY2h1bmtPckhlYWQ7XG5cdFx0XHRcdGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGNodW5rT3JIZWFkKSkge1xuXHRcdFx0XHRcdGNvbnN0IHBhcnNlZCA9IGRlY29kZSh2YWx1ZSk7XG5cdFx0XHRcdFx0aGVhZFtrZXldID0gcGFyc2VkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhlYWREZWZlcnJlZC5yZXNvbHZlKGhlYWQpO1xuXHRcdFx0XHRoZWFkRGVmZXJyZWQgPSBudWxsO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjb25zdCBjaHVuayA9IGNodW5rT3JIZWFkO1xuXHRcdFx0Y29uc3QgW2lkeF0gPSBjaHVuaztcblx0XHRcdGNvbnN0IGNvbnRyb2xsZXIgPSBzdHJlYW1NYW5hZ2VyLmdldE9yQ3JlYXRlKGlkeCk7XG5cdFx0XHRjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuXHRcdH0sXG5cdFx0Y2xvc2U6IGNsb3NlT3JBYm9ydCxcblx0XHRhYm9ydDogY2xvc2VPckFib3J0XG5cdH0pKS5jYXRjaCgoZXJyb3IpID0+IHtcblx0XHR2YXIgX29wdHMkb25FcnJvcjQ7XG5cdFx0KF9vcHRzJG9uRXJyb3I0ID0gb3B0cy5vbkVycm9yKSA9PT0gbnVsbCB8fCBfb3B0cyRvbkVycm9yNCA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3I0LmNhbGwob3B0cywgeyBlcnJvciB9KTtcblx0XHRjbG9zZU9yQWJvcnQoZXJyb3IpO1xuXHR9KTtcblx0cmV0dXJuIFthd2FpdCBoZWFkRGVmZXJyZWQucHJvbWlzZV07XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIC4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9Ab3hjLXByb2plY3QrcnVudGltZUAwLjcyLjIvbm9kZV9tb2R1bGVzL0BveGMtcHJvamVjdC9ydW50aW1lL3NyYy9oZWxwZXJzL2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUuanNcbnZhciByZXF1aXJlX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUgPSBfX2NvbW1vbkpTKHsgXCIuLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQG94Yy1wcm9qZWN0K3J1bnRpbWVAMC43Mi4yL25vZGVfbW9kdWxlcy9Ab3hjLXByb2plY3QvcnVudGltZS9zcmMvaGVscGVycy9hc3luY0dlbmVyYXRvckRlbGVnYXRlLmpzXCIoZXhwb3J0cywgbW9kdWxlKSB7XG5cdHZhciBPdmVybG9hZFlpZWxkID0gcmVxdWlyZV9PdmVybG9hZFlpZWxkKCk7XG5cdGZ1bmN0aW9uIF9hc3luY0dlbmVyYXRvckRlbGVnYXRlJDEodCkge1xuXHRcdHZhciBlID0ge30sIG4gPSAhMTtcblx0XHRmdW5jdGlvbiBwdW1wKGUkMSwgcikge1xuXHRcdFx0cmV0dXJuIG4gPSAhMCwgciA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKG4kMSkge1xuXHRcdFx0XHRuJDEodFtlJDFdKHIpKTtcblx0XHRcdH0pLCB7XG5cdFx0XHRcdGRvbmU6ICExLFxuXHRcdFx0XHR2YWx1ZTogbmV3IE92ZXJsb2FkWWllbGQociwgMSlcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBlW1widW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCJdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LCBlLm5leHQgPSBmdW5jdGlvbih0JDEpIHtcblx0XHRcdHJldHVybiBuID8gKG4gPSAhMSwgdCQxKSA6IHB1bXAoXCJuZXh0XCIsIHQkMSk7XG5cdFx0fSwgXCJmdW5jdGlvblwiID09IHR5cGVvZiB0W1widGhyb3dcIl0gJiYgKGVbXCJ0aHJvd1wiXSA9IGZ1bmN0aW9uKHQkMSkge1xuXHRcdFx0aWYgKG4pIHRocm93IG4gPSAhMSwgdCQxO1xuXHRcdFx0cmV0dXJuIHB1bXAoXCJ0aHJvd1wiLCB0JDEpO1xuXHRcdH0pLCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHRbXCJyZXR1cm5cIl0gJiYgKGVbXCJyZXR1cm5cIl0gPSBmdW5jdGlvbih0JDEpIHtcblx0XHRcdHJldHVybiBuID8gKG4gPSAhMSwgdCQxKSA6IHB1bXAoXCJyZXR1cm5cIiwgdCQxKTtcblx0XHR9KSwgZTtcblx0fVxuXHRtb2R1bGUuZXhwb3J0cyA9IF9hc3luY0dlbmVyYXRvckRlbGVnYXRlJDEsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbn0gfSk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvc3RyZWFtL3NzZS50c1xudmFyIGltcG9ydF9hc3luY0l0ZXJhdG9yID0gX190b0VTTShyZXF1aXJlX2FzeW5jSXRlcmF0b3IoKSwgMSk7XG52YXIgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IgPSBfX3RvRVNNKHJlcXVpcmVfYXdhaXRBc3luY0dlbmVyYXRvcigpLCAxKTtcbnZhciBpbXBvcnRfd3JhcEFzeW5jR2VuZXJhdG9yJDEgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF9hc3luY0dlbmVyYXRvckRlbGVnYXRlID0gX190b0VTTShyZXF1aXJlX2FzeW5jR2VuZXJhdG9yRGVsZWdhdGUoKSwgMSk7XG52YXIgaW1wb3J0X3VzaW5nQ3R4ID0gX190b0VTTShyZXF1aXJlX3VzaW5nQ3R4KCksIDEpO1xuY29uc3QgUElOR19FVkVOVCA9IFwicGluZ1wiO1xuY29uc3QgU0VSSUFMSVpFRF9FUlJPUl9FVkVOVCA9IFwic2VyaWFsaXplZC1lcnJvclwiO1xuY29uc3QgQ09OTkVDVEVEX0VWRU5UID0gXCJjb25uZWN0ZWRcIjtcbmNvbnN0IFJFVFVSTl9FVkVOVCA9IFwicmV0dXJuXCI7XG4vKipcbipcbiogQHNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZXJ2ZXItc2VudC1ldmVudHMuaHRtbFxuKi9cbmZ1bmN0aW9uIHNzZVN0cmVhbVByb2R1Y2VyKG9wdHMpIHtcblx0dmFyIF9vcHRzJHBpbmckZW5hYmxlZCwgX29wdHMkcGluZywgX29wdHMkcGluZyRpbnRlcnZhbE1zLCBfb3B0cyRwaW5nMiwgX29wdHMkY2xpZW50O1xuXHRjb25zdCB7IHNlcmlhbGl6ZSA9IGlkZW50aXR5IH0gPSBvcHRzO1xuXHRjb25zdCBwaW5nID0ge1xuXHRcdGVuYWJsZWQ6IChfb3B0cyRwaW5nJGVuYWJsZWQgPSAoX29wdHMkcGluZyA9IG9wdHMucGluZykgPT09IG51bGwgfHwgX29wdHMkcGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkcGluZy5lbmFibGVkKSAhPT0gbnVsbCAmJiBfb3B0cyRwaW5nJGVuYWJsZWQgIT09IHZvaWQgMCA/IF9vcHRzJHBpbmckZW5hYmxlZCA6IGZhbHNlLFxuXHRcdGludGVydmFsTXM6IChfb3B0cyRwaW5nJGludGVydmFsTXMgPSAoX29wdHMkcGluZzIgPSBvcHRzLnBpbmcpID09PSBudWxsIHx8IF9vcHRzJHBpbmcyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRwaW5nMi5pbnRlcnZhbE1zKSAhPT0gbnVsbCAmJiBfb3B0cyRwaW5nJGludGVydmFsTXMgIT09IHZvaWQgMCA/IF9vcHRzJHBpbmckaW50ZXJ2YWxNcyA6IDFlM1xuXHR9O1xuXHRjb25zdCBjbGllbnQgPSAoX29wdHMkY2xpZW50ID0gb3B0cy5jbGllbnQpICE9PSBudWxsICYmIF9vcHRzJGNsaWVudCAhPT0gdm9pZCAwID8gX29wdHMkY2xpZW50IDoge307XG5cdGlmIChwaW5nLmVuYWJsZWQgJiYgY2xpZW50LnJlY29ubmVjdEFmdGVySW5hY3Rpdml0eU1zICYmIHBpbmcuaW50ZXJ2YWxNcyA+IGNsaWVudC5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcykgdGhyb3cgbmV3IEVycm9yKGBQaW5nIGludGVydmFsIG11c3QgYmUgbGVzcyB0aGFuIGNsaWVudCByZWNvbm5lY3QgaW50ZXJ2YWwgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZWNvbm5lY3Rpb24gLSBwaW5nLmludGVydmFsTXM6ICR7cGluZy5pbnRlcnZhbE1zfSBjbGllbnQucmVjb25uZWN0QWZ0ZXJJbmFjdGl2aXR5TXM6ICR7Y2xpZW50LnJlY29ubmVjdEFmdGVySW5hY3Rpdml0eU1zfWApO1xuXHRmdW5jdGlvbiBnZW5lcmF0b3IoKSB7XG5cdFx0cmV0dXJuIF9nZW5lcmF0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXHRmdW5jdGlvbiBfZ2VuZXJhdG9yKCkge1xuXHRcdF9nZW5lcmF0b3IgPSAoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvciQxLmRlZmF1bHQpKGZ1bmN0aW9uKiAoKSB7XG5cdFx0XHR5aWVsZCB7XG5cdFx0XHRcdGV2ZW50OiBDT05ORUNURURfRVZFTlQsXG5cdFx0XHRcdGRhdGE6IEpTT04uc3RyaW5naWZ5KGNsaWVudClcblx0XHRcdH07XG5cdFx0XHRsZXQgaXRlcmFibGUgPSBvcHRzLmRhdGE7XG5cdFx0XHRpZiAob3B0cy5lbWl0QW5kRW5kSW1tZWRpYXRlbHkpIGl0ZXJhYmxlID0gdGFrZVdpdGhHcmFjZShpdGVyYWJsZSwge1xuXHRcdFx0XHRjb3VudDogMSxcblx0XHRcdFx0Z3JhY2VQZXJpb2RNczogMVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAob3B0cy5tYXhEdXJhdGlvbk1zICYmIG9wdHMubWF4RHVyYXRpb25NcyA+IDAgJiYgb3B0cy5tYXhEdXJhdGlvbk1zICE9PSBJbmZpbml0eSkgaXRlcmFibGUgPSB3aXRoTWF4RHVyYXRpb24oaXRlcmFibGUsIHsgbWF4RHVyYXRpb25Nczogb3B0cy5tYXhEdXJhdGlvbk1zIH0pO1xuXHRcdFx0aWYgKHBpbmcuZW5hYmxlZCAmJiBwaW5nLmludGVydmFsTXMgIT09IEluZmluaXR5ICYmIHBpbmcuaW50ZXJ2YWxNcyA+IDApIGl0ZXJhYmxlID0gd2l0aFBpbmcoaXRlcmFibGUsIHBpbmcuaW50ZXJ2YWxNcyk7XG5cdFx0XHRsZXQgdmFsdWU7XG5cdFx0XHRsZXQgY2h1bms7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiA9IGZhbHNlO1xuXHRcdFx0dmFyIF9kaWRJdGVyYXRvckVycm9yID0gZmFsc2U7XG5cdFx0XHR2YXIgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRmb3IgKHZhciBfaXRlcmF0b3IgPSAoMCwgaW1wb3J0X2FzeW5jSXRlcmF0b3IuZGVmYXVsdCkoaXRlcmFibGUpLCBfc3RlcDsgX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiA9ICEoX3N0ZXAgPSB5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IuZGVmYXVsdCkoX2l0ZXJhdG9yLm5leHQoKSkpLmRvbmU7IF9pdGVyYXRvckFicnVwdENvbXBsZXRpb24gPSBmYWxzZSkge1xuXHRcdFx0XHRcdHZhbHVlID0gX3N0ZXAudmFsdWU7XG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlID09PSBQSU5HX1NZTSkge1xuXHRcdFx0XHRcdFx0XHR5aWVsZCB7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQ6IFBJTkdfRVZFTlQsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogXCJcIlxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNodW5rID0gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpID8ge1xuXHRcdFx0XHRcdFx0XHRpZDogdmFsdWVbMF0sXG5cdFx0XHRcdFx0XHRcdGRhdGE6IHZhbHVlWzFdXG5cdFx0XHRcdFx0XHR9IDogeyBkYXRhOiB2YWx1ZSB9O1xuXHRcdFx0XHRcdFx0Y2h1bmsuZGF0YSA9IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShjaHVuay5kYXRhKSk7XG5cdFx0XHRcdFx0XHR5aWVsZCBjaHVuaztcblx0XHRcdFx0XHRcdHZhbHVlID0gbnVsbDtcblx0XHRcdFx0XHRcdGNodW5rID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGVycikge1xuXHRcdFx0XHRfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG5cdFx0XHRcdF9pdGVyYXRvckVycm9yID0gZXJyO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoX2l0ZXJhdG9yQWJydXB0Q29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHlpZWxkICgwLCBpbXBvcnRfYXdhaXRBc3luY0dlbmVyYXRvci5kZWZhdWx0KShfaXRlcmF0b3IucmV0dXJuKCkpO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmIChfZGlkSXRlcmF0b3JFcnJvcikgdGhyb3cgX2l0ZXJhdG9yRXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gX2dlbmVyYXRvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9XG5cdGZ1bmN0aW9uIGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkge1xuXHRcdHJldHVybiBfZ2VuZXJhdG9yV2l0aEVycm9ySGFuZGxpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fVxuXHRmdW5jdGlvbiBfZ2VuZXJhdG9yV2l0aEVycm9ySGFuZGxpbmcoKSB7XG5cdFx0X2dlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nID0gKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMS5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0eWllbGQqICgwLCBpbXBvcnRfYXN5bmNHZW5lcmF0b3JEZWxlZ2F0ZS5kZWZhdWx0KSgoMCwgaW1wb3J0X2FzeW5jSXRlcmF0b3IuZGVmYXVsdCkoZ2VuZXJhdG9yKCkpKTtcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdGV2ZW50OiBSRVRVUk5fRVZFTlQsXG5cdFx0XHRcdFx0ZGF0YTogXCJcIlxuXHRcdFx0XHR9O1xuXHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0dmFyIF9vcHRzJGZvcm1hdEVycm9yLCBfb3B0cyRmb3JtYXRFcnJvcjI7XG5cdFx0XHRcdGlmIChpc0Fib3J0RXJyb3IoY2F1c2UpKSByZXR1cm47XG5cdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpO1xuXHRcdFx0XHRjb25zdCBkYXRhID0gKF9vcHRzJGZvcm1hdEVycm9yID0gKF9vcHRzJGZvcm1hdEVycm9yMiA9IG9wdHMuZm9ybWF0RXJyb3IpID09PSBudWxsIHx8IF9vcHRzJGZvcm1hdEVycm9yMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkZm9ybWF0RXJyb3IyLmNhbGwob3B0cywgeyBlcnJvciB9KSkgIT09IG51bGwgJiYgX29wdHMkZm9ybWF0RXJyb3IgIT09IHZvaWQgMCA/IF9vcHRzJGZvcm1hdEVycm9yIDogbnVsbDtcblx0XHRcdFx0eWllbGQge1xuXHRcdFx0XHRcdGV2ZW50OiBTRVJJQUxJWkVEX0VSUk9SX0VWRU5ULFxuXHRcdFx0XHRcdGRhdGE6IEpTT04uc3RyaW5naWZ5KHNlcmlhbGl6ZShkYXRhKSlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gX2dlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cblx0Y29uc3Qgc3RyZWFtID0gcmVhZGFibGVTdHJlYW1Gcm9tKGdlbmVyYXRvcldpdGhFcnJvckhhbmRsaW5nKCkpO1xuXHRyZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0oeyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcblx0XHRpZiAoXCJldmVudFwiIGluIGNodW5rKSBjb250cm9sbGVyLmVucXVldWUoYGV2ZW50OiAke2NodW5rLmV2ZW50fVxcbmApO1xuXHRcdGlmIChcImRhdGFcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBkYXRhOiAke2NodW5rLmRhdGF9XFxuYCk7XG5cdFx0aWYgKFwiaWRcIiBpbiBjaHVuaykgY29udHJvbGxlci5lbnF1ZXVlKGBpZDogJHtjaHVuay5pZH1cXG5gKTtcblx0XHRpZiAoXCJjb21tZW50XCIgaW4gY2h1bmspIGNvbnRyb2xsZXIuZW5xdWV1ZShgOiAke2NodW5rLmNvbW1lbnR9XFxuYCk7XG5cdFx0Y29udHJvbGxlci5lbnF1ZXVlKFwiXFxuXFxuXCIpO1xuXHR9IH0pKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG59XG5hc3luYyBmdW5jdGlvbiB3aXRoVGltZW91dChvcHRzKSB7XG5cdHRyeSB7XG5cdFx0dmFyIF91c2luZ0N0eCQxID0gKDAsIGltcG9ydF91c2luZ0N0eC5kZWZhdWx0KSgpO1xuXHRcdGNvbnN0IHRpbWVvdXRQcm9taXNlID0gX3VzaW5nQ3R4JDEudSh0aW1lclJlc291cmNlKG9wdHMudGltZW91dE1zKSk7XG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgVW5wcm9taXNlLnJhY2UoW29wdHMucHJvbWlzZSwgdGltZW91dFByb21pc2Uuc3RhcnQoKV0pO1xuXHRcdGlmIChyZXMgPT09IGRpc3Bvc2FibGVQcm9taXNlVGltZXJSZXN1bHQpIHJldHVybiBhd2FpdCBvcHRzLm9uVGltZW91dCgpO1xuXHRcdHJldHVybiByZXM7XG5cdH0gY2F0Y2ggKF8pIHtcblx0XHRfdXNpbmdDdHgkMS5lID0gXztcblx0fSBmaW5hbGx5IHtcblx0XHRfdXNpbmdDdHgkMS5kKCk7XG5cdH1cbn1cbi8qKlxuKiBAc2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NlcnZlci1zZW50LWV2ZW50cy5odG1sXG4qL1xuZnVuY3Rpb24gc3NlU3RyZWFtQ29uc3VtZXIob3B0cykge1xuXHRjb25zdCB7IGRlc2VyaWFsaXplID0gKHYpID0+IHYgfSA9IG9wdHM7XG5cdGxldCBjbGllbnRPcHRpb25zID0ge307XG5cdGNvbnN0IHNpZ25hbCA9IG9wdHMuc2lnbmFsO1xuXHRsZXQgX2VzID0gbnVsbDtcblx0Y29uc3QgY3JlYXRlU3RyZWFtID0gKCkgPT4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcblx0XHRhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG5cdFx0XHRjb25zdCBbdXJsLCBpbml0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtvcHRzLnVybCgpLCBvcHRzLmluaXQoKV0pO1xuXHRcdFx0Y29uc3QgZXZlbnRTb3VyY2UgPSBfZXMgPSBuZXcgb3B0cy5FdmVudFNvdXJjZSh1cmwsIGluaXQpO1xuXHRcdFx0Y29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0dHlwZTogXCJjb25uZWN0aW5nXCIsXG5cdFx0XHRcdGV2ZW50U291cmNlOiBfZXMsXG5cdFx0XHRcdGV2ZW50OiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoQ09OTkVDVEVEX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb25zdCBvcHRpb25zID0gSlNPTi5wYXJzZShtc2cuZGF0YSk7XG5cdFx0XHRcdGNsaWVudE9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiY29ubmVjdGVkXCIsXG5cdFx0XHRcdFx0b3B0aW9ucyxcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihTRVJJQUxJWkVEX0VSUk9SX0VWRU5ULCAoX21zZykgPT4ge1xuXHRcdFx0XHRjb25zdCBtc2cgPSBfbXNnO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwic2VyaWFsaXplZC1lcnJvclwiLFxuXHRcdFx0XHRcdGVycm9yOiBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSksXG5cdFx0XHRcdFx0ZXZlbnRTb3VyY2Vcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoUElOR19FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwicGluZ1wiLFxuXHRcdFx0XHRcdGV2ZW50U291cmNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0XHRldmVudFNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFJFVFVSTl9FVkVOVCwgKCkgPT4ge1xuXHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRjb250cm9sbGVyLmNsb3NlKCk7XG5cdFx0XHRcdF9lcyA9IG51bGw7XG5cdFx0XHR9KTtcblx0XHRcdGV2ZW50U291cmNlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCAoZXZlbnQpID0+IHtcblx0XHRcdFx0aWYgKGV2ZW50U291cmNlLnJlYWR5U3RhdGUgPT09IGV2ZW50U291cmNlLkNMT1NFRCkgY29udHJvbGxlci5lcnJvcihldmVudCk7XG5cdFx0XHRcdGVsc2UgY29udHJvbGxlci5lbnF1ZXVlKHtcblx0XHRcdFx0XHR0eXBlOiBcImNvbm5lY3RpbmdcIixcblx0XHRcdFx0XHRldmVudFNvdXJjZSxcblx0XHRcdFx0XHRldmVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0ZXZlbnRTb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKF9tc2cpID0+IHtcblx0XHRcdFx0Y29uc3QgbXNnID0gX21zZztcblx0XHRcdFx0Y29uc3QgY2h1bmsgPSBkZXNlcmlhbGl6ZShKU09OLnBhcnNlKG1zZy5kYXRhKSk7XG5cdFx0XHRcdGNvbnN0IGRlZiA9IHsgZGF0YTogY2h1bmsgfTtcblx0XHRcdFx0aWYgKG1zZy5sYXN0RXZlbnRJZCkgZGVmLmlkID0gbXNnLmxhc3RFdmVudElkO1xuXHRcdFx0XHRjb250cm9sbGVyLmVucXVldWUoe1xuXHRcdFx0XHRcdHR5cGU6IFwiZGF0YVwiLFxuXHRcdFx0XHRcdGRhdGE6IGRlZixcblx0XHRcdFx0XHRldmVudFNvdXJjZVxuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdFx0Y29uc3Qgb25BYm9ydCA9ICgpID0+IHtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRldmVudFNvdXJjZS5jbG9zZSgpO1xuXHRcdFx0XHRcdGNvbnRyb2xsZXIuY2xvc2UoKTtcblx0XHRcdFx0fSBjYXRjaCAoX3VudXNlZCkge31cblx0XHRcdH07XG5cdFx0XHRpZiAoc2lnbmFsLmFib3J0ZWQpIG9uQWJvcnQoKTtcblx0XHRcdGVsc2Ugc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCBvbkFib3J0KTtcblx0XHR9LFxuXHRcdGNhbmNlbCgpIHtcblx0XHRcdF9lcyA9PT0gbnVsbCB8fCBfZXMgPT09IHZvaWQgMCB8fCBfZXMuY2xvc2UoKTtcblx0XHR9XG5cdH0pO1xuXHRjb25zdCBnZXRTdHJlYW1SZXNvdXJjZSA9ICgpID0+IHtcblx0XHRsZXQgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG5cdFx0bGV0IHJlYWRlciA9IHN0cmVhbS5nZXRSZWFkZXIoKTtcblx0XHRhc3luYyBmdW5jdGlvbiBkaXNwb3NlKCkge1xuXHRcdFx0YXdhaXQgcmVhZGVyLmNhbmNlbCgpO1xuXHRcdFx0X2VzID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG1ha2VBc3luY1Jlc291cmNlKHtcblx0XHRcdHJlYWQoKSB7XG5cdFx0XHRcdHJldHVybiByZWFkZXIucmVhZCgpO1xuXHRcdFx0fSxcblx0XHRcdGFzeW5jIHJlY3JlYXRlKCkge1xuXHRcdFx0XHRhd2FpdCBkaXNwb3NlKCk7XG5cdFx0XHRcdHN0cmVhbSA9IGNyZWF0ZVN0cmVhbSgpO1xuXHRcdFx0XHRyZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG5cdFx0XHR9XG5cdFx0fSwgZGlzcG9zZSk7XG5cdH07XG5cdHJldHVybiBydW4oKDAsIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IkMS5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdHRyeSB7XG5cdFx0XHR2YXIgX3VzaW5nQ3R4MyA9ICgwLCBpbXBvcnRfdXNpbmdDdHguZGVmYXVsdCkoKTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IF91c2luZ0N0eDMuYShnZXRTdHJlYW1SZXNvdXJjZSgpKTtcblx0XHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRcdGxldCBwcm9taXNlID0gc3RyZWFtLnJlYWQoKTtcblx0XHRcdFx0Y29uc3QgdGltZW91dE1zID0gY2xpZW50T3B0aW9ucy5yZWNvbm5lY3RBZnRlckluYWN0aXZpdHlNcztcblx0XHRcdFx0aWYgKHRpbWVvdXRNcykgcHJvbWlzZSA9IHdpdGhUaW1lb3V0KHtcblx0XHRcdFx0XHRwcm9taXNlLFxuXHRcdFx0XHRcdHRpbWVvdXRNcyxcblx0XHRcdFx0XHRvblRpbWVvdXQ6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdGNvbnN0IHJlcyA9IHtcblx0XHRcdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcInRpbWVvdXRcIixcblx0XHRcdFx0XHRcdFx0XHRtczogdGltZW91dE1zLFxuXHRcdFx0XHRcdFx0XHRcdGV2ZW50U291cmNlOiBfZXNcblx0XHRcdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRcdFx0ZG9uZTogZmFsc2Vcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRhd2FpdCBzdHJlYW0ucmVjcmVhdGUoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0Y29uc3QgcmVzdWx0ID0geWllbGQgKDAsIGltcG9ydF9hd2FpdEFzeW5jR2VuZXJhdG9yLmRlZmF1bHQpKHByb21pc2UpO1xuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdHlpZWxkIHJlc3VsdC52YWx1ZTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChfKSB7XG5cdFx0XHRfdXNpbmdDdHgzLmUgPSBfO1xuXHRcdH0gZmluYWxseSB7XG5cdFx0XHR5aWVsZCAoMCwgaW1wb3J0X2F3YWl0QXN5bmNHZW5lcmF0b3IuZGVmYXVsdCkoX3VzaW5nQ3R4My5kKCkpO1xuXHRcdH1cblx0fSkpO1xufVxuY29uc3Qgc3NlSGVhZGVycyA9IHtcblx0XCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuXHRcIkNhY2hlLUNvbnRyb2xcIjogXCJuby1jYWNoZSwgbm8tdHJhbnNmb3JtXCIsXG5cdFwiWC1BY2NlbC1CdWZmZXJpbmdcIjogXCJub1wiLFxuXHRDb25uZWN0aW9uOiBcImtlZXAtYWxpdmVcIlxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9odHRwL3Jlc29sdmVSZXNwb25zZS50c1xudmFyIGltcG9ydF93cmFwQXN5bmNHZW5lcmF0b3IgPSBfX3RvRVNNKHJlcXVpcmVfd3JhcEFzeW5jR2VuZXJhdG9yKCksIDEpO1xudmFyIGltcG9ydF9vYmplY3RTcHJlYWQyID0gX190b0VTTShyZXF1aXJlX29iamVjdFNwcmVhZDIoKSwgMSk7XG5mdW5jdGlvbiBlcnJvclRvQXN5bmNJdGVyYWJsZShlcnIpIHtcblx0cmV0dXJuIHJ1bigoMCwgaW1wb3J0X3dyYXBBc3luY0dlbmVyYXRvci5kZWZhdWx0KShmdW5jdGlvbiogKCkge1xuXHRcdHRocm93IGVycjtcblx0fSkpO1xufVxuY29uc3QgVFlQRV9BQ0NFUFRFRF9NRVRIT0RfTUFQID0ge1xuXHRtdXRhdGlvbjogW1wiUE9TVFwiXSxcblx0cXVlcnk6IFtcIkdFVFwiXSxcblx0c3Vic2NyaXB0aW9uOiBbXCJHRVRcIl1cbn07XG5jb25zdCBUWVBFX0FDQ0VQVEVEX01FVEhPRF9NQVBfV0lUSF9NRVRIT0RfT1ZFUlJJREUgPSB7XG5cdG11dGF0aW9uOiBbXCJQT1NUXCJdLFxuXHRxdWVyeTogW1wiR0VUXCIsIFwiUE9TVFwiXSxcblx0c3Vic2NyaXB0aW9uOiBbXCJHRVRcIiwgXCJQT1NUXCJdXG59O1xuZnVuY3Rpb24gaW5pdFJlc3BvbnNlKGluaXRPcHRzKSB7XG5cdHZhciBfcmVzcG9uc2VNZXRhLCBfaW5mbyRjYWxscyRmaW5kJHByb2MsIF9pbmZvJGNhbGxzJGZpbmQ7XG5cdGNvbnN0IHsgY3R4LCBpbmZvLCByZXNwb25zZU1ldGEsIHVudHJhbnNmb3JtZWRKU09OLCBlcnJvcnMgPSBbXSwgaGVhZGVycyB9ID0gaW5pdE9wdHM7XG5cdGxldCBzdGF0dXMgPSB1bnRyYW5zZm9ybWVkSlNPTiA/IGdldEhUVFBTdGF0dXNDb2RlKHVudHJhbnNmb3JtZWRKU09OKSA6IDIwMDtcblx0Y29uc3QgZWFnZXJHZW5lcmF0aW9uID0gIXVudHJhbnNmb3JtZWRKU09OO1xuXHRjb25zdCBkYXRhID0gZWFnZXJHZW5lcmF0aW9uID8gW10gOiBBcnJheS5pc0FycmF5KHVudHJhbnNmb3JtZWRKU09OKSA/IHVudHJhbnNmb3JtZWRKU09OIDogW3VudHJhbnNmb3JtZWRKU09OXTtcblx0Y29uc3QgbWV0YSA9IChfcmVzcG9uc2VNZXRhID0gcmVzcG9uc2VNZXRhID09PSBudWxsIHx8IHJlc3BvbnNlTWV0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VNZXRhKHtcblx0XHRjdHgsXG5cdFx0aW5mbyxcblx0XHRwYXRoczogaW5mbyA9PT0gbnVsbCB8fCBpbmZvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbmZvLmNhbGxzLm1hcCgoY2FsbCkgPT4gY2FsbC5wYXRoKSxcblx0XHRkYXRhLFxuXHRcdGVycm9ycyxcblx0XHRlYWdlckdlbmVyYXRpb24sXG5cdFx0dHlwZTogKF9pbmZvJGNhbGxzJGZpbmQkcHJvYyA9IGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwIHx8IChfaW5mbyRjYWxscyRmaW5kID0gaW5mby5jYWxscy5maW5kKChjYWxsKSA9PiB7XG5cdFx0XHR2YXIgX2NhbGwkcHJvY2VkdXJlO1xuXHRcdFx0cmV0dXJuIChfY2FsbCRwcm9jZWR1cmUgPSBjYWxsLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX2NhbGwkcHJvY2VkdXJlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbCRwcm9jZWR1cmUuX2RlZi50eXBlO1xuXHRcdH0pKSA9PT0gbnVsbCB8fCBfaW5mbyRjYWxscyRmaW5kID09PSB2b2lkIDAgfHwgKF9pbmZvJGNhbGxzJGZpbmQgPSBfaW5mbyRjYWxscyRmaW5kLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX2luZm8kY2FsbHMkZmluZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luZm8kY2FsbHMkZmluZC5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9pbmZvJGNhbGxzJGZpbmQkcHJvYyAhPT0gdm9pZCAwID8gX2luZm8kY2FsbHMkZmluZCRwcm9jIDogXCJ1bmtub3duXCJcblx0fSkpICE9PSBudWxsICYmIF9yZXNwb25zZU1ldGEgIT09IHZvaWQgMCA/IF9yZXNwb25zZU1ldGEgOiB7fTtcblx0aWYgKG1ldGEuaGVhZGVycykge1xuXHRcdGlmIChtZXRhLmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzKSBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtZXRhLmhlYWRlcnMuZW50cmllcygpKSBoZWFkZXJzLmFwcGVuZChrZXksIHZhbHVlKTtcblx0XHRlbHNlXG4gLyoqXG5cdFx0KiBAZGVwcmVjYXRlZCwgZGVsZXRlIGluIHYxMlxuXHRcdCovXG5cdFx0Zm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobWV0YS5oZWFkZXJzKSkgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIGhlYWRlcnMuYXBwZW5kKGtleSwgdik7XG5cdFx0ZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSBoZWFkZXJzLnNldChrZXksIHZhbHVlKTtcblx0fVxuXHRpZiAobWV0YS5zdGF0dXMpIHN0YXR1cyA9IG1ldGEuc3RhdHVzO1xuXHRyZXR1cm4geyBzdGF0dXMgfTtcbn1cbmZ1bmN0aW9uIGNhdWdodEVycm9yVG9EYXRhKGNhdXNlLCBlcnJvck9wdHMpIHtcblx0Y29uc3QgeyByb3V0ZXIsIHJlcSwgb25FcnJvciB9ID0gZXJyb3JPcHRzLm9wdHM7XG5cdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpO1xuXHRvbkVycm9yID09PSBudWxsIHx8IG9uRXJyb3IgPT09IHZvaWQgMCB8fCBvbkVycm9yKHtcblx0XHRlcnJvcixcblx0XHRwYXRoOiBlcnJvck9wdHMucGF0aCxcblx0XHRpbnB1dDogZXJyb3JPcHRzLmlucHV0LFxuXHRcdGN0eDogZXJyb3JPcHRzLmN0eCxcblx0XHR0eXBlOiBlcnJvck9wdHMudHlwZSxcblx0XHRyZXFcblx0fSk7XG5cdGNvbnN0IHVudHJhbnNmb3JtZWRKU09OID0geyBlcnJvcjogZ2V0RXJyb3JTaGFwZSh7XG5cdFx0Y29uZmlnOiByb3V0ZXIuX2RlZi5fY29uZmlnLFxuXHRcdGVycm9yLFxuXHRcdHR5cGU6IGVycm9yT3B0cy50eXBlLFxuXHRcdHBhdGg6IGVycm9yT3B0cy5wYXRoLFxuXHRcdGlucHV0OiBlcnJvck9wdHMuaW5wdXQsXG5cdFx0Y3R4OiBlcnJvck9wdHMuY3R4XG5cdH0pIH07XG5cdGNvbnN0IHRyYW5zZm9ybWVkSlNPTiA9IHRyYW5zZm9ybVRSUENSZXNwb25zZShyb3V0ZXIuX2RlZi5fY29uZmlnLCB1bnRyYW5zZm9ybWVkSlNPTik7XG5cdGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1lZEpTT04pO1xuXHRyZXR1cm4ge1xuXHRcdGVycm9yLFxuXHRcdHVudHJhbnNmb3JtZWRKU09OLFxuXHRcdGJvZHlcblx0fTtcbn1cbi8qKlxuKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgc3RyZWFtLWxpa2Ugb2JqZWN0XG4qIC0gaWYgaXQncyBhbiBhc3luYyBpdGVyYWJsZVxuKiAtIGlmIGl0J3MgYW4gb2JqZWN0IHdpdGggYXN5bmMgaXRlcmFibGVzIG9yIHByb21pc2VzXG4qL1xuZnVuY3Rpb24gaXNEYXRhU3RyZWFtKHYpIHtcblx0aWYgKCFpc09iamVjdCh2KSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoaXNBc3luY0l0ZXJhYmxlKHYpKSByZXR1cm4gdHJ1ZTtcblx0cmV0dXJuIE9iamVjdC52YWx1ZXModikuc29tZShpc1Byb21pc2UpIHx8IE9iamVjdC52YWx1ZXModikuc29tZShpc0FzeW5jSXRlcmFibGUpO1xufVxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZVJlc3BvbnNlKG9wdHMpIHtcblx0dmFyIF9yZWYsIF9vcHRzJGFsbG93QmF0Y2hpbmcsIF9vcHRzJGJhdGNoaW5nLCBfb3B0cyRhbGxvd01ldGhvZE92ZXIsIF9jb25maWckc3NlJGVuYWJsZWQsIF9jb25maWckc3NlO1xuXHRjb25zdCB7IHJvdXRlciwgcmVxIH0gPSBvcHRzO1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoW1tcInZhcnlcIiwgXCJ0cnBjLWFjY2VwdFwiXV0pO1xuXHRjb25zdCBjb25maWcgPSByb3V0ZXIuX2RlZi5fY29uZmlnO1xuXHRjb25zdCB1cmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuXHRpZiAocmVxLm1ldGhvZCA9PT0gXCJIRUFEXCIpIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwgeyBzdGF0dXM6IDIwNCB9KTtcblx0Y29uc3QgYWxsb3dCYXRjaGluZyA9IChfcmVmID0gKF9vcHRzJGFsbG93QmF0Y2hpbmcgPSBvcHRzLmFsbG93QmF0Y2hpbmcpICE9PSBudWxsICYmIF9vcHRzJGFsbG93QmF0Y2hpbmcgIT09IHZvaWQgMCA/IF9vcHRzJGFsbG93QmF0Y2hpbmcgOiAoX29wdHMkYmF0Y2hpbmcgPSBvcHRzLmJhdGNoaW5nKSA9PT0gbnVsbCB8fCBfb3B0cyRiYXRjaGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkYmF0Y2hpbmcuZW5hYmxlZCkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IHRydWU7XG5cdGNvbnN0IGFsbG93TWV0aG9kT3ZlcnJpZGUgPSAoKF9vcHRzJGFsbG93TWV0aG9kT3ZlciA9IG9wdHMuYWxsb3dNZXRob2RPdmVycmlkZSkgIT09IG51bGwgJiYgX29wdHMkYWxsb3dNZXRob2RPdmVyICE9PSB2b2lkIDAgPyBfb3B0cyRhbGxvd01ldGhvZE92ZXIgOiBmYWxzZSkgJiYgcmVxLm1ldGhvZCA9PT0gXCJQT1NUXCI7XG5cdGNvbnN0IGluZm9UdXBsZSA9IGF3YWl0IHJ1bihhc3luYyAoKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdHJldHVybiBbdm9pZCAwLCBhd2FpdCBnZXRSZXF1ZXN0SW5mbyh7XG5cdFx0XHRcdHJlcSxcblx0XHRcdFx0cGF0aDogZGVjb2RlVVJJQ29tcG9uZW50KG9wdHMucGF0aCksXG5cdFx0XHRcdHJvdXRlcixcblx0XHRcdFx0c2VhcmNoUGFyYW1zOiB1cmwuc2VhcmNoUGFyYW1zLFxuXHRcdFx0XHRoZWFkZXJzOiBvcHRzLnJlcS5oZWFkZXJzLFxuXHRcdFx0XHR1cmxcblx0XHRcdH0pXTtcblx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0cmV0dXJuIFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHZvaWQgMF07XG5cdFx0fVxuXHR9KTtcblx0Y29uc3QgY3R4TWFuYWdlciA9IHJ1bigoKSA9PiB7XG5cdFx0bGV0IHJlc3VsdCA9IHZvaWQgMDtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWVPclVuZGVmaW5lZDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoIXJlc3VsdCkgcmV0dXJuIHZvaWQgMDtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdFsxXTtcblx0XHRcdH0sXG5cdFx0XHR2YWx1ZTogKCkgPT4ge1xuXHRcdFx0XHRjb25zdCBbZXJyLCBjdHhdID0gcmVzdWx0O1xuXHRcdFx0XHRpZiAoZXJyKSB0aHJvdyBlcnI7XG5cdFx0XHRcdHJldHVybiBjdHg7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlOiBhc3luYyAoaW5mbykgPT4ge1xuXHRcdFx0XHRpZiAocmVzdWx0KSB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlIC0gcmVwb3J0IGEgYnVnIGluIHRSUENcIik7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y29uc3QgY3R4ID0gYXdhaXQgb3B0cy5jcmVhdGVDb250ZXh0KHsgaW5mbyB9KTtcblx0XHRcdFx0XHRyZXN1bHQgPSBbdm9pZCAwLCBjdHhdO1xuXHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdHJlc3VsdCA9IFtnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSksIHZvaWQgMF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KTtcblx0Y29uc3QgbWV0aG9kTWFwcGVyID0gYWxsb3dNZXRob2RPdmVycmlkZSA/IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUF9XSVRIX01FVEhPRF9PVkVSUklERSA6IFRZUEVfQUNDRVBURURfTUVUSE9EX01BUDtcblx0LyoqXG5cdCogQGRlcHJlY2F0ZWRcblx0Ki9cblx0Y29uc3QgaXNTdHJlYW1DYWxsID0gcmVxLmhlYWRlcnMuZ2V0KFwidHJwYy1hY2NlcHRcIikgPT09IFwiYXBwbGljYXRpb24vanNvbmxcIjtcblx0Y29uc3QgZXhwZXJpbWVudGFsU1NFID0gKF9jb25maWckc3NlJGVuYWJsZWQgPSAoX2NvbmZpZyRzc2UgPSBjb25maWcuc3NlKSA9PT0gbnVsbCB8fCBfY29uZmlnJHNzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NvbmZpZyRzc2UuZW5hYmxlZCkgIT09IG51bGwgJiYgX2NvbmZpZyRzc2UkZW5hYmxlZCAhPT0gdm9pZCAwID8gX2NvbmZpZyRzc2UkZW5hYmxlZCA6IHRydWU7XG5cdHRyeSB7XG5cdFx0Y29uc3QgW2luZm9FcnJvciwgaW5mb10gPSBpbmZvVHVwbGU7XG5cdFx0aWYgKGluZm9FcnJvcikgdGhyb3cgaW5mb0Vycm9yO1xuXHRcdGlmIChpbmZvLmlzQmF0Y2hDYWxsICYmICFhbGxvd0JhdGNoaW5nKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdGNvZGU6IFwiQkFEX1JFUVVFU1RcIixcblx0XHRcdG1lc3NhZ2U6IGBCYXRjaGluZyBpcyBub3QgZW5hYmxlZCBvbiB0aGUgc2VydmVyYFxuXHRcdH0pO1xuXHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRpZiAoaXNTdHJlYW1DYWxsICYmICFpbmZvLmlzQmF0Y2hDYWxsKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdG1lc3NhZ2U6IGBTdHJlYW1pbmcgcmVxdWVzdHMgbXVzdCBiZSBiYXRjaGVkICh5b3UgY2FuIGRvIGEgYmF0Y2ggb2YgMSlgLFxuXHRcdFx0Y29kZTogXCJCQURfUkVRVUVTVFwiXG5cdFx0fSk7XG5cdFx0YXdhaXQgY3R4TWFuYWdlci5jcmVhdGUoaW5mbyk7XG5cdFx0Y29uc3QgcnBjQ2FsbHMgPSBpbmZvLmNhbGxzLm1hcChhc3luYyAoY2FsbCkgPT4ge1xuXHRcdFx0Y29uc3QgcHJvYyA9IGNhbGwucHJvY2VkdXJlO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKG9wdHMuZXJyb3IpIHRocm93IG9wdHMuZXJyb3I7XG5cdFx0XHRcdGlmICghcHJvYykgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJOT1RfRk9VTkRcIixcblx0XHRcdFx0XHRtZXNzYWdlOiBgTm8gcHJvY2VkdXJlIGZvdW5kIG9uIHBhdGggXCIke2NhbGwucGF0aH1cImBcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmICghbWV0aG9kTWFwcGVyW3Byb2MuX2RlZi50eXBlXS5pbmNsdWRlcyhyZXEubWV0aG9kKSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0XHRcdG1lc3NhZ2U6IGBVbnN1cHBvcnRlZCAke3JlcS5tZXRob2R9LXJlcXVlc3QgdG8gJHtwcm9jLl9kZWYudHlwZX0gcHJvY2VkdXJlIGF0IHBhdGggXCIke2NhbGwucGF0aH1cImBcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmIChwcm9jLl9kZWYudHlwZSA9PT0gXCJzdWJzY3JpcHRpb25cIikge1xuXHRcdFx0XHRcdC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAtLSBAcHJlc2VydmUgKi9cblx0XHRcdFx0XHRpZiAoaW5mby5pc0JhdGNoQ2FsbCkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIkJBRF9SRVFVRVNUXCIsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBgQ2Fubm90IGJhdGNoIHN1YnNjcmlwdGlvbiBjYWxsc2Bcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zdCBkYXRhID0gYXdhaXQgcHJvYyh7XG5cdFx0XHRcdFx0cGF0aDogY2FsbC5wYXRoLFxuXHRcdFx0XHRcdGdldFJhd0lucHV0OiBjYWxsLmdldFJhd0lucHV0LFxuXHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZSgpLFxuXHRcdFx0XHRcdHR5cGU6IHByb2MuX2RlZi50eXBlLFxuXHRcdFx0XHRcdHNpZ25hbDogb3B0cy5yZXEuc2lnbmFsXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW3ZvaWQgMCwgeyBkYXRhIH1dO1xuXHRcdFx0fSBjYXRjaCAoY2F1c2UpIHtcblx0XHRcdFx0dmFyIF9vcHRzJG9uRXJyb3IsIF9jYWxsJHByb2NlZHVyZSRfZGVmJCwgX2NhbGwkcHJvY2VkdXJlMjtcblx0XHRcdFx0Y29uc3QgZXJyb3IgPSBnZXRUUlBDRXJyb3JGcm9tVW5rbm93bihjYXVzZSk7XG5cdFx0XHRcdGNvbnN0IGlucHV0ID0gY2FsbC5yZXN1bHQoKTtcblx0XHRcdFx0KF9vcHRzJG9uRXJyb3IgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IgPT09IHZvaWQgMCB8fCBfb3B0cyRvbkVycm9yLmNhbGwob3B0cywge1xuXHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdHBhdGg6IGNhbGwucGF0aCxcblx0XHRcdFx0XHRpbnB1dCxcblx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdHR5cGU6IChfY2FsbCRwcm9jZWR1cmUkX2RlZiQgPSAoX2NhbGwkcHJvY2VkdXJlMiA9IGNhbGwucHJvY2VkdXJlKSA9PT0gbnVsbCB8fCBfY2FsbCRwcm9jZWR1cmUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbCRwcm9jZWR1cmUyLl9kZWYudHlwZSkgIT09IG51bGwgJiYgX2NhbGwkcHJvY2VkdXJlJF9kZWYkICE9PSB2b2lkIDAgPyBfY2FsbCRwcm9jZWR1cmUkX2RlZiQgOiBcInVua25vd25cIixcblx0XHRcdFx0XHRyZXE6IG9wdHMucmVxXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRyZXR1cm4gW2Vycm9yLCB2b2lkIDBdO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmICghaW5mby5pc0JhdGNoQ2FsbCkge1xuXHRcdFx0Y29uc3QgW2NhbGxdID0gaW5mby5jYWxscztcblx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJwY0NhbGxzWzBdO1xuXHRcdFx0c3dpdGNoIChpbmZvLnR5cGUpIHtcblx0XHRcdFx0Y2FzZSBcInVua25vd25cIjpcblx0XHRcdFx0Y2FzZSBcIm11dGF0aW9uXCI6XG5cdFx0XHRcdGNhc2UgXCJxdWVyeVwiOiB7XG5cdFx0XHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0XHRcdGlmIChpc0RhdGFTdHJlYW0ocmVzdWx0ID09PSBudWxsIHx8IHJlc3VsdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzdWx0LmRhdGEpKSB0aHJvdyBuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdGNvZGU6IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogXCJDYW5ub3QgdXNlIHN0cmVhbS1saWtlIHJlc3BvbnNlIGluIG5vbi1zdHJlYW1pbmcgcmVxdWVzdCAtIHVzZSBodHRwQmF0Y2hTdHJlYW1MaW5rXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRjb25zdCByZXMgPSBlcnJvciA/IHsgZXJyb3I6IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IGNhbGwucmVzdWx0KCksXG5cdFx0XHRcdFx0XHRwYXRoOiBjYWxsLnBhdGgsXG5cdFx0XHRcdFx0XHR0eXBlOiBpbmZvLnR5cGVcblx0XHRcdFx0XHR9KSB9IDogeyByZXN1bHQ6IHsgZGF0YTogcmVzdWx0LmRhdGEgfSB9O1xuXHRcdFx0XHRcdGNvbnN0IGhlYWRSZXNwb25zZSQxID0gaW5pdFJlc3BvbnNlKHtcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRpbmZvLFxuXHRcdFx0XHRcdFx0cmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcblx0XHRcdFx0XHRcdGVycm9yczogZXJyb3IgPyBbZXJyb3JdIDogW10sXG5cdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0dW50cmFuc2Zvcm1lZEpTT046IFtyZXNdXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeSh0cmFuc2Zvcm1UUlBDUmVzcG9uc2UoY29uZmlnLCByZXMpKSwge1xuXHRcdFx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXMsXG5cdFx0XHRcdFx0XHRoZWFkZXJzXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FzZSBcInN1YnNjcmlwdGlvblwiOiB7XG5cdFx0XHRcdFx0Y29uc3QgaXRlcmFibGUgPSBydW4oKCkgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGVycm9yKSByZXR1cm4gZXJyb3JUb0FzeW5jSXRlcmFibGUoZXJyb3IpO1xuXHRcdFx0XHRcdFx0aWYgKCFleHBlcmltZW50YWxTU0UpIHJldHVybiBlcnJvclRvQXN5bmNJdGVyYWJsZShuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0XHRcdFx0Y29kZTogXCJNRVRIT0RfTk9UX1NVUFBPUlRFRFwiLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBcIk1pc3NpbmcgZXhwZXJpbWVudGFsIGZsYWcgXFxcInNzZVN1YnNjcmlwdGlvbnNcXFwiXCJcblx0XHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRcdGlmICghaXNPYnNlcnZhYmxlKHJlc3VsdC5kYXRhKSAmJiAhaXNBc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhKSkgcmV0dXJuIGVycm9yVG9Bc3luY0l0ZXJhYmxlKG5ldyBUUlBDRXJyb3Ioe1xuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiBgU3Vic2NyaXB0aW9uICR7Y2FsbC5wYXRofSBkaWQgbm90IHJldHVybiBhbiBvYnNlcnZhYmxlIG9yIGEgQXN5bmNHZW5lcmF0b3JgLFxuXHRcdFx0XHRcdFx0XHRjb2RlOiBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiXG5cdFx0XHRcdFx0XHR9KSk7XG5cdFx0XHRcdFx0XHRjb25zdCBkYXRhQXNJdGVyYWJsZSA9IGlzT2JzZXJ2YWJsZShyZXN1bHQuZGF0YSkgPyBvYnNlcnZhYmxlVG9Bc3luY0l0ZXJhYmxlKHJlc3VsdC5kYXRhLCBvcHRzLnJlcS5zaWduYWwpIDogcmVzdWx0LmRhdGE7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGF0YUFzSXRlcmFibGU7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0Y29uc3Qgc3RyZWFtID0gc3NlU3RyZWFtUHJvZHVjZXIoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgY29uZmlnLnNzZSksIHt9LCB7XG5cdFx0XHRcdFx0XHRkYXRhOiBpdGVyYWJsZSxcblx0XHRcdFx0XHRcdHNlcmlhbGl6ZTogKHYpID0+IGNvbmZpZy50cmFuc2Zvcm1lci5vdXRwdXQuc2VyaWFsaXplKHYpLFxuXHRcdFx0XHRcdFx0Zm9ybWF0RXJyb3IoZXJyb3JPcHRzKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBfY2FsbCRwcm9jZWR1cmUkX2RlZiQyLCBfY2FsbCRwcm9jZWR1cmUzLCBfb3B0cyRvbkVycm9yMjtcblx0XHRcdFx0XHRcdFx0Y29uc3QgZXJyb3IkMSA9IGdldFRSUENFcnJvckZyb21Vbmtub3duKGVycm9yT3B0cy5lcnJvcik7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGlucHV0ID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnJlc3VsdCgpO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBwYXRoID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnBhdGg7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IHR5cGUgPSAoX2NhbGwkcHJvY2VkdXJlJF9kZWYkMiA9IGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwIHx8IChfY2FsbCRwcm9jZWR1cmUzID0gY2FsbC5wcm9jZWR1cmUpID09PSBudWxsIHx8IF9jYWxsJHByb2NlZHVyZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsJHByb2NlZHVyZTMuX2RlZi50eXBlKSAhPT0gbnVsbCAmJiBfY2FsbCRwcm9jZWR1cmUkX2RlZiQyICE9PSB2b2lkIDAgPyBfY2FsbCRwcm9jZWR1cmUkX2RlZiQyIDogXCJ1bmtub3duXCI7XG5cdFx0XHRcdFx0XHRcdChfb3B0cyRvbkVycm9yMiA9IG9wdHMub25FcnJvcikgPT09IG51bGwgfHwgX29wdHMkb25FcnJvcjIgPT09IHZvaWQgMCB8fCBfb3B0cyRvbkVycm9yMi5jYWxsKG9wdHMsIHtcblx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyb3IkMSxcblx0XHRcdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRcdFx0cmVxOiBvcHRzLnJlcSxcblx0XHRcdFx0XHRcdFx0XHR0eXBlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0XHRcdGNvbmZpZyxcblx0XHRcdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBlcnJvciQxLFxuXHRcdFx0XHRcdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRcdFx0XHRcdHBhdGgsXG5cdFx0XHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNoYXBlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pKTtcblx0XHRcdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhzc2VIZWFkZXJzKSkgaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0XHRcdFx0Y29uc3QgaGVhZFJlc3BvbnNlJDEgPSBpbml0UmVzcG9uc2Uoe1xuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGluZm8sXG5cdFx0XHRcdFx0XHRyZXNwb25zZU1ldGE6IG9wdHMucmVzcG9uc2VNZXRhLFxuXHRcdFx0XHRcdFx0ZXJyb3JzOiBbXSxcblx0XHRcdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdFx0XHR1bnRyYW5zZm9ybWVkSlNPTjogbnVsbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG5cdFx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXNcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaW5mby5hY2NlcHQgPT09IFwiYXBwbGljYXRpb24vanNvbmxcIikge1xuXHRcdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHRcdFx0aGVhZGVycy5zZXQoXCJ0cmFuc2Zlci1lbmNvZGluZ1wiLCBcImNodW5rZWRcIik7XG5cdFx0XHRjb25zdCBoZWFkUmVzcG9uc2UkMSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdGluZm8sXG5cdFx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHRcdGVycm9yczogW10sXG5cdFx0XHRcdGhlYWRlcnMsXG5cdFx0XHRcdHVudHJhbnNmb3JtZWRKU09OOiBudWxsXG5cdFx0XHR9KTtcblx0XHRcdGNvbnN0IHN0cmVhbSA9IGpzb25sU3RyZWFtUHJvZHVjZXIoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgY29uZmlnLmpzb25sKSwge30sIHtcblx0XHRcdFx0bWF4RGVwdGg6IEluZmluaXR5LFxuXHRcdFx0XHRkYXRhOiBycGNDYWxscy5tYXAoYXN5bmMgKHJlcykgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IFtlcnJvciwgcmVzdWx0XSA9IGF3YWl0IHJlcztcblx0XHRcdFx0XHRjb25zdCBjYWxsID0gaW5mby5jYWxsc1swXTtcblx0XHRcdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdHZhciBfcHJvY2VkdXJlJF9kZWYkdHlwZSwgX3Byb2NlZHVyZTtcblx0XHRcdFx0XHRcdHJldHVybiB7IGVycm9yOiBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRcdFx0aW5wdXQ6IGNhbGwucmVzdWx0KCksXG5cdFx0XHRcdFx0XHRcdHBhdGg6IGNhbGwucGF0aCxcblx0XHRcdFx0XHRcdFx0dHlwZTogKF9wcm9jZWR1cmUkX2RlZiR0eXBlID0gKF9wcm9jZWR1cmUgPSBjYWxsLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX3Byb2NlZHVyZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3Byb2NlZHVyZS5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9wcm9jZWR1cmUkX2RlZiR0eXBlICE9PSB2b2lkIDAgPyBfcHJvY2VkdXJlJF9kZWYkdHlwZSA6IFwidW5rbm93blwiXG5cdFx0XHRcdFx0XHR9KSB9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvKipcblx0XHRcdFx0XHQqIE5vdCB2ZXJ5IHByZXR0eSwgYnV0IHdlIG5lZWQgdG8gd3JhcCBuZXN0ZWQgZGF0YSBpbiBwcm9taXNlc1xuXHRcdFx0XHRcdCogT3VyIHN0cmVhbSBwcm9kdWNlciB3aWxsIG9ubHkgcmVzb2x2ZSB0b3AtbGV2ZWwgYXN5bmMgdmFsdWVzIG9yIGFzeW5jIHZhbHVlcyB0aGF0IGFyZSBkaXJlY3RseSBuZXN0ZWQgaW4gYW5vdGhlciBhc3luYyB2YWx1ZVxuXHRcdFx0XHRcdCovXG5cdFx0XHRcdFx0Y29uc3QgaXRlcmFibGUgPSBpc09ic2VydmFibGUocmVzdWx0LmRhdGEpID8gb2JzZXJ2YWJsZVRvQXN5bmNJdGVyYWJsZShyZXN1bHQuZGF0YSwgb3B0cy5yZXEuc2lnbmFsKSA6IFByb21pc2UucmVzb2x2ZShyZXN1bHQuZGF0YSk7XG5cdFx0XHRcdFx0cmV0dXJuIHsgcmVzdWx0OiBQcm9taXNlLnJlc29sdmUoeyBkYXRhOiBpdGVyYWJsZSB9KSB9O1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0c2VyaWFsaXplOiAoZGF0YSkgPT4gY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoZGF0YSksXG5cdFx0XHRcdG9uRXJyb3I6IChjYXVzZSkgPT4ge1xuXHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yMywgX2luZm8kdHlwZTtcblx0XHRcdFx0XHQoX29wdHMkb25FcnJvcjMgPSBvcHRzLm9uRXJyb3IpID09PSBudWxsIHx8IF9vcHRzJG9uRXJyb3IzID09PSB2b2lkIDAgfHwgX29wdHMkb25FcnJvcjMuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0XHRcdFx0cGF0aDogdm9pZCAwLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IHZvaWQgMCxcblx0XHRcdFx0XHRcdGN0eDogY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCksXG5cdFx0XHRcdFx0XHRyZXE6IG9wdHMucmVxLFxuXHRcdFx0XHRcdFx0dHlwZTogKF9pbmZvJHR5cGUgPSBpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8udHlwZSkgIT09IG51bGwgJiYgX2luZm8kdHlwZSAhPT0gdm9pZCAwID8gX2luZm8kdHlwZSA6IFwidW5rbm93blwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZvcm1hdEVycm9yKGVycm9yT3B0cykge1xuXHRcdFx0XHRcdHZhciBfY2FsbCRwcm9jZWR1cmUkX2RlZiQzLCBfY2FsbCRwcm9jZWR1cmU0O1xuXHRcdFx0XHRcdGNvbnN0IGNhbGwgPSBpbmZvID09PSBudWxsIHx8IGluZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluZm8uY2FsbHNbZXJyb3JPcHRzLnBhdGhbMF1dO1xuXHRcdFx0XHRcdGNvbnN0IGVycm9yID0gZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oZXJyb3JPcHRzLmVycm9yKTtcblx0XHRcdFx0XHRjb25zdCBpbnB1dCA9IGNhbGwgPT09IG51bGwgfHwgY2FsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbC5yZXN1bHQoKTtcblx0XHRcdFx0XHRjb25zdCBwYXRoID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsLnBhdGg7XG5cdFx0XHRcdFx0Y29uc3QgdHlwZSA9IChfY2FsbCRwcm9jZWR1cmUkX2RlZiQzID0gY2FsbCA9PT0gbnVsbCB8fCBjYWxsID09PSB2b2lkIDAgfHwgKF9jYWxsJHByb2NlZHVyZTQgPSBjYWxsLnByb2NlZHVyZSkgPT09IG51bGwgfHwgX2NhbGwkcHJvY2VkdXJlNCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NhbGwkcHJvY2VkdXJlNC5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9jYWxsJHByb2NlZHVyZSRfZGVmJDMgIT09IHZvaWQgMCA/IF9jYWxsJHByb2NlZHVyZSRfZGVmJDMgOiBcInVua25vd25cIjtcblx0XHRcdFx0XHRjb25zdCBzaGFwZSA9IGdldEVycm9yU2hhcGUoe1xuXHRcdFx0XHRcdFx0Y29uZmlnLFxuXHRcdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRcdGVycm9yLFxuXHRcdFx0XHRcdFx0aW5wdXQsXG5cdFx0XHRcdFx0XHRwYXRoLFxuXHRcdFx0XHRcdFx0dHlwZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHJldHVybiBzaGFwZTtcblx0XHRcdFx0fVxuXHRcdFx0fSkpO1xuXHRcdFx0cmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcblx0XHRcdFx0aGVhZGVycyxcblx0XHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2UkMS5zdGF0dXNcblx0XHRcdH0pO1xuXHRcdH1cblx0XHQvKipcblx0XHQqIE5vbi1zdHJlYW1pbmcgcmVzcG9uc2U6XG5cdFx0KiAtIGF3YWl0IGFsbCByZXNwb25zZXMgaW4gcGFyYWxsZWwsIGJsb2NraW5nIG9uIHRoZSBzbG93ZXN0IG9uZVxuXHRcdCogLSBjcmVhdGUgaGVhZGVycyB3aXRoIGtub3duIHJlc3BvbnNlIGJvZHlcblx0XHQqIC0gcmV0dXJuIGEgY29tcGxldGUgSFRUUFJlc3BvbnNlXG5cdFx0Ki9cblx0XHRoZWFkZXJzLnNldChcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0Y29uc3QgcmVzdWx0cyA9IChhd2FpdCBQcm9taXNlLmFsbChycGNDYWxscykpLm1hcCgocmVzKSA9PiB7XG5cdFx0XHRjb25zdCBbZXJyb3IsIHJlc3VsdF0gPSByZXM7XG5cdFx0XHRpZiAoZXJyb3IpIHJldHVybiByZXM7XG5cdFx0XHRpZiAoaXNEYXRhU3RyZWFtKHJlc3VsdC5kYXRhKSkgcmV0dXJuIFtuZXcgVFJQQ0Vycm9yKHtcblx0XHRcdFx0Y29kZTogXCJVTlNVUFBPUlRFRF9NRURJQV9UWVBFXCIsXG5cdFx0XHRcdG1lc3NhZ2U6IFwiQ2Fubm90IHVzZSBzdHJlYW0tbGlrZSByZXNwb25zZSBpbiBub24tc3RyZWFtaW5nIHJlcXVlc3QgLSB1c2UgaHR0cEJhdGNoU3RyZWFtTGlua1wiXG5cdFx0XHR9KSwgdm9pZCAwXTtcblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSk7XG5cdFx0Y29uc3QgcmVzdWx0QXNSUENSZXNwb25zZSA9IHJlc3VsdHMubWFwKChbZXJyb3IsIHJlc3VsdF0sIGluZGV4KSA9PiB7XG5cdFx0XHRjb25zdCBjYWxsID0gaW5mby5jYWxsc1tpbmRleF07XG5cdFx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdFx0dmFyIF9jYWxsJHByb2NlZHVyZSRfZGVmJDQsIF9jYWxsJHByb2NlZHVyZTU7XG5cdFx0XHRcdHJldHVybiB7IGVycm9yOiBnZXRFcnJvclNoYXBlKHtcblx0XHRcdFx0XHRjb25maWcsXG5cdFx0XHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdFx0XHRlcnJvcixcblx0XHRcdFx0XHRpbnB1dDogY2FsbC5yZXN1bHQoKSxcblx0XHRcdFx0XHRwYXRoOiBjYWxsLnBhdGgsXG5cdFx0XHRcdFx0dHlwZTogKF9jYWxsJHByb2NlZHVyZSRfZGVmJDQgPSAoX2NhbGwkcHJvY2VkdXJlNSA9IGNhbGwucHJvY2VkdXJlKSA9PT0gbnVsbCB8fCBfY2FsbCRwcm9jZWR1cmU1ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY2FsbCRwcm9jZWR1cmU1Ll9kZWYudHlwZSkgIT09IG51bGwgJiYgX2NhbGwkcHJvY2VkdXJlJF9kZWYkNCAhPT0gdm9pZCAwID8gX2NhbGwkcHJvY2VkdXJlJF9kZWYkNCA6IFwidW5rbm93blwiXG5cdFx0XHRcdH0pIH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geyByZXN1bHQ6IHsgZGF0YTogcmVzdWx0LmRhdGEgfSB9O1xuXHRcdH0pO1xuXHRcdGNvbnN0IGVycm9ycyA9IHJlc3VsdHMubWFwKChbZXJyb3JdKSA9PiBlcnJvcikuZmlsdGVyKEJvb2xlYW4pO1xuXHRcdGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRjdHg6IGN0eE1hbmFnZXIudmFsdWVPclVuZGVmaW5lZCgpLFxuXHRcdFx0aW5mbyxcblx0XHRcdHJlc3BvbnNlTWV0YTogb3B0cy5yZXNwb25zZU1ldGEsXG5cdFx0XHR1bnRyYW5zZm9ybWVkSlNPTjogcmVzdWx0QXNSUENSZXNwb25zZSxcblx0XHRcdGVycm9ycyxcblx0XHRcdGhlYWRlcnNcblx0XHR9KTtcblx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHRyYW5zZm9ybVRSUENSZXNwb25zZShjb25maWcsIHJlc3VsdEFzUlBDUmVzcG9uc2UpKSwge1xuXHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2Uuc3RhdHVzLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdHZhciBfaW5mbyR0eXBlMjtcblx0XHRjb25zdCBbX2luZm9FcnJvciwgaW5mb10gPSBpbmZvVHVwbGU7XG5cdFx0Y29uc3QgY3R4ID0gY3R4TWFuYWdlci52YWx1ZU9yVW5kZWZpbmVkKCk7XG5cdFx0Y29uc3QgeyBlcnJvciwgdW50cmFuc2Zvcm1lZEpTT04sIGJvZHkgfSA9IGNhdWdodEVycm9yVG9EYXRhKGNhdXNlLCB7XG5cdFx0XHRvcHRzLFxuXHRcdFx0Y3R4OiBjdHhNYW5hZ2VyLnZhbHVlT3JVbmRlZmluZWQoKSxcblx0XHRcdHR5cGU6IChfaW5mbyR0eXBlMiA9IGluZm8gPT09IG51bGwgfHwgaW5mbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5mby50eXBlKSAhPT0gbnVsbCAmJiBfaW5mbyR0eXBlMiAhPT0gdm9pZCAwID8gX2luZm8kdHlwZTIgOiBcInVua25vd25cIlxuXHRcdH0pO1xuXHRcdGNvbnN0IGhlYWRSZXNwb25zZSA9IGluaXRSZXNwb25zZSh7XG5cdFx0XHRjdHgsXG5cdFx0XHRpbmZvLFxuXHRcdFx0cmVzcG9uc2VNZXRhOiBvcHRzLnJlc3BvbnNlTWV0YSxcblx0XHRcdHVudHJhbnNmb3JtZWRKU09OLFxuXHRcdFx0ZXJyb3JzOiBbZXJyb3JdLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHRcdHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuXHRcdFx0c3RhdHVzOiBoZWFkUmVzcG9uc2Uuc3RhdHVzLFxuXHRcdFx0aGVhZGVyc1xuXHRcdH0pO1xuXHR9XG59XG5cbi8vI2VuZHJlZ2lvblxuZXhwb3J0IHsgVW5wcm9taXNlLCBjcmVhdGVEZWZlcnJlZCwgZ2V0UmVxdWVzdEluZm8sIGlzQWJvcnRFcnJvciwgaXNQcm9taXNlLCBpdGVyYXRvclJlc291cmNlLCBqc29ubFN0cmVhbUNvbnN1bWVyLCBqc29ubFN0cmVhbVByb2R1Y2VyLCBtYWtlQXN5bmNSZXNvdXJjZSwgbWFrZVJlc291cmNlLCBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tU3RyaW5nLCBwYXJzZUNvbm5lY3Rpb25QYXJhbXNGcm9tVW5rbm93biwgcmVxdWlyZV91c2luZ0N0eCwgcmVzb2x2ZVJlc3BvbnNlLCBzc2VIZWFkZXJzLCBzc2VTdHJlYW1Db25zdW1lciwgc3NlU3RyZWFtUHJvZHVjZXIsIHRha2VXaXRoR3JhY2UsIHRocm93QWJvcnRFcnJvciwgd2l0aE1heER1cmF0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlUmVzcG9uc2UtRG5nU2doYTYubWpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/resolveResponse-DngSgha6.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/tracked-Blz8XOf1.mjs":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/tracked-Blz8XOf1.mjs ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPCError: () => (/* binding */ TRPCError),\n/* harmony export */   callProcedure: () => (/* binding */ callProcedure),\n/* harmony export */   createCallerFactory: () => (/* binding */ createCallerFactory),\n/* harmony export */   createRouterFactory: () => (/* binding */ createRouterFactory),\n/* harmony export */   defaultFormatter: () => (/* binding */ defaultFormatter),\n/* harmony export */   defaultTransformer: () => (/* binding */ defaultTransformer),\n/* harmony export */   getCauseFromUnknown: () => (/* binding */ getCauseFromUnknown),\n/* harmony export */   getDataTransformer: () => (/* binding */ getDataTransformer),\n/* harmony export */   getProcedureAtPath: () => (/* binding */ getProcedureAtPath),\n/* harmony export */   getTRPCErrorFromUnknown: () => (/* binding */ getTRPCErrorFromUnknown),\n/* harmony export */   isTrackedEnvelope: () => (/* binding */ isTrackedEnvelope),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   mergeRouters: () => (/* binding */ mergeRouters),\n/* harmony export */   sse: () => (/* binding */ sse),\n/* harmony export */   tracked: () => (/* binding */ tracked),\n/* harmony export */   transformResult: () => (/* binding */ transformResult),\n/* harmony export */   transformTRPCResponse: () => (/* binding */ transformTRPCResponse)\n/* harmony export */ });\n/* harmony import */ var _getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getErrorShape-BH60iMC2.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/getErrorShape-BH60iMC2.mjs\");\n/* harmony import */ var _utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils-CLZnJdb_.mjs */ \"(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/utils-CLZnJdb_.mjs\");\n\n\n\n//#region src/unstable-core-do-not-import/error/formatter.ts\nconst defaultFormatter = ({ shape }) => {\n\treturn shape;\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/error/TRPCError.ts\nvar import_defineProperty = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.require_defineProperty)(), 1);\nvar UnknownCauseError = class extends Error {};\nfunction getCauseFromUnknown(cause) {\n\tif (cause instanceof Error) return cause;\n\tconst type = typeof cause;\n\tif (type === \"undefined\" || type === \"function\" || cause === null) return void 0;\n\tif (type !== \"object\") return new Error(String(cause));\n\tif ((0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(cause)) return Object.assign(new UnknownCauseError(), cause);\n\treturn void 0;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n\tif (cause instanceof TRPCError) return cause;\n\tif (cause instanceof Error && cause.name === \"TRPCError\") return cause;\n\tconst trpcError = new TRPCError({\n\t\tcode: \"INTERNAL_SERVER_ERROR\",\n\t\tcause\n\t});\n\tif (cause instanceof Error && cause.stack) trpcError.stack = cause.stack;\n\treturn trpcError;\n}\nvar TRPCError = class extends Error {\n\tconstructor(opts) {\n\t\tvar _ref, _opts$message, _this$cause;\n\t\tconst cause = getCauseFromUnknown(opts.cause);\n\t\tconst message = (_ref = (_opts$message = opts.message) !== null && _opts$message !== void 0 ? _opts$message : cause === null || cause === void 0 ? void 0 : cause.message) !== null && _ref !== void 0 ? _ref : opts.code;\n\t\tsuper(message, { cause });\n\t\t(0, import_defineProperty.default)(this, \"cause\", void 0);\n\t\t(0, import_defineProperty.default)(this, \"code\", void 0);\n\t\tthis.code = opts.code;\n\t\tthis.name = \"TRPCError\";\n\t\t(_this$cause = this.cause) !== null && _this$cause !== void 0 || (this.cause = cause);\n\t}\n};\n\n//#endregion\n//#region src/unstable-core-do-not-import/transformer.ts\nvar import_objectSpread2$1 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/**\n* @internal\n*/\nfunction getDataTransformer(transformer) {\n\tif (\"input\" in transformer) return transformer;\n\treturn {\n\t\tinput: transformer,\n\t\toutput: transformer\n\t};\n}\n/**\n* @internal\n*/\nconst defaultTransformer = {\n\tinput: {\n\t\tserialize: (obj) => obj,\n\t\tdeserialize: (obj) => obj\n\t},\n\toutput: {\n\t\tserialize: (obj) => obj,\n\t\tdeserialize: (obj) => obj\n\t}\n};\nfunction transformTRPCResponseItem(config, item) {\n\tif (\"error\" in item) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, { error: config.transformer.output.serialize(item.error) });\n\tif (\"data\" in item.result) return (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item), {}, { result: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, item.result), {}, { data: config.transformer.output.serialize(item.result.data) }) });\n\treturn item;\n}\n/**\n* Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n**/\nfunction transformTRPCResponse(config, itemOrItems) {\n\treturn Array.isArray(itemOrItems) ? itemOrItems.map((item) => transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n/** @internal */\nfunction transformResultInner(response, transformer) {\n\tif (\"error\" in response) {\n\t\tconst error = transformer.deserialize(response.error);\n\t\treturn {\n\t\t\tok: false,\n\t\t\terror: (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response), {}, { error })\n\t\t};\n\t}\n\tconst result = (0, import_objectSpread2$1.default)((0, import_objectSpread2$1.default)({}, response.result), (!response.result.type || response.result.type === \"data\") && {\n\t\ttype: \"data\",\n\t\tdata: transformer.deserialize(response.result.data)\n\t});\n\treturn {\n\t\tok: true,\n\t\tresult\n\t};\n}\nvar TransformResultError = class extends Error {\n\tconstructor() {\n\t\tsuper(\"Unable to transform response from server\");\n\t}\n};\n/**\n* Transforms and validates that the result is a valid TRPCResponse\n* @internal\n*/\nfunction transformResult(response, transformer) {\n\tlet result;\n\ttry {\n\t\tresult = transformResultInner(response, transformer);\n\t} catch (_unused) {\n\t\tthrow new TransformResultError();\n\t}\n\tif (!result.ok && (!(0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.error.error) || typeof result.error.error[\"code\"] !== \"number\")) throw new TransformResultError();\n\tif (result.ok && !(0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(result.result)) throw new TransformResultError();\n\treturn result;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/router.ts\nvar import_objectSpread2 = (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.__toESM)((0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.require_objectSpread2)(), 1);\n/**\n* @internal\n*/\nconst lazyMarker = \"lazyMarker\";\nfunction once(fn) {\n\tconst uncalled = Symbol();\n\tlet result = uncalled;\n\treturn () => {\n\t\tif (result === uncalled) result = fn();\n\t\treturn result;\n\t};\n}\n/**\n* Lazy load a router\n* @see https://trpc.io/docs/server/merging-routers#lazy-load\n*/\nfunction lazy(importRouter) {\n\tasync function resolve() {\n\t\tconst mod = await importRouter();\n\t\tif (isRouter(mod)) return mod;\n\t\tconst routers = Object.values(mod);\n\t\tif (routers.length !== 1 || !isRouter(routers[0])) throw new Error(\"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\");\n\t\treturn routers[0];\n\t}\n\tresolve[lazyMarker] = true;\n\treturn resolve;\n}\nfunction isLazy(input) {\n\treturn typeof input === \"function\" && lazyMarker in input;\n}\nfunction isRouter(value) {\n\treturn (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value) && (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.isObject)(value[\"_def\"]) && \"router\" in value[\"_def\"];\n}\nconst emptyRouter = {\n\t_ctx: null,\n\t_errorShape: null,\n\t_meta: null,\n\tqueries: {},\n\tmutations: {},\n\tsubscriptions: {},\n\terrorFormatter: defaultFormatter,\n\ttransformer: defaultTransformer\n};\n/**\n* Reserved words that can't be used as router or procedure names\n*/\nconst reservedWords = [\n\t\"then\",\n\t\"call\",\n\t\"apply\"\n];\n/**\n* @internal\n*/\nfunction createRouterFactory(config) {\n\tfunction createRouterInner(input) {\n\t\tconst reservedWordsUsed = new Set(Object.keys(input).filter((v) => reservedWords.includes(v)));\n\t\tif (reservedWordsUsed.size > 0) throw new Error(\"Reserved words used in `router({})` call: \" + Array.from(reservedWordsUsed).join(\", \"));\n\t\tconst procedures = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n\t\tconst lazy$1 = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n\t\tfunction createLazyLoader(opts) {\n\t\t\treturn {\n\t\t\t\tref: opts.ref,\n\t\t\t\tload: once(async () => {\n\t\t\t\t\tconst router$1 = await opts.ref();\n\t\t\t\t\tconst lazyPath = [...opts.path, opts.key];\n\t\t\t\t\tconst lazyKey = lazyPath.join(\".\");\n\t\t\t\t\topts.aggregate[opts.key] = step(router$1._def.record, lazyPath);\n\t\t\t\t\tdelete lazy$1[lazyKey];\n\t\t\t\t\tfor (const [nestedKey, nestedItem] of Object.entries(router$1._def.lazy)) {\n\t\t\t\t\t\tconst nestedRouterKey = [...lazyPath, nestedKey].join(\".\");\n\t\t\t\t\t\tlazy$1[nestedRouterKey] = createLazyLoader({\n\t\t\t\t\t\t\tref: nestedItem.ref,\n\t\t\t\t\t\t\tpath: lazyPath,\n\t\t\t\t\t\t\tkey: nestedKey,\n\t\t\t\t\t\t\taggregate: opts.aggregate[opts.key]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t};\n\t\t}\n\t\tfunction step(from, path = []) {\n\t\t\tconst aggregate = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.omitPrototype)({});\n\t\t\tfor (const [key, item] of Object.entries(from !== null && from !== void 0 ? from : {})) {\n\t\t\t\tif (isLazy(item)) {\n\t\t\t\t\tlazy$1[[...path, key].join(\".\")] = createLazyLoader({\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\tref: item,\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\taggregate\n\t\t\t\t\t});\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (isRouter(item)) {\n\t\t\t\t\taggregate[key] = step(item._def.record, [...path, key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!isProcedure(item)) {\n\t\t\t\t\taggregate[key] = step(item, [...path, key]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst newPath = [...path, key].join(\".\");\n\t\t\t\tif (procedures[newPath]) throw new Error(`Duplicate key: ${newPath}`);\n\t\t\t\tprocedures[newPath] = item;\n\t\t\t\taggregate[key] = item;\n\t\t\t}\n\t\t\treturn aggregate;\n\t\t}\n\t\tconst record = step(input);\n\t\tconst _def = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({\n\t\t\t_config: config,\n\t\t\trouter: true,\n\t\t\tprocedures,\n\t\t\tlazy: lazy$1\n\t\t}, emptyRouter), {}, { record });\n\t\tconst router = (0, import_objectSpread2.default)((0, import_objectSpread2.default)({}, record), {}, {\n\t\t\t_def,\n\t\t\tcreateCaller: createCallerFactory()({ _def })\n\t\t});\n\t\treturn router;\n\t}\n\treturn createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n\treturn typeof procedureOrRouter === \"function\";\n}\n/**\n* @internal\n*/\nasync function getProcedureAtPath(router, path) {\n\tconst { _def } = router;\n\tlet procedure = _def.procedures[path];\n\twhile (!procedure) {\n\t\tconst key = Object.keys(_def.lazy).find((key$1) => path.startsWith(key$1));\n\t\tif (!key) return null;\n\t\tconst lazyRouter = _def.lazy[key];\n\t\tawait lazyRouter.load();\n\t\tprocedure = _def.procedures[path];\n\t}\n\treturn procedure;\n}\n/**\n* @internal\n*/\nasync function callProcedure(opts) {\n\tconst { type, path } = opts;\n\tconst proc = await getProcedureAtPath(opts.router, path);\n\tif (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) throw new TRPCError({\n\t\tcode: \"NOT_FOUND\",\n\t\tmessage: `No \"${type}\"-procedure on path \"${path}\"`\n\t});\n\t/* istanbul ignore if -- @preserve */\n\tif (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === \"subscription\") throw new TRPCError({\n\t\tcode: \"METHOD_NOT_SUPPORTED\",\n\t\tmessage: `Method override is not supported for subscriptions`\n\t});\n\treturn proc(opts);\n}\nfunction createCallerFactory() {\n\treturn function createCallerInner(router) {\n\t\tconst { _def } = router;\n\t\treturn function createCaller(ctxOrCallback, opts) {\n\t\t\treturn (0,_getErrorShape_BH60iMC2_mjs__WEBPACK_IMPORTED_MODULE_0__.createRecursiveProxy)(async (innerOpts) => {\n\t\t\t\tconst { path, args } = innerOpts;\n\t\t\t\tconst fullPath = path.join(\".\");\n\t\t\t\tif (path.length === 1 && path[0] === \"_def\") return _def;\n\t\t\t\tconst procedure = await getProcedureAtPath(router, fullPath);\n\t\t\t\tlet ctx = void 0;\n\t\t\t\ttry {\n\t\t\t\t\tif (!procedure) throw new TRPCError({\n\t\t\t\t\t\tcode: \"NOT_FOUND\",\n\t\t\t\t\t\tmessage: `No procedure found on path \"${path}\"`\n\t\t\t\t\t});\n\t\t\t\t\tctx = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.isFunction)(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n\t\t\t\t\treturn await procedure({\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\tgetRawInput: async () => args[0],\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\ttype: procedure._def.type,\n\t\t\t\t\t\tsignal: opts === null || opts === void 0 ? void 0 : opts.signal\n\t\t\t\t\t});\n\t\t\t\t} catch (cause) {\n\t\t\t\t\tvar _opts$onError, _procedure$_def$type;\n\t\t\t\t\topts === null || opts === void 0 || (_opts$onError = opts.onError) === null || _opts$onError === void 0 || _opts$onError.call(opts, {\n\t\t\t\t\t\tctx,\n\t\t\t\t\t\terror: getTRPCErrorFromUnknown(cause),\n\t\t\t\t\t\tinput: args[0],\n\t\t\t\t\t\tpath: fullPath,\n\t\t\t\t\t\ttype: (_procedure$_def$type = procedure === null || procedure === void 0 ? void 0 : procedure._def.type) !== null && _procedure$_def$type !== void 0 ? _procedure$_def$type : \"unknown\"\n\t\t\t\t\t});\n\t\t\t\t\tthrow cause;\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n}\nfunction mergeRouters(...routerList) {\n\tvar _routerList$;\n\tconst record = (0,_utils_CLZnJdb_mjs__WEBPACK_IMPORTED_MODULE_1__.mergeWithoutOverrides)({}, ...routerList.map((r) => r._def.record));\n\tconst errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {\n\t\tif (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n\t\t\tif (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) throw new Error(\"You seem to have several error formatters\");\n\t\t\treturn nextRouter._def._config.errorFormatter;\n\t\t}\n\t\treturn currentErrorFormatter;\n\t}, defaultFormatter);\n\tconst transformer = routerList.reduce((prev, current) => {\n\t\tif (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n\t\t\tif (prev !== defaultTransformer && prev !== current._def._config.transformer) throw new Error(\"You seem to have several transformers\");\n\t\t\treturn current._def._config.transformer;\n\t\t}\n\t\treturn prev;\n\t}, defaultTransformer);\n\tconst router = createRouterFactory({\n\t\terrorFormatter,\n\t\ttransformer,\n\t\tisDev: routerList.every((r) => r._def._config.isDev),\n\t\tallowOutsideOfServer: routerList.every((r) => r._def._config.allowOutsideOfServer),\n\t\tisServer: routerList.every((r) => r._def._config.isServer),\n\t\t$types: (_routerList$ = routerList[0]) === null || _routerList$ === void 0 ? void 0 : _routerList$._def._config.$types\n\t})(record);\n\treturn router;\n}\n\n//#endregion\n//#region src/unstable-core-do-not-import/stream/tracked.ts\nconst trackedSymbol = Symbol();\n/**\n* Produce a typed server-sent event message\n* @deprecated use `tracked(id, data)` instead\n*/\nfunction sse(event) {\n\treturn tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n\treturn Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n* Automatically track an event so that it can be resumed from a given id if the connection is lost\n*/\nfunction tracked(id, data) {\n\tif (id === \"\") throw new Error(\"`id` must not be an empty string as empty string is the same as not setting the id at all\");\n\treturn [\n\t\tid,\n\t\tdata,\n\t\ttrackedSymbol\n\t];\n}\n\n//#endregion\n\n//# sourceMappingURL=tracked-Blz8XOf1.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC90cmFja2VkLUJsejhYT2YxLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRIO0FBQzFCOztBQUVsRztBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRCQUE0QixvRUFBTyxDQUFDLG1GQUFzQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLDREQUFRO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZCQUE2QixvRUFBTyxDQUFDLGtGQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxXQUFXLElBQUksd0RBQXdEO0FBQzlLLDZHQUE2RyxXQUFXLElBQUksa0ZBQWtGLGtCQUFrQixJQUFJLDZEQUE2RCxHQUFHO0FBQ3BTO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsZUFBZSxJQUFJLE9BQU87QUFDOUc7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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ZHlhZC1hcHBzXFxyb3JrLXVuaXBhbG0tLS1DaC1uZy1uLW5nLWMtR3UtY29weVxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zXFxub2RlX21vZHVsZXNcXEB0cnBjXFxzZXJ2ZXJcXGRpc3RcXHRyYWNrZWQtQmx6OFhPZjEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fdG9FU00sIGNyZWF0ZVJlY3Vyc2l2ZVByb3h5LCByZXF1aXJlX2RlZmluZVByb3BlcnR5LCByZXF1aXJlX29iamVjdFNwcmVhZDIgfSBmcm9tIFwiLi9nZXRFcnJvclNoYXBlLUJINjBpTUMyLm1qc1wiO1xuaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNPYmplY3QsIG1lcmdlV2l0aG91dE92ZXJyaWRlcywgb21pdFByb3RvdHlwZSB9IGZyb20gXCIuL3V0aWxzLUNMWm5KZGJfLm1qc1wiO1xuXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9lcnJvci9mb3JtYXR0ZXIudHNcbmNvbnN0IGRlZmF1bHRGb3JtYXR0ZXIgPSAoeyBzaGFwZSB9KSA9PiB7XG5cdHJldHVybiBzaGFwZTtcbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvZXJyb3IvVFJQQ0Vycm9yLnRzXG52YXIgaW1wb3J0X2RlZmluZVByb3BlcnR5ID0gX190b0VTTShyZXF1aXJlX2RlZmluZVByb3BlcnR5KCksIDEpO1xudmFyIFVua25vd25DYXVzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7fTtcbmZ1bmN0aW9uIGdldENhdXNlRnJvbVVua25vd24oY2F1c2UpIHtcblx0aWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiBjYXVzZTtcblx0Y29uc3QgdHlwZSA9IHR5cGVvZiBjYXVzZTtcblx0aWYgKHR5cGUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiIHx8IGNhdXNlID09PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuXHRpZiAodHlwZSAhPT0gXCJvYmplY3RcIikgcmV0dXJuIG5ldyBFcnJvcihTdHJpbmcoY2F1c2UpKTtcblx0aWYgKGlzT2JqZWN0KGNhdXNlKSkgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFVua25vd25DYXVzZUVycm9yKCksIGNhdXNlKTtcblx0cmV0dXJuIHZvaWQgMDtcbn1cbmZ1bmN0aW9uIGdldFRSUENFcnJvckZyb21Vbmtub3duKGNhdXNlKSB7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIFRSUENFcnJvcikgcmV0dXJuIGNhdXNlO1xuXHRpZiAoY2F1c2UgaW5zdGFuY2VvZiBFcnJvciAmJiBjYXVzZS5uYW1lID09PSBcIlRSUENFcnJvclwiKSByZXR1cm4gY2F1c2U7XG5cdGNvbnN0IHRycGNFcnJvciA9IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdFx0Y2F1c2Vcblx0fSk7XG5cdGlmIChjYXVzZSBpbnN0YW5jZW9mIEVycm9yICYmIGNhdXNlLnN0YWNrKSB0cnBjRXJyb3Iuc3RhY2sgPSBjYXVzZS5zdGFjaztcblx0cmV0dXJuIHRycGNFcnJvcjtcbn1cbnZhciBUUlBDRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcblx0Y29uc3RydWN0b3Iob3B0cykge1xuXHRcdHZhciBfcmVmLCBfb3B0cyRtZXNzYWdlLCBfdGhpcyRjYXVzZTtcblx0XHRjb25zdCBjYXVzZSA9IGdldENhdXNlRnJvbVVua25vd24ob3B0cy5jYXVzZSk7XG5cdFx0Y29uc3QgbWVzc2FnZSA9IChfcmVmID0gKF9vcHRzJG1lc3NhZ2UgPSBvcHRzLm1lc3NhZ2UpICE9PSBudWxsICYmIF9vcHRzJG1lc3NhZ2UgIT09IHZvaWQgMCA/IF9vcHRzJG1lc3NhZ2UgOiBjYXVzZSA9PT0gbnVsbCB8fCBjYXVzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2F1c2UubWVzc2FnZSkgIT09IG51bGwgJiYgX3JlZiAhPT0gdm9pZCAwID8gX3JlZiA6IG9wdHMuY29kZTtcblx0XHRzdXBlcihtZXNzYWdlLCB7IGNhdXNlIH0pO1xuXHRcdCgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgXCJjYXVzZVwiLCB2b2lkIDApO1xuXHRcdCgwLCBpbXBvcnRfZGVmaW5lUHJvcGVydHkuZGVmYXVsdCkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG5cdFx0dGhpcy5jb2RlID0gb3B0cy5jb2RlO1xuXHRcdHRoaXMubmFtZSA9IFwiVFJQQ0Vycm9yXCI7XG5cdFx0KF90aGlzJGNhdXNlID0gdGhpcy5jYXVzZSkgIT09IG51bGwgJiYgX3RoaXMkY2F1c2UgIT09IHZvaWQgMCB8fCAodGhpcy5jYXVzZSA9IGNhdXNlKTtcblx0fVxufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC90cmFuc2Zvcm1lci50c1xudmFyIGltcG9ydF9vYmplY3RTcHJlYWQyJDEgPSBfX3RvRVNNKHJlcXVpcmVfb2JqZWN0U3ByZWFkMigpLCAxKTtcbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBnZXREYXRhVHJhbnNmb3JtZXIodHJhbnNmb3JtZXIpIHtcblx0aWYgKFwiaW5wdXRcIiBpbiB0cmFuc2Zvcm1lcikgcmV0dXJuIHRyYW5zZm9ybWVyO1xuXHRyZXR1cm4ge1xuXHRcdGlucHV0OiB0cmFuc2Zvcm1lcixcblx0XHRvdXRwdXQ6IHRyYW5zZm9ybWVyXG5cdH07XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuY29uc3QgZGVmYXVsdFRyYW5zZm9ybWVyID0ge1xuXHRpbnB1dDoge1xuXHRcdHNlcmlhbGl6ZTogKG9iaikgPT4gb2JqLFxuXHRcdGRlc2VyaWFsaXplOiAob2JqKSA9PiBvYmpcblx0fSxcblx0b3V0cHV0OiB7XG5cdFx0c2VyaWFsaXplOiAob2JqKSA9PiBvYmosXG5cdFx0ZGVzZXJpYWxpemU6IChvYmopID0+IG9ialxuXHR9XG59O1xuZnVuY3Rpb24gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW0pIHtcblx0aWYgKFwiZXJyb3JcIiBpbiBpdGVtKSByZXR1cm4gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoe30sIGl0ZW0pLCB7fSwgeyBlcnJvcjogY29uZmlnLnRyYW5zZm9ybWVyLm91dHB1dC5zZXJpYWxpemUoaXRlbS5lcnJvcikgfSk7XG5cdGlmIChcImRhdGFcIiBpbiBpdGVtLnJlc3VsdCkgcmV0dXJuICgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKHt9LCBpdGVtKSwge30sIHsgcmVzdWx0OiAoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSgoMCwgaW1wb3J0X29iamVjdFNwcmVhZDIkMS5kZWZhdWx0KSh7fSwgaXRlbS5yZXN1bHQpLCB7fSwgeyBkYXRhOiBjb25maWcudHJhbnNmb3JtZXIub3V0cHV0LnNlcmlhbGl6ZShpdGVtLnJlc3VsdC5kYXRhKSB9KSB9KTtcblx0cmV0dXJuIGl0ZW07XG59XG4vKipcbiogVGFrZXMgYSB1bnNlcmlhbGl6ZWQgYFRSUENSZXNwb25zZWAgYW5kIHNlcmlhbGl6ZXMgaXQgd2l0aCB0aGUgcm91dGVyJ3MgdHJhbnNmb3JtZXJzXG4qKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVRSUENSZXNwb25zZShjb25maWcsIGl0ZW1Pckl0ZW1zKSB7XG5cdHJldHVybiBBcnJheS5pc0FycmF5KGl0ZW1Pckl0ZW1zKSA/IGl0ZW1Pckl0ZW1zLm1hcCgoaXRlbSkgPT4gdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlSXRlbShjb25maWcsIGl0ZW0pKSA6IHRyYW5zZm9ybVRSUENSZXNwb25zZUl0ZW0oY29uZmlnLCBpdGVtT3JJdGVtcyk7XG59XG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHRJbm5lcihyZXNwb25zZSwgdHJhbnNmb3JtZXIpIHtcblx0aWYgKFwiZXJyb3JcIiBpbiByZXNwb25zZSkge1xuXHRcdGNvbnN0IGVycm9yID0gdHJhbnNmb3JtZXIuZGVzZXJpYWxpemUocmVzcG9uc2UuZXJyb3IpO1xuXHRcdHJldHVybiB7XG5cdFx0XHRvazogZmFsc2UsXG5cdFx0XHRlcnJvcjogKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyJDEuZGVmYXVsdCkoe30sIHJlc3BvbnNlKSwge30sIHsgZXJyb3IgfSlcblx0XHR9O1xuXHR9XG5cdGNvbnN0IHJlc3VsdCA9ICgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMiQxLmRlZmF1bHQpKHt9LCByZXNwb25zZS5yZXN1bHQpLCAoIXJlc3BvbnNlLnJlc3VsdC50eXBlIHx8IHJlc3BvbnNlLnJlc3VsdC50eXBlID09PSBcImRhdGFcIikgJiYge1xuXHRcdHR5cGU6IFwiZGF0YVwiLFxuXHRcdGRhdGE6IHRyYW5zZm9ybWVyLmRlc2VyaWFsaXplKHJlc3BvbnNlLnJlc3VsdC5kYXRhKVxuXHR9KTtcblx0cmV0dXJuIHtcblx0XHRvazogdHJ1ZSxcblx0XHRyZXN1bHRcblx0fTtcbn1cbnZhciBUcmFuc2Zvcm1SZXN1bHRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHRzdXBlcihcIlVuYWJsZSB0byB0cmFuc2Zvcm0gcmVzcG9uc2UgZnJvbSBzZXJ2ZXJcIik7XG5cdH1cbn07XG4vKipcbiogVHJhbnNmb3JtcyBhbmQgdmFsaWRhdGVzIHRoYXQgdGhlIHJlc3VsdCBpcyBhIHZhbGlkIFRSUENSZXNwb25zZVxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiB0cmFuc2Zvcm1SZXN1bHQocmVzcG9uc2UsIHRyYW5zZm9ybWVyKSB7XG5cdGxldCByZXN1bHQ7XG5cdHRyeSB7XG5cdFx0cmVzdWx0ID0gdHJhbnNmb3JtUmVzdWx0SW5uZXIocmVzcG9uc2UsIHRyYW5zZm9ybWVyKTtcblx0fSBjYXRjaCAoX3VudXNlZCkge1xuXHRcdHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuXHR9XG5cdGlmICghcmVzdWx0Lm9rICYmICghaXNPYmplY3QocmVzdWx0LmVycm9yLmVycm9yKSB8fCB0eXBlb2YgcmVzdWx0LmVycm9yLmVycm9yW1wiY29kZVwiXSAhPT0gXCJudW1iZXJcIikpIHRocm93IG5ldyBUcmFuc2Zvcm1SZXN1bHRFcnJvcigpO1xuXHRpZiAocmVzdWx0Lm9rICYmICFpc09iamVjdChyZXN1bHQucmVzdWx0KSkgdGhyb3cgbmV3IFRyYW5zZm9ybVJlc3VsdEVycm9yKCk7XG5cdHJldHVybiByZXN1bHQ7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvcm91dGVyLnRzXG52YXIgaW1wb3J0X29iamVjdFNwcmVhZDIgPSBfX3RvRVNNKHJlcXVpcmVfb2JqZWN0U3ByZWFkMigpLCAxKTtcbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5jb25zdCBsYXp5TWFya2VyID0gXCJsYXp5TWFya2VyXCI7XG5mdW5jdGlvbiBvbmNlKGZuKSB7XG5cdGNvbnN0IHVuY2FsbGVkID0gU3ltYm9sKCk7XG5cdGxldCByZXN1bHQgPSB1bmNhbGxlZDtcblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAocmVzdWx0ID09PSB1bmNhbGxlZCkgcmVzdWx0ID0gZm4oKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xufVxuLyoqXG4qIExhenkgbG9hZCBhIHJvdXRlclxuKiBAc2VlIGh0dHBzOi8vdHJwYy5pby9kb2NzL3NlcnZlci9tZXJnaW5nLXJvdXRlcnMjbGF6eS1sb2FkXG4qL1xuZnVuY3Rpb24gbGF6eShpbXBvcnRSb3V0ZXIpIHtcblx0YXN5bmMgZnVuY3Rpb24gcmVzb2x2ZSgpIHtcblx0XHRjb25zdCBtb2QgPSBhd2FpdCBpbXBvcnRSb3V0ZXIoKTtcblx0XHRpZiAoaXNSb3V0ZXIobW9kKSkgcmV0dXJuIG1vZDtcblx0XHRjb25zdCByb3V0ZXJzID0gT2JqZWN0LnZhbHVlcyhtb2QpO1xuXHRcdGlmIChyb3V0ZXJzLmxlbmd0aCAhPT0gMSB8fCAhaXNSb3V0ZXIocm91dGVyc1swXSkpIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm91dGVyIG1vZHVsZSAtIGVpdGhlciBkZWZpbmUgZXhhY3RseSAxIGV4cG9ydCBvciByZXR1cm4gdGhlIHJvdXRlciBkaXJlY3RseS5cXG5FeGFtcGxlOiBgbGF6eSgoKSA9PiBpbXBvcnQoJy4vc2xvdy5qcycpLnRoZW4oKG0pID0+IG0uc2xvd1JvdXRlcikpYFwiKTtcblx0XHRyZXR1cm4gcm91dGVyc1swXTtcblx0fVxuXHRyZXNvbHZlW2xhenlNYXJrZXJdID0gdHJ1ZTtcblx0cmV0dXJuIHJlc29sdmU7XG59XG5mdW5jdGlvbiBpc0xhenkoaW5wdXQpIHtcblx0cmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gXCJmdW5jdGlvblwiICYmIGxhenlNYXJrZXIgaW4gaW5wdXQ7XG59XG5mdW5jdGlvbiBpc1JvdXRlcih2YWx1ZSkge1xuXHRyZXR1cm4gaXNPYmplY3QodmFsdWUpICYmIGlzT2JqZWN0KHZhbHVlW1wiX2RlZlwiXSkgJiYgXCJyb3V0ZXJcIiBpbiB2YWx1ZVtcIl9kZWZcIl07XG59XG5jb25zdCBlbXB0eVJvdXRlciA9IHtcblx0X2N0eDogbnVsbCxcblx0X2Vycm9yU2hhcGU6IG51bGwsXG5cdF9tZXRhOiBudWxsLFxuXHRxdWVyaWVzOiB7fSxcblx0bXV0YXRpb25zOiB7fSxcblx0c3Vic2NyaXB0aW9uczoge30sXG5cdGVycm9yRm9ybWF0dGVyOiBkZWZhdWx0Rm9ybWF0dGVyLFxuXHR0cmFuc2Zvcm1lcjogZGVmYXVsdFRyYW5zZm9ybWVyXG59O1xuLyoqXG4qIFJlc2VydmVkIHdvcmRzIHRoYXQgY2FuJ3QgYmUgdXNlZCBhcyByb3V0ZXIgb3IgcHJvY2VkdXJlIG5hbWVzXG4qL1xuY29uc3QgcmVzZXJ2ZWRXb3JkcyA9IFtcblx0XCJ0aGVuXCIsXG5cdFwiY2FsbFwiLFxuXHRcImFwcGx5XCJcbl07XG4vKipcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVyRmFjdG9yeShjb25maWcpIHtcblx0ZnVuY3Rpb24gY3JlYXRlUm91dGVySW5uZXIoaW5wdXQpIHtcblx0XHRjb25zdCByZXNlcnZlZFdvcmRzVXNlZCA9IG5ldyBTZXQoT2JqZWN0LmtleXMoaW5wdXQpLmZpbHRlcigodikgPT4gcmVzZXJ2ZWRXb3Jkcy5pbmNsdWRlcyh2KSkpO1xuXHRcdGlmIChyZXNlcnZlZFdvcmRzVXNlZC5zaXplID4gMCkgdGhyb3cgbmV3IEVycm9yKFwiUmVzZXJ2ZWQgd29yZHMgdXNlZCBpbiBgcm91dGVyKHt9KWAgY2FsbDogXCIgKyBBcnJheS5mcm9tKHJlc2VydmVkV29yZHNVc2VkKS5qb2luKFwiLCBcIikpO1xuXHRcdGNvbnN0IHByb2NlZHVyZXMgPSBvbWl0UHJvdG90eXBlKHt9KTtcblx0XHRjb25zdCBsYXp5JDEgPSBvbWl0UHJvdG90eXBlKHt9KTtcblx0XHRmdW5jdGlvbiBjcmVhdGVMYXp5TG9hZGVyKG9wdHMpIHtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHJlZjogb3B0cy5yZWYsXG5cdFx0XHRcdGxvYWQ6IG9uY2UoYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGNvbnN0IHJvdXRlciQxID0gYXdhaXQgb3B0cy5yZWYoKTtcblx0XHRcdFx0XHRjb25zdCBsYXp5UGF0aCA9IFsuLi5vcHRzLnBhdGgsIG9wdHMua2V5XTtcblx0XHRcdFx0XHRjb25zdCBsYXp5S2V5ID0gbGF6eVBhdGguam9pbihcIi5cIik7XG5cdFx0XHRcdFx0b3B0cy5hZ2dyZWdhdGVbb3B0cy5rZXldID0gc3RlcChyb3V0ZXIkMS5fZGVmLnJlY29yZCwgbGF6eVBhdGgpO1xuXHRcdFx0XHRcdGRlbGV0ZSBsYXp5JDFbbGF6eUtleV07XG5cdFx0XHRcdFx0Zm9yIChjb25zdCBbbmVzdGVkS2V5LCBuZXN0ZWRJdGVtXSBvZiBPYmplY3QuZW50cmllcyhyb3V0ZXIkMS5fZGVmLmxhenkpKSB7XG5cdFx0XHRcdFx0XHRjb25zdCBuZXN0ZWRSb3V0ZXJLZXkgPSBbLi4ubGF6eVBhdGgsIG5lc3RlZEtleV0uam9pbihcIi5cIik7XG5cdFx0XHRcdFx0XHRsYXp5JDFbbmVzdGVkUm91dGVyS2V5XSA9IGNyZWF0ZUxhenlMb2FkZXIoe1xuXHRcdFx0XHRcdFx0XHRyZWY6IG5lc3RlZEl0ZW0ucmVmLFxuXHRcdFx0XHRcdFx0XHRwYXRoOiBsYXp5UGF0aCxcblx0XHRcdFx0XHRcdFx0a2V5OiBuZXN0ZWRLZXksXG5cdFx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZTogb3B0cy5hZ2dyZWdhdGVbb3B0cy5rZXldXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRmdW5jdGlvbiBzdGVwKGZyb20sIHBhdGggPSBbXSkge1xuXHRcdFx0Y29uc3QgYWdncmVnYXRlID0gb21pdFByb3RvdHlwZSh7fSk7XG5cdFx0XHRmb3IgKGNvbnN0IFtrZXksIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKGZyb20gIT09IG51bGwgJiYgZnJvbSAhPT0gdm9pZCAwID8gZnJvbSA6IHt9KSkge1xuXHRcdFx0XHRpZiAoaXNMYXp5KGl0ZW0pKSB7XG5cdFx0XHRcdFx0bGF6eSQxW1suLi5wYXRoLCBrZXldLmpvaW4oXCIuXCIpXSA9IGNyZWF0ZUxhenlMb2FkZXIoe1xuXHRcdFx0XHRcdFx0cGF0aCxcblx0XHRcdFx0XHRcdHJlZjogaXRlbSxcblx0XHRcdFx0XHRcdGtleSxcblx0XHRcdFx0XHRcdGFnZ3JlZ2F0ZVxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpc1JvdXRlcihpdGVtKSkge1xuXHRcdFx0XHRcdGFnZ3JlZ2F0ZVtrZXldID0gc3RlcChpdGVtLl9kZWYucmVjb3JkLCBbLi4ucGF0aCwga2V5XSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFpc1Byb2NlZHVyZShpdGVtKSkge1xuXHRcdFx0XHRcdGFnZ3JlZ2F0ZVtrZXldID0gc3RlcChpdGVtLCBbLi4ucGF0aCwga2V5XSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc3QgbmV3UGF0aCA9IFsuLi5wYXRoLCBrZXldLmpvaW4oXCIuXCIpO1xuXHRcdFx0XHRpZiAocHJvY2VkdXJlc1tuZXdQYXRoXSkgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUga2V5OiAke25ld1BhdGh9YCk7XG5cdFx0XHRcdHByb2NlZHVyZXNbbmV3UGF0aF0gPSBpdGVtO1xuXHRcdFx0XHRhZ2dyZWdhdGVba2V5XSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWdncmVnYXRlO1xuXHRcdH1cblx0XHRjb25zdCByZWNvcmQgPSBzdGVwKGlucHV0KTtcblx0XHRjb25zdCBfZGVmID0gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7XG5cdFx0XHRfY29uZmlnOiBjb25maWcsXG5cdFx0XHRyb3V0ZXI6IHRydWUsXG5cdFx0XHRwcm9jZWR1cmVzLFxuXHRcdFx0bGF6eTogbGF6eSQxXG5cdFx0fSwgZW1wdHlSb3V0ZXIpLCB7fSwgeyByZWNvcmQgfSk7XG5cdFx0Y29uc3Qgcm91dGVyID0gKDAsIGltcG9ydF9vYmplY3RTcHJlYWQyLmRlZmF1bHQpKCgwLCBpbXBvcnRfb2JqZWN0U3ByZWFkMi5kZWZhdWx0KSh7fSwgcmVjb3JkKSwge30sIHtcblx0XHRcdF9kZWYsXG5cdFx0XHRjcmVhdGVDYWxsZXI6IGNyZWF0ZUNhbGxlckZhY3RvcnkoKSh7IF9kZWYgfSlcblx0XHR9KTtcblx0XHRyZXR1cm4gcm91dGVyO1xuXHR9XG5cdHJldHVybiBjcmVhdGVSb3V0ZXJJbm5lcjtcbn1cbmZ1bmN0aW9uIGlzUHJvY2VkdXJlKHByb2NlZHVyZU9yUm91dGVyKSB7XG5cdHJldHVybiB0eXBlb2YgcHJvY2VkdXJlT3JSb3V0ZXIgPT09IFwiZnVuY3Rpb25cIjtcbn1cbi8qKlxuKiBAaW50ZXJuYWxcbiovXG5hc3luYyBmdW5jdGlvbiBnZXRQcm9jZWR1cmVBdFBhdGgocm91dGVyLCBwYXRoKSB7XG5cdGNvbnN0IHsgX2RlZiB9ID0gcm91dGVyO1xuXHRsZXQgcHJvY2VkdXJlID0gX2RlZi5wcm9jZWR1cmVzW3BhdGhdO1xuXHR3aGlsZSAoIXByb2NlZHVyZSkge1xuXHRcdGNvbnN0IGtleSA9IE9iamVjdC5rZXlzKF9kZWYubGF6eSkuZmluZCgoa2V5JDEpID0+IHBhdGguc3RhcnRzV2l0aChrZXkkMSkpO1xuXHRcdGlmICgha2V5KSByZXR1cm4gbnVsbDtcblx0XHRjb25zdCBsYXp5Um91dGVyID0gX2RlZi5sYXp5W2tleV07XG5cdFx0YXdhaXQgbGF6eVJvdXRlci5sb2FkKCk7XG5cdFx0cHJvY2VkdXJlID0gX2RlZi5wcm9jZWR1cmVzW3BhdGhdO1xuXHR9XG5cdHJldHVybiBwcm9jZWR1cmU7XG59XG4vKipcbiogQGludGVybmFsXG4qL1xuYXN5bmMgZnVuY3Rpb24gY2FsbFByb2NlZHVyZShvcHRzKSB7XG5cdGNvbnN0IHsgdHlwZSwgcGF0aCB9ID0gb3B0cztcblx0Y29uc3QgcHJvYyA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChvcHRzLnJvdXRlciwgcGF0aCk7XG5cdGlmICghcHJvYyB8fCAhaXNQcm9jZWR1cmUocHJvYykgfHwgcHJvYy5fZGVmLnR5cGUgIT09IHR5cGUgJiYgIW9wdHMuYWxsb3dNZXRob2RPdmVycmlkZSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0Y29kZTogXCJOT1RfRk9VTkRcIixcblx0XHRtZXNzYWdlOiBgTm8gXCIke3R5cGV9XCItcHJvY2VkdXJlIG9uIHBhdGggXCIke3BhdGh9XCJgXG5cdH0pO1xuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLS0gQHByZXNlcnZlICovXG5cdGlmIChwcm9jLl9kZWYudHlwZSAhPT0gdHlwZSAmJiBvcHRzLmFsbG93TWV0aG9kT3ZlcnJpZGUgJiYgcHJvYy5fZGVmLnR5cGUgPT09IFwic3Vic2NyaXB0aW9uXCIpIHRocm93IG5ldyBUUlBDRXJyb3Ioe1xuXHRcdGNvZGU6IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIixcblx0XHRtZXNzYWdlOiBgTWV0aG9kIG92ZXJyaWRlIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHN1YnNjcmlwdGlvbnNgXG5cdH0pO1xuXHRyZXR1cm4gcHJvYyhvcHRzKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhbGxlckZhY3RvcnkoKSB7XG5cdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDYWxsZXJJbm5lcihyb3V0ZXIpIHtcblx0XHRjb25zdCB7IF9kZWYgfSA9IHJvdXRlcjtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ2FsbGVyKGN0eE9yQ2FsbGJhY2ssIG9wdHMpIHtcblx0XHRcdHJldHVybiBjcmVhdGVSZWN1cnNpdmVQcm94eShhc3luYyAoaW5uZXJPcHRzKSA9PiB7XG5cdFx0XHRcdGNvbnN0IHsgcGF0aCwgYXJncyB9ID0gaW5uZXJPcHRzO1xuXHRcdFx0XHRjb25zdCBmdWxsUGF0aCA9IHBhdGguam9pbihcIi5cIik7XG5cdFx0XHRcdGlmIChwYXRoLmxlbmd0aCA9PT0gMSAmJiBwYXRoWzBdID09PSBcIl9kZWZcIikgcmV0dXJuIF9kZWY7XG5cdFx0XHRcdGNvbnN0IHByb2NlZHVyZSA9IGF3YWl0IGdldFByb2NlZHVyZUF0UGF0aChyb3V0ZXIsIGZ1bGxQYXRoKTtcblx0XHRcdFx0bGV0IGN0eCA9IHZvaWQgMDtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRpZiAoIXByb2NlZHVyZSkgdGhyb3cgbmV3IFRSUENFcnJvcih7XG5cdFx0XHRcdFx0XHRjb2RlOiBcIk5PVF9GT1VORFwiLFxuXHRcdFx0XHRcdFx0bWVzc2FnZTogYE5vIHByb2NlZHVyZSBmb3VuZCBvbiBwYXRoIFwiJHtwYXRofVwiYFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGN0eCA9IGlzRnVuY3Rpb24oY3R4T3JDYWxsYmFjaykgPyBhd2FpdCBQcm9taXNlLnJlc29sdmUoY3R4T3JDYWxsYmFjaygpKSA6IGN0eE9yQ2FsbGJhY2s7XG5cdFx0XHRcdFx0cmV0dXJuIGF3YWl0IHByb2NlZHVyZSh7XG5cdFx0XHRcdFx0XHRwYXRoOiBmdWxsUGF0aCxcblx0XHRcdFx0XHRcdGdldFJhd0lucHV0OiBhc3luYyAoKSA9PiBhcmdzWzBdLFxuXHRcdFx0XHRcdFx0Y3R4LFxuXHRcdFx0XHRcdFx0dHlwZTogcHJvY2VkdXJlLl9kZWYudHlwZSxcblx0XHRcdFx0XHRcdHNpZ25hbDogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNpZ25hbFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGNhdGNoIChjYXVzZSkge1xuXHRcdFx0XHRcdHZhciBfb3B0cyRvbkVycm9yLCBfcHJvY2VkdXJlJF9kZWYkdHlwZTtcblx0XHRcdFx0XHRvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCB8fCAoX29wdHMkb25FcnJvciA9IG9wdHMub25FcnJvcikgPT09IG51bGwgfHwgX29wdHMkb25FcnJvciA9PT0gdm9pZCAwIHx8IF9vcHRzJG9uRXJyb3IuY2FsbChvcHRzLCB7XG5cdFx0XHRcdFx0XHRjdHgsXG5cdFx0XHRcdFx0XHRlcnJvcjogZ2V0VFJQQ0Vycm9yRnJvbVVua25vd24oY2F1c2UpLFxuXHRcdFx0XHRcdFx0aW5wdXQ6IGFyZ3NbMF0sXG5cdFx0XHRcdFx0XHRwYXRoOiBmdWxsUGF0aCxcblx0XHRcdFx0XHRcdHR5cGU6IChfcHJvY2VkdXJlJF9kZWYkdHlwZSA9IHByb2NlZHVyZSA9PT0gbnVsbCB8fCBwcm9jZWR1cmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2NlZHVyZS5fZGVmLnR5cGUpICE9PSBudWxsICYmIF9wcm9jZWR1cmUkX2RlZiR0eXBlICE9PSB2b2lkIDAgPyBfcHJvY2VkdXJlJF9kZWYkdHlwZSA6IFwidW5rbm93blwiXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0dGhyb3cgY2F1c2U7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH07XG5cdH07XG59XG5mdW5jdGlvbiBtZXJnZVJvdXRlcnMoLi4ucm91dGVyTGlzdCkge1xuXHR2YXIgX3JvdXRlckxpc3QkO1xuXHRjb25zdCByZWNvcmQgPSBtZXJnZVdpdGhvdXRPdmVycmlkZXMoe30sIC4uLnJvdXRlckxpc3QubWFwKChyKSA9PiByLl9kZWYucmVjb3JkKSk7XG5cdGNvbnN0IGVycm9yRm9ybWF0dGVyID0gcm91dGVyTGlzdC5yZWR1Y2UoKGN1cnJlbnRFcnJvckZvcm1hdHRlciwgbmV4dFJvdXRlcikgPT4ge1xuXHRcdGlmIChuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAmJiBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlcikge1xuXHRcdFx0aWYgKGN1cnJlbnRFcnJvckZvcm1hdHRlciAhPT0gZGVmYXVsdEZvcm1hdHRlciAmJiBjdXJyZW50RXJyb3JGb3JtYXR0ZXIgIT09IG5leHRSb3V0ZXIuX2RlZi5fY29uZmlnLmVycm9yRm9ybWF0dGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJZb3Ugc2VlbSB0byBoYXZlIHNldmVyYWwgZXJyb3IgZm9ybWF0dGVyc1wiKTtcblx0XHRcdHJldHVybiBuZXh0Um91dGVyLl9kZWYuX2NvbmZpZy5lcnJvckZvcm1hdHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnJlbnRFcnJvckZvcm1hdHRlcjtcblx0fSwgZGVmYXVsdEZvcm1hdHRlcik7XG5cdGNvbnN0IHRyYW5zZm9ybWVyID0gcm91dGVyTGlzdC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcblx0XHRpZiAoY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgJiYgY3VycmVudC5fZGVmLl9jb25maWcudHJhbnNmb3JtZXIgIT09IGRlZmF1bHRUcmFuc2Zvcm1lcikge1xuXHRcdFx0aWYgKHByZXYgIT09IGRlZmF1bHRUcmFuc2Zvcm1lciAmJiBwcmV2ICE9PSBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lcikgdGhyb3cgbmV3IEVycm9yKFwiWW91IHNlZW0gdG8gaGF2ZSBzZXZlcmFsIHRyYW5zZm9ybWVyc1wiKTtcblx0XHRcdHJldHVybiBjdXJyZW50Ll9kZWYuX2NvbmZpZy50cmFuc2Zvcm1lcjtcblx0XHR9XG5cdFx0cmV0dXJuIHByZXY7XG5cdH0sIGRlZmF1bHRUcmFuc2Zvcm1lcik7XG5cdGNvbnN0IHJvdXRlciA9IGNyZWF0ZVJvdXRlckZhY3Rvcnkoe1xuXHRcdGVycm9yRm9ybWF0dGVyLFxuXHRcdHRyYW5zZm9ybWVyLFxuXHRcdGlzRGV2OiByb3V0ZXJMaXN0LmV2ZXJ5KChyKSA9PiByLl9kZWYuX2NvbmZpZy5pc0RldiksXG5cdFx0YWxsb3dPdXRzaWRlT2ZTZXJ2ZXI6IHJvdXRlckxpc3QuZXZlcnkoKHIpID0+IHIuX2RlZi5fY29uZmlnLmFsbG93T3V0c2lkZU9mU2VydmVyKSxcblx0XHRpc1NlcnZlcjogcm91dGVyTGlzdC5ldmVyeSgocikgPT4gci5fZGVmLl9jb25maWcuaXNTZXJ2ZXIpLFxuXHRcdCR0eXBlczogKF9yb3V0ZXJMaXN0JCA9IHJvdXRlckxpc3RbMF0pID09PSBudWxsIHx8IF9yb3V0ZXJMaXN0JCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3JvdXRlckxpc3QkLl9kZWYuX2NvbmZpZy4kdHlwZXNcblx0fSkocmVjb3JkKTtcblx0cmV0dXJuIHJvdXRlcjtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9zdHJlYW0vdHJhY2tlZC50c1xuY29uc3QgdHJhY2tlZFN5bWJvbCA9IFN5bWJvbCgpO1xuLyoqXG4qIFByb2R1Y2UgYSB0eXBlZCBzZXJ2ZXItc2VudCBldmVudCBtZXNzYWdlXG4qIEBkZXByZWNhdGVkIHVzZSBgdHJhY2tlZChpZCwgZGF0YSlgIGluc3RlYWRcbiovXG5mdW5jdGlvbiBzc2UoZXZlbnQpIHtcblx0cmV0dXJuIHRyYWNrZWQoZXZlbnQuaWQsIGV2ZW50LmRhdGEpO1xufVxuZnVuY3Rpb24gaXNUcmFja2VkRW52ZWxvcGUodmFsdWUpIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlWzJdID09PSB0cmFja2VkU3ltYm9sO1xufVxuLyoqXG4qIEF1dG9tYXRpY2FsbHkgdHJhY2sgYW4gZXZlbnQgc28gdGhhdCBpdCBjYW4gYmUgcmVzdW1lZCBmcm9tIGEgZ2l2ZW4gaWQgaWYgdGhlIGNvbm5lY3Rpb24gaXMgbG9zdFxuKi9cbmZ1bmN0aW9uIHRyYWNrZWQoaWQsIGRhdGEpIHtcblx0aWYgKGlkID09PSBcIlwiKSB0aHJvdyBuZXcgRXJyb3IoXCJgaWRgIG11c3Qgbm90IGJlIGFuIGVtcHR5IHN0cmluZyBhcyBlbXB0eSBzdHJpbmcgaXMgdGhlIHNhbWUgYXMgbm90IHNldHRpbmcgdGhlIGlkIGF0IGFsbFwiKTtcblx0cmV0dXJuIFtcblx0XHRpZCxcblx0XHRkYXRhLFxuXHRcdHRyYWNrZWRTeW1ib2xcblx0XTtcbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBUUlBDRXJyb3IsIGNhbGxQcm9jZWR1cmUsIGNyZWF0ZUNhbGxlckZhY3RvcnksIGNyZWF0ZVJvdXRlckZhY3RvcnksIGRlZmF1bHRGb3JtYXR0ZXIsIGRlZmF1bHRUcmFuc2Zvcm1lciwgZ2V0Q2F1c2VGcm9tVW5rbm93biwgZ2V0RGF0YVRyYW5zZm9ybWVyLCBnZXRQcm9jZWR1cmVBdFBhdGgsIGdldFRSUENFcnJvckZyb21Vbmtub3duLCBpc1RyYWNrZWRFbnZlbG9wZSwgbGF6eSwgbWVyZ2VSb3V0ZXJzLCBzc2UsIHRyYWNrZWQsIHRyYW5zZm9ybVJlc3VsdCwgdHJhbnNmb3JtVFJQQ1Jlc3BvbnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFja2VkLUJsejhYT2YxLm1qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/tracked-Blz8XOf1.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/utils-CLZnJdb_.mjs":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/utils-CLZnJdb_.mjs ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TRPC_ERROR_CODES_BY_KEY: () => (/* binding */ TRPC_ERROR_CODES_BY_KEY),\n/* harmony export */   TRPC_ERROR_CODES_BY_NUMBER: () => (/* binding */ TRPC_ERROR_CODES_BY_NUMBER),\n/* harmony export */   abortSignalsAnyPonyfill: () => (/* binding */ abortSignalsAnyPonyfill),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   identity: () => (/* binding */ identity),\n/* harmony export */   isAsyncIterable: () => (/* binding */ isAsyncIterable),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isObject: () => (/* binding */ isObject),\n/* harmony export */   mergeWithoutOverrides: () => (/* binding */ mergeWithoutOverrides),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   omitPrototype: () => (/* binding */ omitPrototype),\n/* harmony export */   retryableRpcCodes: () => (/* binding */ retryableRpcCodes),\n/* harmony export */   run: () => (/* binding */ run),\n/* harmony export */   sleep: () => (/* binding */ sleep)\n/* harmony export */ });\n//#region src/unstable-core-do-not-import/rpc/codes.ts\n/**\n* JSON-RPC 2.0 Error codes\n*\n* `-32000` to `-32099` are reserved for implementation-defined server-errors.\n* For tRPC we're copying the last digits of HTTP 4XX errors.\n*/\nconst TRPC_ERROR_CODES_BY_KEY = {\n\tPARSE_ERROR: -32700,\n\tBAD_REQUEST: -32600,\n\tINTERNAL_SERVER_ERROR: -32603,\n\tNOT_IMPLEMENTED: -32603,\n\tBAD_GATEWAY: -32603,\n\tSERVICE_UNAVAILABLE: -32603,\n\tGATEWAY_TIMEOUT: -32603,\n\tUNAUTHORIZED: -32001,\n\tPAYMENT_REQUIRED: -32002,\n\tFORBIDDEN: -32003,\n\tNOT_FOUND: -32004,\n\tMETHOD_NOT_SUPPORTED: -32005,\n\tTIMEOUT: -32008,\n\tCONFLICT: -32009,\n\tPRECONDITION_FAILED: -32012,\n\tPAYLOAD_TOO_LARGE: -32013,\n\tUNSUPPORTED_MEDIA_TYPE: -32015,\n\tUNPROCESSABLE_CONTENT: -32022,\n\tPRECONDITION_REQUIRED: -32028,\n\tTOO_MANY_REQUESTS: -32029,\n\tCLIENT_CLOSED_REQUEST: -32099\n};\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n\t[-32700]: \"PARSE_ERROR\",\n\t[-32600]: \"BAD_REQUEST\",\n\t[-32603]: \"INTERNAL_SERVER_ERROR\",\n\t[-32001]: \"UNAUTHORIZED\",\n\t[-32002]: \"PAYMENT_REQUIRED\",\n\t[-32003]: \"FORBIDDEN\",\n\t[-32004]: \"NOT_FOUND\",\n\t[-32005]: \"METHOD_NOT_SUPPORTED\",\n\t[-32008]: \"TIMEOUT\",\n\t[-32009]: \"CONFLICT\",\n\t[-32012]: \"PRECONDITION_FAILED\",\n\t[-32013]: \"PAYLOAD_TOO_LARGE\",\n\t[-32015]: \"UNSUPPORTED_MEDIA_TYPE\",\n\t[-32022]: \"UNPROCESSABLE_CONTENT\",\n\t[-32028]: \"PRECONDITION_REQUIRED\",\n\t[-32029]: \"TOO_MANY_REQUESTS\",\n\t[-32099]: \"CLIENT_CLOSED_REQUEST\"\n};\n/**\n* tRPC error codes that are considered retryable\n* With out of the box SSE, the client will reconnect when these errors are encountered\n*/\nconst retryableRpcCodes = [\n\tTRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n\tTRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n\tTRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n\tTRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n\n//#endregion\n//#region src/unstable-core-do-not-import/utils.ts\n/**\n* Ensures there are no duplicate keys when building a procedure.\n* @internal\n*/\nfunction mergeWithoutOverrides(obj1, ...objs) {\n\tconst newObj = Object.assign(Object.create(null), obj1);\n\tfor (const overrides of objs) for (const key in overrides) {\n\t\tif (key in newObj && newObj[key] !== overrides[key]) throw new Error(`Duplicate key ${key}`);\n\t\tnewObj[key] = overrides[key];\n\t}\n\treturn newObj;\n}\n/**\n* Check that value is object\n* @internal\n*/\nfunction isObject(value) {\n\treturn !!value && !Array.isArray(value) && typeof value === \"object\";\n}\nfunction isFunction(fn) {\n\treturn typeof fn === \"function\";\n}\n/**\n* Create an object without inheriting anything from `Object.prototype`\n* @internal\n*/\nfunction omitPrototype(obj) {\n\treturn Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === \"function\" && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n\treturn asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n* Run an IIFE\n*/\nconst run = (fn) => fn();\nfunction noop() {}\nfunction identity(it) {\n\treturn it;\n}\n/**\n* Generic runtime assertion function. Throws, if the condition is not `true`.\n*\n* Can be used as a slightly less dangerous variant of type assertions. Code\n* mistakes would be revealed at runtime then (hopefully during testing).\n*/\nfunction assert(condition, msg = \"no additional info\") {\n\tif (!condition) throw new Error(`AssertionError: ${msg}`);\n}\nfunction sleep(ms = 0) {\n\treturn new Promise((res) => setTimeout(res, ms));\n}\n/**\n* Ponyfill for\n* [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n*/\nfunction abortSignalsAnyPonyfill(signals) {\n\tif (typeof AbortSignal.any === \"function\") return AbortSignal.any(signals);\n\tconst ac = new AbortController();\n\tfor (const signal of signals) {\n\t\tif (signal.aborted) {\n\t\t\ttrigger();\n\t\t\tbreak;\n\t\t}\n\t\tsignal.addEventListener(\"abort\", trigger, { once: true });\n\t}\n\treturn ac.signal;\n\tfunction trigger() {\n\t\tac.abort();\n\t\tfor (const signal of signals) signal.removeEventListener(\"abort\", trigger);\n\t}\n}\n\n//#endregion\n\n//# sourceMappingURL=utils-CLZnJdb_.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zL25vZGVfbW9kdWxlcy9AdHJwYy9zZXJ2ZXIvZGlzdC91dGlscy1DTFpuSmRiXy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQUF3RixJQUFJO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELElBQUk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUM0TjtBQUM1TiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxoZXJpY1xcZHlhZC1hcHBzXFxyb3JrLXVuaXBhbG0tLS1DaC1uZy1uLW5nLWMtR3UtY29weVxcbm9kZV9tb2R1bGVzXFwucG5wbVxcQHRycGMrc2VydmVyQDExLjcuMV90eXBlc2NyaXB0QDUuOS4zXFxub2RlX21vZHVsZXNcXEB0cnBjXFxzZXJ2ZXJcXGRpc3RcXHV0aWxzLUNMWm5KZGJfLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyNyZWdpb24gc3JjL3Vuc3RhYmxlLWNvcmUtZG8tbm90LWltcG9ydC9ycGMvY29kZXMudHNcbi8qKlxuKiBKU09OLVJQQyAyLjAgRXJyb3IgY29kZXNcbipcbiogYC0zMjAwMGAgdG8gYC0zMjA5OWAgYXJlIHJlc2VydmVkIGZvciBpbXBsZW1lbnRhdGlvbi1kZWZpbmVkIHNlcnZlci1lcnJvcnMuXG4qIEZvciB0UlBDIHdlJ3JlIGNvcHlpbmcgdGhlIGxhc3QgZGlnaXRzIG9mIEhUVFAgNFhYIGVycm9ycy5cbiovXG5jb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSA9IHtcblx0UEFSU0VfRVJST1I6IC0zMjcwMCxcblx0QkFEX1JFUVVFU1Q6IC0zMjYwMCxcblx0SU5URVJOQUxfU0VSVkVSX0VSUk9SOiAtMzI2MDMsXG5cdE5PVF9JTVBMRU1FTlRFRDogLTMyNjAzLFxuXHRCQURfR0FURVdBWTogLTMyNjAzLFxuXHRTRVJWSUNFX1VOQVZBSUxBQkxFOiAtMzI2MDMsXG5cdEdBVEVXQVlfVElNRU9VVDogLTMyNjAzLFxuXHRVTkFVVEhPUklaRUQ6IC0zMjAwMSxcblx0UEFZTUVOVF9SRVFVSVJFRDogLTMyMDAyLFxuXHRGT1JCSURERU46IC0zMjAwMyxcblx0Tk9UX0ZPVU5EOiAtMzIwMDQsXG5cdE1FVEhPRF9OT1RfU1VQUE9SVEVEOiAtMzIwMDUsXG5cdFRJTUVPVVQ6IC0zMjAwOCxcblx0Q09ORkxJQ1Q6IC0zMjAwOSxcblx0UFJFQ09ORElUSU9OX0ZBSUxFRDogLTMyMDEyLFxuXHRQQVlMT0FEX1RPT19MQVJHRTogLTMyMDEzLFxuXHRVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiAtMzIwMTUsXG5cdFVOUFJPQ0VTU0FCTEVfQ09OVEVOVDogLTMyMDIyLFxuXHRQUkVDT05ESVRJT05fUkVRVUlSRUQ6IC0zMjAyOCxcblx0VE9PX01BTllfUkVRVUVTVFM6IC0zMjAyOSxcblx0Q0xJRU5UX0NMT1NFRF9SRVFVRVNUOiAtMzIwOTlcbn07XG5jb25zdCBUUlBDX0VSUk9SX0NPREVTX0JZX05VTUJFUiA9IHtcblx0Wy0zMjcwMF06IFwiUEFSU0VfRVJST1JcIixcblx0Wy0zMjYwMF06IFwiQkFEX1JFUVVFU1RcIixcblx0Wy0zMjYwM106IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsXG5cdFstMzIwMDFdOiBcIlVOQVVUSE9SSVpFRFwiLFxuXHRbLTMyMDAyXTogXCJQQVlNRU5UX1JFUVVJUkVEXCIsXG5cdFstMzIwMDNdOiBcIkZPUkJJRERFTlwiLFxuXHRbLTMyMDA0XTogXCJOT1RfRk9VTkRcIixcblx0Wy0zMjAwNV06IFwiTUVUSE9EX05PVF9TVVBQT1JURURcIixcblx0Wy0zMjAwOF06IFwiVElNRU9VVFwiLFxuXHRbLTMyMDA5XTogXCJDT05GTElDVFwiLFxuXHRbLTMyMDEyXTogXCJQUkVDT05ESVRJT05fRkFJTEVEXCIsXG5cdFstMzIwMTNdOiBcIlBBWUxPQURfVE9PX0xBUkdFXCIsXG5cdFstMzIwMTVdOiBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIixcblx0Wy0zMjAyMl06IFwiVU5QUk9DRVNTQUJMRV9DT05URU5UXCIsXG5cdFstMzIwMjhdOiBcIlBSRUNPTkRJVElPTl9SRVFVSVJFRFwiLFxuXHRbLTMyMDI5XTogXCJUT09fTUFOWV9SRVFVRVNUU1wiLFxuXHRbLTMyMDk5XTogXCJDTElFTlRfQ0xPU0VEX1JFUVVFU1RcIlxufTtcbi8qKlxuKiB0UlBDIGVycm9yIGNvZGVzIHRoYXQgYXJlIGNvbnNpZGVyZWQgcmV0cnlhYmxlXG4qIFdpdGggb3V0IG9mIHRoZSBib3ggU1NFLCB0aGUgY2xpZW50IHdpbGwgcmVjb25uZWN0IHdoZW4gdGhlc2UgZXJyb3JzIGFyZSBlbmNvdW50ZXJlZFxuKi9cbmNvbnN0IHJldHJ5YWJsZVJwY0NvZGVzID0gW1xuXHRUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5CQURfR0FURVdBWSxcblx0VFJQQ19FUlJPUl9DT0RFU19CWV9LRVkuU0VSVklDRV9VTkFWQUlMQUJMRSxcblx0VFJQQ19FUlJPUl9DT0RFU19CWV9LRVkuR0FURVdBWV9USU1FT1VULFxuXHRUUlBDX0VSUk9SX0NPREVTX0JZX0tFWS5JTlRFUk5BTF9TRVJWRVJfRVJST1Jcbl07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy91bnN0YWJsZS1jb3JlLWRvLW5vdC1pbXBvcnQvdXRpbHMudHNcbi8qKlxuKiBFbnN1cmVzIHRoZXJlIGFyZSBubyBkdXBsaWNhdGUga2V5cyB3aGVuIGJ1aWxkaW5nIGEgcHJvY2VkdXJlLlxuKiBAaW50ZXJuYWxcbiovXG5mdW5jdGlvbiBtZXJnZVdpdGhvdXRPdmVycmlkZXMob2JqMSwgLi4ub2Jqcykge1xuXHRjb25zdCBuZXdPYmogPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIG9iajEpO1xuXHRmb3IgKGNvbnN0IG92ZXJyaWRlcyBvZiBvYmpzKSBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcblx0XHRpZiAoa2V5IGluIG5ld09iaiAmJiBuZXdPYmpba2V5XSAhPT0gb3ZlcnJpZGVzW2tleV0pIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGtleSAke2tleX1gKTtcblx0XHRuZXdPYmpba2V5XSA9IG92ZXJyaWRlc1trZXldO1xuXHR9XG5cdHJldHVybiBuZXdPYmo7XG59XG4vKipcbiogQ2hlY2sgdGhhdCB2YWx1ZSBpcyBvYmplY3RcbiogQGludGVybmFsXG4qL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcblx0cmV0dXJuICEhdmFsdWUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIjtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZm4pIHtcblx0cmV0dXJuIHR5cGVvZiBmbiA9PT0gXCJmdW5jdGlvblwiO1xufVxuLyoqXG4qIENyZWF0ZSBhbiBvYmplY3Qgd2l0aG91dCBpbmhlcml0aW5nIGFueXRoaW5nIGZyb20gYE9iamVjdC5wcm90b3R5cGVgXG4qIEBpbnRlcm5hbFxuKi9cbmZ1bmN0aW9uIG9taXRQcm90b3R5cGUob2JqKSB7XG5cdHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIG9iaik7XG59XG5jb25zdCBhc3luY0l0ZXJhdG9yc1N1cHBvcnRlZCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAhIVN5bWJvbC5hc3luY0l0ZXJhdG9yO1xuZnVuY3Rpb24gaXNBc3luY0l0ZXJhYmxlKHZhbHVlKSB7XG5cdHJldHVybiBhc3luY0l0ZXJhdG9yc1N1cHBvcnRlZCAmJiBpc09iamVjdCh2YWx1ZSkgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWU7XG59XG4vKipcbiogUnVuIGFuIElJRkVcbiovXG5jb25zdCBydW4gPSAoZm4pID0+IGZuKCk7XG5mdW5jdGlvbiBub29wKCkge31cbmZ1bmN0aW9uIGlkZW50aXR5KGl0KSB7XG5cdHJldHVybiBpdDtcbn1cbi8qKlxuKiBHZW5lcmljIHJ1bnRpbWUgYXNzZXJ0aW9uIGZ1bmN0aW9uLiBUaHJvd3MsIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IGB0cnVlYC5cbipcbiogQ2FuIGJlIHVzZWQgYXMgYSBzbGlnaHRseSBsZXNzIGRhbmdlcm91cyB2YXJpYW50IG9mIHR5cGUgYXNzZXJ0aW9ucy4gQ29kZVxuKiBtaXN0YWtlcyB3b3VsZCBiZSByZXZlYWxlZCBhdCBydW50aW1lIHRoZW4gKGhvcGVmdWxseSBkdXJpbmcgdGVzdGluZykuXG4qL1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnID0gXCJubyBhZGRpdGlvbmFsIGluZm9cIikge1xuXHRpZiAoIWNvbmRpdGlvbikgdGhyb3cgbmV3IEVycm9yKGBBc3NlcnRpb25FcnJvcjogJHttc2d9YCk7XG59XG5mdW5jdGlvbiBzbGVlcChtcyA9IDApIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKChyZXMpID0+IHNldFRpbWVvdXQocmVzLCBtcykpO1xufVxuLyoqXG4qIFBvbnlmaWxsIGZvclxuKiBbYEFib3J0U2lnbmFsLmFueWBdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9BYm9ydFNpZ25hbC9hbnlfc3RhdGljKS5cbiovXG5mdW5jdGlvbiBhYm9ydFNpZ25hbHNBbnlQb255ZmlsbChzaWduYWxzKSB7XG5cdGlmICh0eXBlb2YgQWJvcnRTaWduYWwuYW55ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBBYm9ydFNpZ25hbC5hbnkoc2lnbmFscyk7XG5cdGNvbnN0IGFjID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuXHRmb3IgKGNvbnN0IHNpZ25hbCBvZiBzaWduYWxzKSB7XG5cdFx0aWYgKHNpZ25hbC5hYm9ydGVkKSB7XG5cdFx0XHR0cmlnZ2VyKCk7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0c2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJhYm9ydFwiLCB0cmlnZ2VyLCB7IG9uY2U6IHRydWUgfSk7XG5cdH1cblx0cmV0dXJuIGFjLnNpZ25hbDtcblx0ZnVuY3Rpb24gdHJpZ2dlcigpIHtcblx0XHRhYy5hYm9ydCgpO1xuXHRcdGZvciAoY29uc3Qgc2lnbmFsIG9mIHNpZ25hbHMpIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYWJvcnRcIiwgdHJpZ2dlcik7XG5cdH1cbn1cblxuLy8jZW5kcmVnaW9uXG5leHBvcnQgeyBUUlBDX0VSUk9SX0NPREVTX0JZX0tFWSwgVFJQQ19FUlJPUl9DT0RFU19CWV9OVU1CRVIsIGFib3J0U2lnbmFsc0FueVBvbnlmaWxsLCBhc3NlcnQsIGlkZW50aXR5LCBpc0FzeW5jSXRlcmFibGUsIGlzRnVuY3Rpb24sIGlzT2JqZWN0LCBtZXJnZVdpdGhvdXRPdmVycmlkZXMsIG5vb3AsIG9taXRQcm90b3R5cGUsIHJldHJ5YWJsZVJwY0NvZGVzLCBydW4sIHNsZWVwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy1DTFpuSmRiXy5tanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@trpc+server@11.7.1_typescript@5.9.3/node_modules/@trpc/server/dist/utils-CLZnJdb_.mjs\n");

/***/ })

};
;